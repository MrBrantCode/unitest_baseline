{
  "task_id": "taco_913",
  "entry_point": "get_circle_center_and_radius",
  "mutant_count": 446,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 / ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 / ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 + ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 + ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 ** ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 ** ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) * d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) * d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) // d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) // d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) * -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) * -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) // -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) // -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 3 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 3 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 1 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 1 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 0 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 0 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 1 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 1 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = -2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = -2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) + (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) + (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) * ((y1 - y2) * (x1 - x3)))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) * ((y1 - y2) * (x1 - x3)))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) + (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) + (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = (y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) * ((y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = (y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) * ((y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) + (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) + (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = (x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) * ((x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = (x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) * ((x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / +d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / +d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 - (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 - (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 * (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 * (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans = float('inf')",
      "mutated_line": "ans = float('')",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n + 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n * 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n + 2):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n + 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n * 2):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n * 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) / (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) / (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * (y1 - y3 + (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * (y1 - y3 + (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) ** (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) ** (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) / (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) / (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2 + (x1 - x3)))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2 + (x1 - x3)))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) ** (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) ** (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) / (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) / (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = (y1 - y3 + (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = (y1 - y3 + (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) ** (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) ** (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) / (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) / (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2 + (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2))) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2 + (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2))) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) ** (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) ** (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) / (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) / (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = (x1 - x3 + (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = (x1 - x3 + (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) ** (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) ** (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) / (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) / (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2 + (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2))) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2 + (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2))) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) ** (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) ** (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) * 2 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) * 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt(x - x1 + 2 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt(x - x1 + 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) * 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) * 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y - y1 + 2))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1 + 2))\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 2):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 0):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 0):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - -1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i - 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i * 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][0]) * 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) * 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][0]) // 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) // 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][1]) * 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) * 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][1]) // 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) // 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) * 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) * 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) // 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) // 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = 1",
      "mutated_line": "flag = 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 2\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 0\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 0\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = 1",
      "mutated_line": "flag = -1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = -1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag != 1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag != 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 3):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 3):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 1):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 0):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 1):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - -2):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - -2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i - 1, n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i - 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i * 1, n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i * 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 1, n + 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 1, n * 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n * 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 + y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 + y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * (y1 * y3 * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * (y1 * y3 * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 + x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 + x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 * x2) - (y1 - y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 * x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 + y2) * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 + y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) - y1 * y2 * (x1 - x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - y1 * y2 * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 + x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 + x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))",
      "mutated_line": "d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 * x3))",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 * x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 + y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 + y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = (y1 * y3 * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = (y1 * y3 * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 + x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 + x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * ((y1 ** 2 - y2 ** 2 + x1 ** 2) * x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * ((y1 ** 2 - y2 ** 2 + x1 ** 2) * x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 + y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 + y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - y1 * y2 * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - y1 * y2 * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 + x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 + x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * ((y1 ** 2 - y3 ** 2 + x1 ** 2) * x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * ((y1 ** 2 - y3 ** 2 + x1 ** 2) * x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 + x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 + x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = (x1 * x3 * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = (x1 * x3 * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 + y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 + y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * ((x1 ** 2 - x2 ** 2 + y1 ** 2) * y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * ((x1 ** 2 - x2 ** 2 + y1 ** 2) * y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 + x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 + x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - x1 * x2 * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - x1 * x2 * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 + y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 + y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * ((x1 ** 2 - x3 ** 2 + y1 ** 2) * y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * ((x1 ** 2 - x3 ** 2 + y1 ** 2) * y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x + x1) ** 2 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x + x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x * x1) ** 2 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x * x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 3 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 3 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 1 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 1 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 0 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 0 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 1 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 1 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** -2 + (y - y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** -2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y + y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y + y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y * y1) ** 2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y * y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 3)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 3)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 1)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 1)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 0)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 0)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 1)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 1)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)",
      "mutated_line": "r = math.sqrt((x - x1) ** 2 + (y - y1) ** -2)",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** -2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 0, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 0, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + -1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] - points[j][0]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] - points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = points[i][0] * points[j][0] / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = points[i][0] * points[j][0] / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][0]) / 3",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 3\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][0]) / 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 1\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][0]) / 0",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 0\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][0]) / 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 1\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][0]) / -2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / -2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] - points[j][1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] - points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = points[i][1] * points[j][1] / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = points[i][1] * points[j][1] / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][1]) / 3",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 3\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][1]) / 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 1\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][1]) / 0",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 0\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][1]) / 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 1\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][1]) / -2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / -2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 3",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 3\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 1\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 0",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 0\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 1\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / -2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / -2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if k != i and k != j:",
      "mutated_line": "if k != i or k != j:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i or k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 2:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == 0:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 0:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == 0:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 0:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == -1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == -1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 2, n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 2, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 0, n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 0, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 0, n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 0, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + -1, n - 1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + -1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 1, n - 2):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 2):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 1, n - 0):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 0):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 1, n - 0):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 0):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n - 1):",
      "mutated_line": "for j in range(i + 1, n - -1):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - -1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j - 1, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j - 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j * 1, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j * 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 - x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 - x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * ((y1 ** 2 - y2 ** 2) * x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * ((y1 ** 2 - y2 ** 2) * x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 * 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 * 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - (x2 + 2)) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - (x2 + 2)) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 - x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 - x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * ((y1 ** 2 - y3 ** 2) * x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * ((y1 ** 2 - y3 ** 2) * x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 * 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 * 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - (x3 + 2))) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - (x3 + 2))) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 - y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 - y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * ((x1 ** 2 - x2 ** 2) * y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * ((x1 ** 2 - x2 ** 2) * y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 * 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 * 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - (y2 + 2)) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - (y2 + 2)) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 - y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 - y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * ((x1 ** 2 - x3 ** 2) * y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * ((x1 ** 2 - x3 ** 2) * y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 * 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 * 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - (y3 + 2))) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - (y3 + 2))) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 - (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 - (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 * (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 * (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k != i and k != j:",
      "mutated_line": "if k == i and k != j:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k == i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k != i and k != j:",
      "mutated_line": "if k != i and k == j:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k == j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 >= r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 >= r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 <= r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 <= r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 != r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 != r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + 2, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 2, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + 0, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 0, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + 0, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 0, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + -1, n):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + -1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "flag = 1",
      "mutated_line": "flag = 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 2\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 0\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 0\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "flag = 1",
      "mutated_line": "flag = -1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = -1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag != 1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag != 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 + y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 + y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 * y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 * y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 * 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 * 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + (x1 + 2) - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + (x1 + 2) - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 3) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 3) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 1) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 1) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 0) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 0) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 1) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 1) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** -2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** -2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 + y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 + y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 * y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 * y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 * 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 * 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + (x1 + 2) - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + (x1 + 2) - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 3)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 3)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 1)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 1)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 0)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 0)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 1)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 1)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** -2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** -2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 + x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 + x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 * x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 * x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 * 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 * 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + (y1 + 2) - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + (y1 + 2) - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 3) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 3) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 1) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 1) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 0) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 0) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 1) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 1) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** -2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** -2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 + x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 + x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 * x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 * x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 * 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 * 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + (y1 + 2) - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + (y1 + 2) - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 3)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 3)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 1)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 1)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 0)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 0)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 1)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 1)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** -2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** -2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][1] + points[j][0]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][1] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][-1] + points[j][0]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][-1] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][1] + points[j][0]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][1] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][1]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][-1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][-1]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = (points[i][0] + points[j][0]) / 2",
      "mutated_line": "x = (points[i][0] + points[j][1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][1]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][2] + points[j][1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][2] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][0] + points[j][1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][0] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][0] + points[j][1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][0] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][-1] + points[j][1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][-1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][2]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][2]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][0]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][0]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][0]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][0]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y = (points[i][1] + points[j][1]) / 2",
      "mutated_line": "y = (points[i][1] + points[j][-1]) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][-1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) * 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) * 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt(points[i][0] - points[j][0] + 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt(points[i][0] - points[j][0] + 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) * 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) * 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1] + 2)) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1] + 2)) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 - (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 - (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 * (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 * (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r * 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r * 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r + 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r + 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 1\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "flag = 0",
      "mutated_line": "flag = -1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = -1\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 1\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if p != i and p != j and p != k:",
      "mutated_line": "if p != i or p != j or p != k:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i or p != j or p != k:\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 2:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == 0:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 0:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == 0:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 0:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if flag == 1:",
      "mutated_line": "if flag == -1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == -1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 * 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 * 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 + 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 + 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 * 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 * 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - (y2 + 2) + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - (y2 + 2) + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 3 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 3 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 1 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 1 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 0 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 0 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 1 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 1 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** -2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** -2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 * 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 * 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 + 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 + 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 * 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 * 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - (y3 + 2) + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - (y3 + 2) + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 3 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 3 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 1 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 1 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 0 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 0 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 1 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 1 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** -2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** -2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 * 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 * 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 + 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 + 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 * 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 * 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - (x2 + 2) + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - (x2 + 2) + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 3 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 3 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 1 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 1 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 0 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 0 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 1 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 1 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** -2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** -2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 * 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 * 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 + 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 + 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 * 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 * 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - (x3 + 2) + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - (x3 + 2) + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 3 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 3 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 1 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 1 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 0 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 0 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 1 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 1 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** -2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** -2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] + points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] + points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] * points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] * points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 3 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 3 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 1 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 1 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 0 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 0 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 1 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 1 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** -2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** -2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] + points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] + points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] * points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] * points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 3) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 3) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 1) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 1) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 0) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 0) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 1) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 1) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** -2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** -2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) * 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) * 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if x - points[k][0] + 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if x - points[k][0] + 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) * 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) * 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1] + 2) > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1] + 2) > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 3:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 3:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 1:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 0:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 0:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 1:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** -2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** -2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][1], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][1], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][-1], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][-1], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][1], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][1], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][2], points[j][0], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][2], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][0], points[j][0], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][0], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][0], points[j][0], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][0], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][-1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][-1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][1], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][1], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][-1], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][-1], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][1], points[j][1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][1], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][2], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][2], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][0], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][0], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][0], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][0], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][-1], points[k][0], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][-1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][1], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][1], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][-1], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][-1], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][1], points[k][1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][1], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][2])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][2])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][0])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][0])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][0])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][0])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "(x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][-1])",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][-1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if p != i and p != j and p != k:",
      "mutated_line": "if p == i and p != j and (p != k):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p == i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if p != i and p != j and p != k:",
      "mutated_line": "if p != i and p == j and (p != k):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p == j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if p != i and p != j and p != k:",
      "mutated_line": "if p != i and p != j and (p == k):",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p == k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 >= r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 >= r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 <= r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 <= r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 != r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 != r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 3 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 3 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 1 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 1 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 0 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 0 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 1 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 1 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** -2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** -2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 3 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 3 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 1 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 1 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 0 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 0 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 1 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 1 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** -2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** -2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 3 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 3 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 1 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 1 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 0 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 0 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 1 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 1 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** -2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** -2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 3 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 3 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 1 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 1 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 0 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 0 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 1 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 1 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d",
      "mutated_line": "x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** -2 + x1 ** 2 - x3 ** 2)) / d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** -2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 3 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 3 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 1 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 1 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 0 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 0 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 1 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 1 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** -2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** -2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 3 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 3 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 1 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 1 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 0 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 0 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 1 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 1 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** -2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** -2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 3 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 3 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 1 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 1 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 0 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 0 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 1 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 1 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** -2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** -2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 3 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 3 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 1 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 1 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 0 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 0 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 1 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 1 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d",
      "mutated_line": "y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** -2 + y1 ** 2 - y3 ** 2)) / -d",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** -2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x + points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x + points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x * points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x * points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 3 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 3 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 1 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 1 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 0 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 0 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 1 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 1 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** -2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** -2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y + points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y + points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y * points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y * points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 3 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 3 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 1 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 1 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 0 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 0 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 1 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 1 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** -2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** -2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 - (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 - (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 * (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 * (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r * 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r * 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r + 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r + 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 1\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "flag = 0",
      "mutated_line": "flag = -1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = -1\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 1\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][1] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][1] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][-1] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][-1] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][1] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][1] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][1]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][1]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][-1]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][-1]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][1]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][1]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][2] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][2] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][0] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][0] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][0] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][0] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][-1] - points[j][1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][-1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][2]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][2]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][0]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][0]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][0]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][0]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2",
      "mutated_line": "r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][-1]) ** 2) / 2",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][-1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) * 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) * 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if x - points[p][0] + 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if x - points[p][0] + 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) * 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) * 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1] + 2) > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1] + 2) > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 3:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 3:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 1:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 0:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 0:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 1:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 1:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** -2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** -2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][1]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][1]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][-1]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][-1]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][1]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][1]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][2]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][2]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][0]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][0]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][0]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][0]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[k][0]) ** 2 + (y - points[k][-1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][-1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x + points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x + points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x * points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x * points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 3 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 3 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 1 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 1 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 0 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 0 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 1 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 1 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** -2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** -2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y + points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y + points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y * points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y * points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 3 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 3 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 1 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 1 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 0 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 0 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 1 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 1 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** -2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][1]) ** -2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][1]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][1]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][-1]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][-1]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][1]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][1]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][2]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][2]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][0]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][0]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][0]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][0]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if (x - points[p][0]) ** 2 + (y - points[p][1]) ** 2 > r ** 2:",
      "mutated_line": "if (x - points[p][0]) ** 2 + (y - points[p][-1]) ** 2 > r ** 2:",
      "code": "import math\n\ndef get_circle_center_and_radius(x1, y1, x2, y2, x3, y3):\n    d = 2 * ((y1 - y3) * (x1 - x2) - (y1 - y2) * (x1 - x3))\n    x = ((y1 - y3) * (y1 ** 2 - y2 ** 2 + x1 ** 2 - x2 ** 2) - (y1 - y2) * (y1 ** 2 - y3 ** 2 + x1 ** 2 - x3 ** 2)) / d\n    y = ((x1 - x3) * (x1 ** 2 - x2 ** 2 + y1 ** 2 - y2 ** 2) - (x1 - x2) * (x1 ** 2 - x3 ** 2 + y1 ** 2 - y3 ** 2)) / -d\n    r = math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    return (x, y, r)\n\ndef find_minimum_circle_radius(points):\n    n = len(points)\n    ans = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = (points[i][0] + points[j][0]) / 2\n            y = (points[i][1] + points[j][1]) / 2\n            r = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) / 2\n            flag = 1\n            for k in range(n):\n                if k != i and k != j:\n                    if (x - points[k][0]) ** 2 + (y - points[k][1]) ** 2 > r ** 2:\n                        flag = 0\n                        break\n            if flag == 1:\n                ans = min(r, ans)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                try:\n                    (x, y, r) = get_circle_center_and_radius(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                    flag = 1\n                    for p in range(n):\n                        if p != i and p != j and (p != k):\n                            if (x - points[p][0]) ** 2 + (y - points[p][-1]) ** 2 > r ** 2:\n                                flag = 0\n                                break\n                    if flag == 1:\n                        ans = min(r, ans)\n                except:\n                    continue\n    return ans"
    }
  ]
}