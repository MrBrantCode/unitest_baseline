{
  "task_id": "taco_19036",
  "entry_point": "minimum_total_pairwise_distance",
  "mutant_count": 317,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 or d2 == 0 or d3 == 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 or d2 == 0 or d3 == 0:\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 or d2 > 0 or d3 > 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 or d2 > 0 or d3 > 0:\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d1 == 0:",
      "mutated_line": "if d1 != 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 != 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if d2 == 0:",
      "mutated_line": "if d2 != 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 != 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if d3 == 0:",
      "mutated_line": "if d3 != 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 != 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return d1 + d2 - d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 - d3"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return (d1 + d2) * d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return (d1 + d2) * d3"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] + positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] + positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] * positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] * positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] + positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] + positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] * positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] * positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] + positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] + positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] * positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] * positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 != 0 and d2 == 0 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 != 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 != 0 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 != 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 == 0 and (d3 != 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 != 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 1\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return -1\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 1\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 >= 0 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 >= 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 <= 0 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 <= 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 != 0 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 != 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 >= 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 >= 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 <= 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 <= 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 != 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 != 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 >= 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 >= 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 <= 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 <= 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 != 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 != 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d1 > d2:",
      "mutated_line": "if d1 >= d2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 >= d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d1 > d2:",
      "mutated_line": "if d1 <= d2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 <= d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d1 > d2:",
      "mutated_line": "if d1 != d2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 != d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] -= 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] += 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] += 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return d1 + d2 - d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 - d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return (d1 + d2) * d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return (d1 + d2) * d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d1 == 0:",
      "mutated_line": "if d1 == 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 1:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d1 == 0:",
      "mutated_line": "if d1 == -1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == -1:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d1 == 0:",
      "mutated_line": "if d1 == 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 1:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] != positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] != positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if d2 == 0:",
      "mutated_line": "if d2 == 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 1:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if d2 == 0:",
      "mutated_line": "if d2 == -1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == -1:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if d2 == 0:",
      "mutated_line": "if d2 == 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 1:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] != positions[1] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] != positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if d3 == 0:",
      "mutated_line": "if d3 == 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 1:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if d3 == 0:",
      "mutated_line": "if d3 == -1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == -1:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if d3 == 0:",
      "mutated_line": "if d3 == 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 1:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] != positions[0] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] != positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return d1 - d2 + d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 - d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return d1 * d2 + d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 * d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 1 and d2 == 0 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 1 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == -1 and d2 == 0 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == -1 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 1 and d2 == 0 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 1 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 == 1 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 1 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 == -1 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == -1 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 == 1 and (d3 == 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 1 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 == 0 and (d3 == 1):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 1):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 == 0 and (d3 == -1):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == -1):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d1 == 0 and d2 == 0 and d3 == 0:",
      "mutated_line": "if d1 == 0 and d2 == 0 and (d3 == 1):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 1):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 1 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 1 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > -1 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > -1 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 1 and d2 > 0 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 1 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 1 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 1 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > -1 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > -1 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 1 and (d3 > 0):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 1 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 > 1):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 1):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 > -1):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > -1):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d1 > 0 and d2 > 0 and d3 > 0:",
      "mutated_line": "if d1 > 0 and d2 > 0 and (d3 > 1):",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 1):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 2\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 0\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 0\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += -1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[1] -= 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 2\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[1] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 0\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[1] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 0\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[1] -= -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= -1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 2\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 0\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 0\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= -1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif d1 < d2:",
      "mutated_line": "elif d1 <= d2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 <= d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif d1 < d2:",
      "mutated_line": "elif d1 >= d2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 >= d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif d1 < d2:",
      "mutated_line": "elif d1 != d2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 != d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] -= 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] += 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] -= 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] -= 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] += 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] + positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] + positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] * positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] * positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] + positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] + positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] * positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] * positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] + positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] + positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] * positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] * positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return d1 - d2 + d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 - d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return d1 + d2 + d3",
      "mutated_line": "return d1 * d2 + d3",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 * d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[1] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[1] * 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] * 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 1\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return -1\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 1\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 / (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 / (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 + (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 + (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 ** (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 ** (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[1] * 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] * 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 1\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return -1\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 1\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 / (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 / (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 + (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 + (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 ** (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 ** (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[0] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[0] * 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] * 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 1\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return -1\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 1\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 / (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 / (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 + (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 + (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 ** (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 ** (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[1] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[-1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[-1] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[1] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[2])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[0])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[0])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[-1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[-1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[2] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[2] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[0] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[0] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[0] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[0] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[-1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[-1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[3])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[3])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[1])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[0])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[1])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[-2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[-2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[1] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[-1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[-1] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[1] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[3])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[3])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[1])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[0])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[1])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[-2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[-2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[1] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[-1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[-1] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[1] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[2] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[2] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[0] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[0] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "positions[1] -= 1",
      "mutated_line": "positions[-1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[-1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[3] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[3] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[1] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[0] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[1] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[-2] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[-2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[1] += 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 2\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[1] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 0\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[1] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 0\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[1] += -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += -1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 2\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 0\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 0\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= -1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 2\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 0\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 0\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += -1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 2\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 0\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 0\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[0] += -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += -1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 2",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 2\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 0\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= 0",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 0\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[2] -= -1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= -1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[3] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[3] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[1] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[1] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[0] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[0] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[1] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[1] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[-2] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[-2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[1] + 2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 2:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[1] + 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 0:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[1] + 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 0:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[1] + -1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + -1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 3 * (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 3 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 1 * (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 1 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 0 * (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 0 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 1 * (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 1 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return -2 * (positions[2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return -2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[1] + 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] + 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * ((positions[2] - positions[1]) * 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * ((positions[2] - positions[1]) * 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[1] == positions[1] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[1] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[-1] == positions[1] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[-1] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[1] == positions[1] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[1] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[1] - 2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 2:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[1] - 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 0:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[1] - 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 0:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[1] - -1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - -1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 3 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 3 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 1 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 1 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 0 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 0 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 1 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 1 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return -2 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return -2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] + 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] + 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * ((positions[1] - positions[0]) * 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * ((positions[1] - positions[0]) * 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[2] == positions[0] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[2] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[0] == positions[0] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[0] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[0] == positions[0] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[0] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[-1] == positions[0] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[-1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[0] + 2:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 2:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[0] + 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 0:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[0] + 0:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 0:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[0] + -1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + -1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 3 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 3 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 1 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 1 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 0 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 0 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 1 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 1 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return -2 * (positions[1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return -2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] + 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] + 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * ((positions[1] - positions[0]) * 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * ((positions[1] - positions[0]) * 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[2] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[2] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[0] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[0] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[0] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[0] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "positions[1] += 1",
      "mutated_line": "positions[-1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[-1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[3] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[3] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[1] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[0] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[1] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[-2] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[-2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[1] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[-1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[-1] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[1] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[1] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[-1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[-1] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "positions[0] += 1",
      "mutated_line": "positions[1] += 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[1] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[3] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[3] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[1] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[0] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[0] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[1] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[1] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "positions[2] -= 1",
      "mutated_line": "positions[-2] -= 1",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[-2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[1] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[-1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[-1] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[1] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[2])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[0])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[0])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = abs(positions[0] - positions[1])",
      "mutated_line": "d1 = abs(positions[0] - positions[-1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[-1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[2] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[2] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[0] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[0] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[0] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[0] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[-1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[-1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[3])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[3])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[1])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[0])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[1])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = abs(positions[1] - positions[2])",
      "mutated_line": "d2 = abs(positions[1] - positions[-2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[-2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[1] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[-1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[-1] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[1] - positions[2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[1] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[3])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[3])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[1])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[0])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[0])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[1])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[1])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d3 = abs(positions[0] - positions[2])",
      "mutated_line": "d3 = abs(positions[0] - positions[-2])",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[-2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[2] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[2] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[0] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[0] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if positions[2] == positions[1] + 1:",
      "mutated_line": "if positions[2] == positions[-1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[-1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] + positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] + positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] * positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] * positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[1] - 2)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 2)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[1] - 0)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 0)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[1] - 0)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 0)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[1] - -1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - -1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[2] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[2] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[0] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[0] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[0] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[0] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if positions[0] == positions[1] - 1:",
      "mutated_line": "if positions[0] == positions[-1] - 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[-1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] + positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] + positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] * positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] * positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - 2)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 2)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - 0)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 0)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - 0)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 0)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - -1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - -1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[-1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[-1] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if positions[1] == positions[0] + 1:",
      "mutated_line": "if positions[1] == positions[1] + 1:",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] + positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] + positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] * positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] * positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - 2)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 2)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - 0)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 0)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - 0)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 0)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[0] - -1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - -1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[3] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[3] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[0] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[0] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[-2] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[-2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[2] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[2] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[0] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[0] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2 * (positions[2] - positions[1] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[-1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[-1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[0] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[0] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[0] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[0] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[-1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[-1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[1] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[-1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[-1] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[1] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[2] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[0] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[0] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[0] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[0] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[-1] - positions[0] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[-1] - positions[0] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[1] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[-1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[-1] - 1)\n    return d1 + d2 + d3"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 2 * (positions[1] - positions[0] - 1)",
      "mutated_line": "return 2 * (positions[1] - positions[1] - 1)",
      "code": "def minimum_total_pairwise_distance(a, b, c):\n    positions = [a, b, c]\n    positions.sort()\n    d1 = abs(positions[0] - positions[1])\n    d2 = abs(positions[1] - positions[2])\n    d3 = abs(positions[0] - positions[2])\n    if d1 == 0 and d2 == 0 and (d3 == 0):\n        return 0\n    if d1 > 0 and d2 > 0 and (d3 > 0):\n        if d1 > d2:\n            positions[0] += 1\n            positions[1] -= 1\n            positions[2] -= 1\n        elif d1 < d2:\n            positions[1] += 1\n            positions[2] -= 1\n            positions[0] += 1\n        else:\n            positions[0] += 1\n            positions[2] -= 1\n        d1 = abs(positions[0] - positions[1])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[0] - positions[2])\n        return d1 + d2 + d3\n    if d1 == 0:\n        if positions[2] == positions[1] + 1:\n            return 0\n        else:\n            return 2 * (positions[2] - positions[1] - 1)\n    if d2 == 0:\n        if positions[0] == positions[1] - 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[0] - 1)\n    if d3 == 0:\n        if positions[1] == positions[0] + 1:\n            return 0\n        else:\n            return 2 * (positions[1] - positions[1] - 1)\n    return d1 + d2 + d3"
    }
  ]
}