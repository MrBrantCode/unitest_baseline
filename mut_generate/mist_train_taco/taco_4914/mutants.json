{
  "task_id": "taco_4914",
  "entry_point": "calculate_dominating_colours_sum",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] - [None] * (n - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] - [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] * ([None] * (n - 1))",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] * ([None] * (n - 1))\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "parent = [None] * n",
      "mutated_line": "parent = [None] / n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] / n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "parent = [None] * n",
      "mutated_line": "parent = [None] + n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] + n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "parent = [None] * n",
      "mutated_line": "parent = [None] ** n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] ** n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 1\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "index = 0",
      "mutated_line": "index = -1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = -1\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 1\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while index < len(que):",
      "mutated_line": "while index <= len(que):",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index <= len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while index < len(que):",
      "mutated_line": "while index >= len(que):",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index >= len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while index < len(que):",
      "mutated_line": "while index != len(que):",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index != len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "index += 1",
      "mutated_line": "index -= 1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index -= 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "answer = [0] * n",
      "mutated_line": "answer = [0] / n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] / n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "answer = [0] * n",
      "mutated_line": "answer = [0] + n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] + n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "answer = [0] * n",
      "mutated_line": "answer = [0] ** n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] ** n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] / (n - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] / (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + ([None] + (n - 1))",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + ([None] + (n - 1))\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] ** (n - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] ** (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [0]",
      "mutated_line": "que = [1]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [1]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [0]",
      "mutated_line": "que = [-1]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [-1]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [0]",
      "mutated_line": "que = [1]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [1]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "index += 1",
      "mutated_line": "index += 2",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 2\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 0\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 0\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "index += 1",
      "mutated_line": "index += -1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += -1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if val > 0:",
      "mutated_line": "if val >= 0:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val >= 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if val > 0:",
      "mutated_line": "if val <= 0:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val <= 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if val > 0:",
      "mutated_line": "if val != 0:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val != 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "self[bb] += val",
      "mutated_line": "self[bb] -= val",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] -= val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 1].append(b + 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b + 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 1].append(b * 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b * 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 1].append(a + 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a + 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 1].append(a * 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a * 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [1] + [None] * (n - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [1] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [-1] + [None] * (n - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [-1] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [1] + [None] * (n - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [1] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] * (n + 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n + 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] * (n * 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n * 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if depth[b] is None:",
      "mutated_line": "if depth[b] is not None:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is not None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "order = sorted(((depth[i], i) for i in range(n)), reverse=True)",
      "mutated_line": "order = sorted(((depth[i], i) for i in range(n)), reverse=False)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=False)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = [0] * n",
      "mutated_line": "answer = [1] * n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [1] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = [0] * n",
      "mutated_line": "answer = [-1] * n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [-1] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = [0] * n",
      "mutated_line": "answer = [1] * n",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [1] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if val > 0:",
      "mutated_line": "if val > 1:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 1:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if val > 0:",
      "mutated_line": "if val > -1:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > -1:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if val > 0:",
      "mutated_line": "if val > 1:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 1:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if self[bb] > self.mx:",
      "mutated_line": "if self[bb] >= self.mx:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] >= self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if self[bb] > self.mx:",
      "mutated_line": "if self[bb] <= self.mx:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] <= self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if self[bb] > self.mx:",
      "mutated_line": "if self[bb] != self.mx:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] != self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 1].append(b - 2)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 2)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 1].append(b - 0)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 0)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 1].append(b - 0)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 0)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 1].append(b - -1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - -1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 1].append(a - 2)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 2)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 1].append(a - 0)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 0)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 1].append(a - 0)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 0)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 1].append(a - -1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - -1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] * (n - 2)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 2)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] * (n - 0)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 0)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] * (n - 0)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 0)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "depth = [0] + [None] * (n - 1)",
      "mutated_line": "depth = [0] + [None] * (n - -1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - -1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "depth[b] = depth[curr] + 1",
      "mutated_line": "depth[b] = depth[curr] - 1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] - 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "depth[b] = depth[curr] + 1",
      "mutated_line": "depth[b] = depth[curr] * 1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] * 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]",
      "mutated_line": "cols = [SumDefaultdict({colours[i]: 2}) for i in range(n)]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 2}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]",
      "mutated_line": "cols = [SumDefaultdict({colours[i]: 0}) for i in range(n)]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 0}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]",
      "mutated_line": "cols = [SumDefaultdict({colours[i]: 0}) for i in range(n)]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 0}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]",
      "mutated_line": "cols = [SumDefaultdict({colours[i]: -1}) for i in range(n)]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: -1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)",
      "mutated_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=False)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=False)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(1, len(children)):",
      "mutated_line": "for j in range(2, len(children)):",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(2, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(1, len(children)):",
      "mutated_line": "for j in range(0, len(children)):",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(0, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(1, len(children)):",
      "mutated_line": "for j in range(0, len(children)):",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(0, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(1, len(children)):",
      "mutated_line": "for j in range(-1, len(children)):",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(-1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "cols[i] = children[0]",
      "mutated_line": "cols[i] = children[1]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[1]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "cols[i] = children[0]",
      "mutated_line": "cols[i] = children[-1]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[-1]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "cols[i] = children[0]",
      "mutated_line": "cols[i] = children[1]",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[1]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))",
      "mutated_line": "self.mx_sum = sum((c for (c, v) in self.items() if v != self.mx))",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v != self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif self[bb] == self.mx:",
      "mutated_line": "elif self[bb] != self.mx:",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] != self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "self.mx_sum += bb",
      "mutated_line": "self.mx_sum -= bb",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum -= bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a + 1].append(b - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a + 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a * 1].append(b - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a * 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b + 1].append(a - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b + 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b * 1].append(a - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b * 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "depth[b] = depth[curr] + 1",
      "mutated_line": "depth[b] = depth[curr] + 2",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 2\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "depth[b] = depth[curr] + 1",
      "mutated_line": "depth[b] = depth[curr] + 0",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 0\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "depth[b] = depth[curr] + 1",
      "mutated_line": "depth[b] = depth[curr] + 0",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 0\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "depth[b] = depth[curr] + 1",
      "mutated_line": "depth[b] = depth[curr] + -1",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + -1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)",
      "mutated_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] >= d], key=len, reverse=True)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] >= d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)",
      "mutated_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] <= d], key=len, reverse=True)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] <= d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)",
      "mutated_line": "children = sorted([cols[b] for b in adjacency_list[i] if depth[b] != d], key=len, reverse=True)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] != d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "children[0].sumadd({colours[i]: 1})",
      "mutated_line": "children[0].sumadd({colours[i]: 2})",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 2})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "children[0].sumadd({colours[i]: 1})",
      "mutated_line": "children[0].sumadd({colours[i]: 0})",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 0})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "children[0].sumadd({colours[i]: 1})",
      "mutated_line": "children[0].sumadd({colours[i]: 0})",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 0})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "children[0].sumadd({colours[i]: 1})",
      "mutated_line": "children[0].sumadd({colours[i]: -1})",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: -1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 2].append(b - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 2].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 0].append(b - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 0].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - 0].append(b - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 0].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adjacency_list[a - 1].append(b - 1)",
      "mutated_line": "adjacency_list[a - -1].append(b - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - -1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 2].append(a - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 2].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 0].append(a - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 0].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - 0].append(a - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 0].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adjacency_list[b - 1].append(a - 1)",
      "mutated_line": "adjacency_list[b - -1].append(a - 1)",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - -1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "children[0].sumadd({colours[i]: 1})",
      "mutated_line": "children[1].sumadd({colours[i]: 1})",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[1].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "children[0].sumadd({colours[i]: 1})",
      "mutated_line": "children[-1].sumadd({colours[i]: 1})",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[-1].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "children[0].sumadd({colours[i]: 1})",
      "mutated_line": "children[1].sumadd({colours[i]: 1})",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[0].sumadd(children[j])\n            children[1].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "children[0].sumadd(children[j])",
      "mutated_line": "children[1].sumadd(children[j])",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[1].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "children[0].sumadd(children[j])",
      "mutated_line": "children[-1].sumadd(children[j])",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[-1].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "children[0].sumadd(children[j])",
      "mutated_line": "children[1].sumadd(children[j])",
      "code": "from collections import defaultdict\n\nclass SumDefaultdict(defaultdict):\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(int, *args, **kwargs)\n        self.mx = max(self.values())\n        self.mx_sum = sum((c for (c, v) in self.items() if v == self.mx))\n\n    def sumadd(self, map):\n        for (bb, val) in map.items():\n            if val > 0:\n                self[bb] += val\n                if self[bb] > self.mx:\n                    self.mx = self[bb]\n                    self.mx_sum = bb\n                elif self[bb] == self.mx:\n                    self.mx_sum += bb\n\ndef calculate_dominating_colours_sum(n, colours, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (a, b) in edges:\n        adjacency_list[a - 1].append(b - 1)\n        adjacency_list[b - 1].append(a - 1)\n    depth = [0] + [None] * (n - 1)\n    parent = [None] * n\n    que = [0]\n    index = 0\n    while index < len(que):\n        curr = que[index]\n        for b in adjacency_list[curr]:\n            if depth[b] is None:\n                depth[b] = depth[curr] + 1\n                parent[b] = curr\n                que.append(b)\n        index += 1\n    order = sorted(((depth[i], i) for i in range(n)), reverse=True)\n    cols = [SumDefaultdict({colours[i]: 1}) for i in range(n)]\n    answer = [0] * n\n    for (d, i) in order:\n        children = sorted([cols[b] for b in adjacency_list[i] if depth[b] > d], key=len, reverse=True)\n        if children:\n            for j in range(1, len(children)):\n                children[1].sumadd(children[j])\n            children[0].sumadd({colours[i]: 1})\n            cols[i] = children[0]\n        answer[i] = cols[i].mx_sum\n    return answer"
    }
  ]
}