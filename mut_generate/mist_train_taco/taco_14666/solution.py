"""
QUESTION:
Chef recently took a course in linear algebra and learned about linear combinations of vectors. Therefore, in order to test his intelligence, Raj gave him a "fuzzy" problem to solve.
A sequence of integers $B_1, B_2, \ldots, B_M$ generates an integer $K$ if it is possible to find a sequence of integers $C_1, C_2, \ldots, C_M$ such that $C_1 \cdot B_1 + C_2 \cdot B_2 + \ldots + C_M \cdot B_M = K$.
In this problem, Chef has a sequence $A_1, A_2, \ldots, A_N$ and he should answer $Q$ queries. In each query, he is given an integer $K$; the answer to this query is the number of pairs $(l, r)$ such that $1 \le l \le r \le N$ and the subsequence $(A_l, A_{l+1}, \ldots, A_r)$ generates $K$.
Chef has no idea how to solve this problem ― can you help him find the answers to all queries?

-----Input-----
- The first line of the input contains a single integer $N$.
- The second line contains $N$ space-separated integers $A_1, A_2, \ldots, A_N$.
- The third line contains a single integer $Q$.
- The following $Q$ lines describe queries. Each of these lines contains a single integer $K$.

-----Output-----
For each query, print a single line containing one integer ― the number of contiguous subsequences that generate $K$.

-----Constraints-----
- $1 \le N, Q \le 10^5$
- $1 \le A_i \le 10^9$ for each valid $i$
- $1 \le K \le 10^6$

-----Subtasks-----
Subtask #1 (10 points): $1 \le N \le 1,000$
Subtask #2 (90 points): original constraints

-----Example Input-----
2
2 4
3
1
2
8

-----Example Output-----
0
2
3

-----Explanation-----
The sequence $(2, 4)$ has three contiguous subsequences: $(2)$, $(4)$ and $(2, 4)$. 
- In the first query, $1$ cannot be generated by any subsequence.
- In the second query, $2$ is generated by subsequences $(2)$ and $(2, 4)$. For example, for the subsequence $(2, 4)$, we can choose $C_1 = 1$ and $C_2 = 0$.
- In the third query, $8$ is generated by all three subsequences.
"""

import math as mt

def count_subsequences_generating_k(N, A, queries):
    sz = 1000501
    x = [0] * sz
    gcs = [0] * N
    
    # Calculate gcs array
    gcs[N - 1] = A[N - 1]
    for i in range(N - 2, -1, -1):
        gcs[i] = mt.gcd(gcs[i + 1], A[i])
    
    # Populate x array
    for i in range(N):
        curr = A[i]
        if curr < sz:
            x[curr] += 1
        for j in range(i + 1, N):
            curr = mt.gcd(curr, A[j])
            if curr == gcs[j]:
                x[curr] += N - j
                break
            elif curr < sz:
                x[curr] += 1
    
    # Process queries
    results = []
    for q1 in queries:
        ans = 0
        for t in range(1, int(mt.sqrt(q1) + 1)):
            if q1 % t == 0:
                if q1 // t == t:
                    ans += x[t]
                else:
                    ans += x[t]
                    ans += x[q1 // t]
        results.append(ans)
    
    return results