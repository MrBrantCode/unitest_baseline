{
  "task_id": "taco_9412",
  "entry_point": "pre_order_traversal",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if output is None:",
      "mutated_line": "if output is not None:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is not None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if root is not None:",
      "mutated_line": "if root is None:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(node_address) == 0:",
      "mutated_line": "if len(node_address) != 0:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) != 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if B == 0:",
      "mutated_line": "if B != 0:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B != 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if C == 0:",
      "mutated_line": "if C != 0:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C != 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(node_address) == 0:",
      "mutated_line": "if len(node_address) == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 1:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(node_address) == 0:",
      "mutated_line": "if len(node_address) == -1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == -1:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(node_address) == 0:",
      "mutated_line": "if len(node_address) == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 1:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if B == 0:",
      "mutated_line": "if B == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 1:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if B == 0:",
      "mutated_line": "if B == -1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == -1:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if B == 0:",
      "mutated_line": "if B == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 1:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if C == 0:",
      "mutated_line": "if C == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 1:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if C == 0:",
      "mutated_line": "if C == -1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == -1:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if C == 0:",
      "mutated_line": "if C == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 1:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(relations) == 0:",
      "mutated_line": "if len(relations) != 0:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) != 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(relations) == 0:",
      "mutated_line": "if len(relations) == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 1:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(relations) == 0:",
      "mutated_line": "if len(relations) == -1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == -1:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(relations) == 0:",
      "mutated_line": "if len(relations) == 1:",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 1:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "output = ['1']",
      "mutated_line": "output = ['']",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[0]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "root = list(node_address.values())[0]",
      "mutated_line": "root = list(node_address.values())[1]",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[1]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "root = list(node_address.values())[0]",
      "mutated_line": "root = list(node_address.values())[-1]",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[-1]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "root = list(node_address.values())[0]",
      "mutated_line": "root = list(node_address.values())[1]",
      "code": "from collections import OrderedDict\n\nclass TreeNode:\n\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef pre_order_traversal(root, output=None):\n    if output is None:\n        output = []\n    if root is not None:\n        output.append(str(root.value))\n        pre_order_traversal(root.left, output)\n        pre_order_traversal(root.right, output)\n    return output\n\ndef fill_nodes(node_values, node_address):\n    (A, B, C) = node_values\n    if len(node_address) == 0:\n        temp = TreeNode(A)\n        node_address[A] = temp\n    else:\n        temp = node_address.get(A)\n    if B == 0:\n        left = None\n    else:\n        left = TreeNode(B)\n    if C == 0:\n        right = None\n    else:\n        right = TreeNode(C)\n    temp.left = left\n    temp.right = right\n    node_address[B] = left\n    node_address[C] = right\n    return node_address\n\ndef silly_snail_traversal(test_cases):\n    result = []\n    for relations in test_cases:\n        node_address = OrderedDict()\n        if len(relations) == 0:\n            output = ['1']\n        else:\n            for node_values in relations:\n                node_address = fill_nodes(node_values, node_address)\n            root = list(node_address.values())[1]\n            output = pre_order_traversal(root)\n        result.append(output)\n    return result"
    }
  ]
}