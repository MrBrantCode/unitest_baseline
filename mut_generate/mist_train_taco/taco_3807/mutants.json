{
  "task_id": "taco_3807",
  "entry_point": "find_treasure_door",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if key_number_a > key_number_b:",
      "mutated_line": "if key_number_a >= key_number_b:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a >= key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if key_number_a > key_number_b:",
      "mutated_line": "if key_number_a <= key_number_b:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a <= key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if key_number_a > key_number_b:",
      "mutated_line": "if key_number_a != key_number_b:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a != key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "factor = 2",
      "mutated_line": "factor = 3",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 3\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "factor = 2",
      "mutated_line": "factor = 1",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 1\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "factor = 2",
      "mutated_line": "factor = 0",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 0\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "factor = 2",
      "mutated_line": "factor = 1",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 1\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "factor = 2",
      "mutated_line": "factor = -2",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = -2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor != 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor != 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "factor = 3",
      "mutated_line": "factor = 4",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 4\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "factor = 3",
      "mutated_line": "factor = 2",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 2\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "factor = 3",
      "mutated_line": "factor = 0",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 0\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "factor = 3",
      "mutated_line": "factor = 1",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 1\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "factor = 3",
      "mutated_line": "factor = -3",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = -3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while factor * factor <= n:",
      "mutated_line": "while factor * factor < n:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor < n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while factor * factor <= n:",
      "mutated_line": "while factor * factor > n:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor > n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while factor * factor <= n:",
      "mutated_line": "while factor * factor == n:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor == n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "factor += 2",
      "mutated_line": "factor -= 2",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor -= 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if n > 1:",
      "mutated_line": "if n >= 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n >= 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if n > 1:",
      "mutated_line": "if n <= 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n <= 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if n > 1:",
      "mutated_line": "if n != 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n != 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(prime_factors) == 1:",
      "mutated_line": "if len(prime_factors) != 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) != 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 'a'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return ''\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 'b'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return ''"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n * factor == 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n * factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n + factor == 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n + factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor == 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 1:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor == -1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == -1:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor == 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 1:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while factor * factor <= n:",
      "mutated_line": "while factor / factor <= n:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor / factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while factor * factor <= n:",
      "mutated_line": "while factor + factor <= n:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor + factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while factor * factor <= n:",
      "mutated_line": "while factor ** factor <= n:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor ** factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor != 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor != 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "factor += 2",
      "mutated_line": "factor += 3",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 3\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "factor += 2",
      "mutated_line": "factor += 1",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 1\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "factor += 2",
      "mutated_line": "factor += 0",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 0\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "factor += 2",
      "mutated_line": "factor += 1",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 1\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "factor += 2",
      "mutated_line": "factor += -2",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += -2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 2:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 2:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 0:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 0:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if n > 1:",
      "mutated_line": "if n > -1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > -1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if len(prime_factors) == 1:",
      "mutated_line": "if len(prime_factors) == 2:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 2:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if len(prime_factors) == 1:",
      "mutated_line": "if len(prime_factors) == 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 0:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if len(prime_factors) == 1:",
      "mutated_line": "if len(prime_factors) == 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 0:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if len(prime_factors) == 1:",
      "mutated_line": "if len(prime_factors) == -1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == -1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[0] + sum(prime_factors[1:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] + sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[0] * sum(prime_factors[1:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] * sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n * factor == 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n * factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n + factor == 0:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n + factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor == 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 1:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor == -1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == -1:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while n % factor == 0:",
      "mutated_line": "while n % factor == 1:",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 1:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "prime_factors.sort(reverse=True)",
      "mutated_line": "prime_factors.sort(reverse=False)",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=False)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return prime_factors[0]",
      "mutated_line": "return prime_factors[1]",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[1]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return prime_factors[0]",
      "mutated_line": "return prime_factors[-1]",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[-1]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return prime_factors[0]",
      "mutated_line": "return prime_factors[1]",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[1]\n        else:\n            return prime_factors[0] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[1] - sum(prime_factors[1:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[1] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[-1] - sum(prime_factors[1:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[-1] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[1] - sum(prime_factors[1:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[1] - sum(prime_factors[1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[0] - sum(prime_factors[2:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[2:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[0] - sum(prime_factors[0:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[0:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[0] - sum(prime_factors[0:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[0:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return prime_factors[0] - sum(prime_factors[1:])",
      "mutated_line": "return prime_factors[0] - sum(prime_factors[-1:])",
      "code": "import math\n\ndef find_treasure_door(a: int, b: int) -> str:\n    \"\"\"\n    Determines which door leads to the treasure repository based on the key number calculation.\n\n    Parameters:\n    a (int): The integer associated with the first door.\n    b (int): The integer associated with the second door.\n\n    Returns:\n    str: 'a' if the first door leads to the treasure repository, 'b' otherwise.\n    \"\"\"\n\n    def get_prime_factors(n: int) -> list:\n        \"\"\"\n        Returns a list of unique prime factors of the given integer n.\n        \"\"\"\n        prime_factors = []\n        factor = 2\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                prime_factors.append(factor)\n                n //= factor\n            factor += 2\n        if n > 1:\n            prime_factors.append(n)\n        return list(set(prime_factors))\n\n    def calculate_key_number(prime_factors: list) -> int:\n        \"\"\"\n        Calculates the key number based on the prime factors.\n        \"\"\"\n        prime_factors.sort(reverse=True)\n        if len(prime_factors) == 1:\n            return prime_factors[0]\n        else:\n            return prime_factors[0] - sum(prime_factors[-1:])\n    prime_factors_a = get_prime_factors(a)\n    prime_factors_b = get_prime_factors(b)\n    key_number_a = calculate_key_number(prime_factors_a)\n    key_number_b = calculate_key_number(prime_factors_b)\n    if key_number_a > key_number_b:\n        return 'a'\n    else:\n        return 'b'"
    }
  ]
}