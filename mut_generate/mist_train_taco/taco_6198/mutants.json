{
  "task_id": "taco_6198",
  "entry_point": "can_reach_in_k_steps",
  "mutant_count": 115,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Path = namedtuple('Path', 'length midlength middle left right')",
      "mutated_line": "Path = namedtuple('', 'length midlength middle left right')",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "Path = namedtuple('Path', 'length midlength middle left right')",
      "mutated_line": "Path = namedtuple('Path', '')",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', '')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "l = path.length + 1",
      "mutated_line": "l = path.length - 1",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length - 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "l = path.length + 1",
      "mutated_line": "l = path.length * 1",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length * 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l > 2 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l > 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l < 2 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l < 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l == 2 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l == 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if not x or not y:",
      "mutated_line": "if not x and (not y):",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x and (not y):\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while x.midlength > y.midlength:",
      "mutated_line": "while x.midlength >= y.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength >= y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while x.midlength > y.midlength:",
      "mutated_line": "while x.midlength <= y.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength <= y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while x.midlength > y.midlength:",
      "mutated_line": "while x.midlength != y.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength != y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while y.midlength > x.midlength:",
      "mutated_line": "while y.midlength >= x.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength >= x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while y.midlength > x.midlength:",
      "mutated_line": "while y.midlength <= x.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength <= x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while y.midlength > x.midlength:",
      "mutated_line": "while y.midlength != x.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength != x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if x.middle == y.middle:",
      "mutated_line": "if x.middle != y.middle:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle != y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length + 2 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length + 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return (px.length + py.length) * (2 * gcp(px, py))",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return (px.length + py.length) * (2 * gcp(px, py))\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l = path.length + 1",
      "mutated_line": "l = path.length + 2",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 2\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l = path.length + 1",
      "mutated_line": "l = path.length + 0",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 0\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l = path.length + 1",
      "mutated_line": "l = path.length + 0",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 0\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l = path.length + 1",
      "mutated_line": "l = path.length + -1",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + -1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= 2 / path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 / path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= 2 + path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 + path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= 2 ** path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 ** path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [(1, 0)]",
      "mutated_line": "queue = [(2, 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(2, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [(1, 0)]",
      "mutated_line": "queue = [(0, 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(0, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [(1, 0)]",
      "mutated_line": "queue = [(0, 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(0, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [(1, 0)]",
      "mutated_line": "queue = [(-1, 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(-1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [(1, 0)]",
      "mutated_line": "queue = [(1, 1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 1)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [(1, 0)]",
      "mutated_line": "queue = [(1, -1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, -1)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "queue = [(1, 0)]",
      "mutated_line": "queue = [(1, 1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 1)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if u != parent:",
      "mutated_line": "if u == parent:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u == parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 1\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return -1\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 1\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return x.midlength + gcp(x.right, y.right)",
      "mutated_line": "return x.midlength - gcp(x.right, y.right)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength - gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return x.midlength + gcp(x.right, y.right)",
      "mutated_line": "return x.midlength * gcp(x.right, y.right)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength * gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length - py.length - 2 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length - py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length * py.length - 2 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length * py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - 2 / gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 / gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - (2 + gcp(px, py))",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - (2 + gcp(px, py))\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - 2 ** gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 ** gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 - dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 - dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), (dist(a, x) + 1) * dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), (dist(a, x) + 1) * dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 - dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 - dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), (dist(a, y) + 1) * dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), (dist(a, y) + 1) * dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d or (k - d) % 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d or (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n - 1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n - 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n * 1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n * 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "paths = [None for _ in range(n + 1)]",
      "mutated_line": "paths = [None for _ in range(n - 1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n - 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "paths = [None for _ in range(n + 1)]",
      "mutated_line": "paths = [None for _ in range(n * 1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n * 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(2, 1, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(2, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(0, 1, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(0, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(0, 1, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(0, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(-1, 1, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(-1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(1, 2, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 2, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(1, 0, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 0, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(1, 0, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 0, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return Path(1, 1, x, None, None)",
      "mutated_line": "return Path(1, -1, x, None, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, -1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= 3 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 3 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= 1 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 1 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= 0 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 0 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= 1 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 1 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l >= 2 * path.midlength:",
      "mutated_line": "if l >= -2 * path.midlength:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= -2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength / 2, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength / 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength + 2, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength + 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength ** 2, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength ** 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - 3 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 3 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - 1 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 1 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - 0 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 0 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - 1 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 1 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return px.length + py.length - 2 * gcp(px, py)",
      "mutated_line": "return px.length + py.length - -2 * gcp(px, py)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - -2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) - 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) - 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) * 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) * 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) - 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) - 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) * 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) * 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k > d and (k - d) % 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k > d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k < d and (k - d) % 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k < d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k == d and (k - d) % 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k == d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 2 != 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 != 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "results.append(\"NO\")",
      "mutated_line": "results.append('')",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 2)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 2)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 0)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 0)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + -1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + -1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "paths = [None for _ in range(n + 1)]",
      "mutated_line": "paths = [None for _ in range(n + 2)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 2)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "paths = [None for _ in range(n + 1)]",
      "mutated_line": "paths = [None for _ in range(n + 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "paths = [None for _ in range(n + 1)]",
      "mutated_line": "paths = [None for _ in range(n + 0)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "paths = [None for _ in range(n + 1)]",
      "mutated_line": "paths = [None for _ in range(n + -1)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + -1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength * 3, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 3, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength * 1, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 1, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength * 0, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 0, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength * 1, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 1, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return Path(l, path.midlength * 2, x, path, None)",
      "mutated_line": "return Path(l, path.midlength * -2, x, path, None)",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * -2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 2 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 2 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 0 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 0 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 0 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 0 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + -1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + -1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 2 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 2 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 0 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 0 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 0 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 0 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]",
      "mutated_line": "ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + -1 + dist(x, b)]",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + -1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) * 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) * 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and k - d + 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and k - d + 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 2 == 1:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 1:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 2 == -1:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == -1:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 2 == 1:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 1:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "results.append(\"YES\")",
      "mutated_line": "results.append('')",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 2 == 0:\n                results.append('')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k + d) % 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k + d) % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and k * d % 2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and k * d % 2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 3 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 3 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 1 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 1 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 0 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 0 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % 1 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % 1 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if k >= d and (k - d) % 2 == 0:",
      "mutated_line": "if k >= d and (k - d) % -2 == 0:",
      "code": "from collections import namedtuple\nfrom sys import stdin, stderr\nPath = namedtuple('Path', 'length midlength middle left right')\n\ndef can_reach_in_k_steps(n, edges, queries):\n    adj = [[] for _ in range(n + 1)]\n    paths = [None for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def append(path, x):\n        if not path:\n            return Path(1, 1, x, None, None)\n        l = path.length + 1\n        if l >= 2 * path.midlength:\n            return Path(l, path.midlength * 2, x, path, None)\n        else:\n            return Path(l, path.midlength, path.middle, path.left, append(path.right, x))\n    queue = [(1, 0)]\n    for i in range(n):\n        (v, parent) = queue[i]\n        paths[v] = append(paths[parent], v)\n        for u in adj[v]:\n            if u != parent:\n                queue.append((u, v))\n\n    def gcp(x, y):\n        if not x or not y:\n            return 0\n        while x.midlength > y.midlength:\n            x = x.left\n        while y.midlength > x.midlength:\n            y = y.left\n        if x.middle == y.middle:\n            return x.midlength + gcp(x.right, y.right)\n        else:\n            return gcp(x.left, y.left)\n\n    def dist(x, y):\n        px = paths[x]\n        py = paths[y]\n        return px.length + py.length - 2 * gcp(px, py)\n    results = []\n    for (x, y, a, b, k) in queries:\n        ds = [dist(a, b), dist(a, x) + 1 + dist(y, b), dist(a, y) + 1 + dist(x, b)]\n        for d in ds:\n            if k >= d and (k - d) % -2 == 0:\n                results.append('YES')\n                break\n        else:\n            results.append('NO')\n    return results"
    }
  ]
}