{
  "task_id": "taco_5355",
  "entry_point": "minimize_heap_sum",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "initial_root = 0",
      "mutated_line": "initial_root = 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 1\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "initial_root = 0",
      "mutated_line": "initial_root = -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = -1\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "initial_root = 0",
      "mutated_line": "initial_root = 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 1\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(2, g) + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) + 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(2, g) * 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) * 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(2, h) + pow(2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) + pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(2, h) * pow(2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) * pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while len(ans) < expected_ans_size:",
      "mutated_line": "while len(ans) <= expected_ans_size:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) <= expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while len(ans) < expected_ans_size:",
      "mutated_line": "while len(ans) >= expected_ans_size:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) >= expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while len(ans) < expected_ans_size:",
      "mutated_line": "while len(ans) != expected_ans_size:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) != expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(2, g) - 2",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 2\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(2, g) - 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 0\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(2, g) - 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 0\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(2, g) - -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - -1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ok = False",
      "mutated_line": "ok = True",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = True\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while False:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "initial_root += 1",
      "mutated_line": "initial_root -= 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root -= 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(3, g) - 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(3, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(1, g) - 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(1, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(0, g) - 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(0, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(1, g) - 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(1, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "items_to_leave = pow(2, g) - 1",
      "mutated_line": "items_to_leave = pow(-2, g) - 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(-2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(3, h) - pow(2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(3, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(1, h) - pow(2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(1, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(0, h) - pow(2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(0, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(1, h) - pow(2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(1, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(-2, h) - pow(2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(-2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(2, h) - pow(3, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(3, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(2, h) - pow(1, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(1, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(2, h) - pow(0, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(0, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(2, h) - pow(1, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(1, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "expected_ans_size = pow(2, h) - pow(2, g)",
      "mutated_line": "expected_ans_size = pow(2, h) - pow(-2, g)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(-2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 2 - 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 - 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 2 * 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 * 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rchi = lchi + 1",
      "mutated_line": "rchi = lchi - 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi - 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rchi = lchi + 1",
      "mutated_line": "rchi = lchi * 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi * 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == 0 or rchv == 0:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 or rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if lchv > rchv:",
      "mutated_line": "if lchv >= rchv:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv >= rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if lchv > rchv:",
      "mutated_line": "if lchv <= rchv:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv <= rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if lchv > rchv:",
      "mutated_line": "if lchv != rchv:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv != rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "initial_root += 1",
      "mutated_line": "initial_root += 2",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 2\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "initial_root += 1",
      "mutated_line": "initial_root += 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 0\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "initial_root += 1",
      "mutated_line": "initial_root += 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 0\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "initial_root += 1",
      "mutated_line": "initial_root += -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += -1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root / 2 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root / 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root + 2 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root + 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root ** 2 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root ** 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 2 + 2",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 2\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 2 + 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 0\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 2 + 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 0\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 2 + -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + -1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rchi = lchi + 1",
      "mutated_line": "rchi = lchi + 2",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 2\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rchi = lchi + 1",
      "mutated_line": "rchi = lchi + 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 0\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rchi = lchi + 1",
      "mutated_line": "rchi = lchi + 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 0\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rchi = lchi + 1",
      "mutated_line": "rchi = lchi + -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + -1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "lchv = A[lchi] if lchi < N else 0",
      "mutated_line": "lchv = A[lchi] if lchi <= N else 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi <= N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "lchv = A[lchi] if lchi < N else 0",
      "mutated_line": "lchv = A[lchi] if lchi >= N else 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi >= N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "lchv = A[lchi] if lchi < N else 0",
      "mutated_line": "lchv = A[lchi] if lchi != N else 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi != N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lchv = A[lchi] if lchi < N else 0",
      "mutated_line": "lchv = A[lchi] if lchi < N else 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 1\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lchv = A[lchi] if lchi < N else 0",
      "mutated_line": "lchv = A[lchi] if lchi < N else -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else -1\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lchv = A[lchi] if lchi < N else 0",
      "mutated_line": "lchv = A[lchi] if lchi < N else 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 1\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "rchv = A[rchi] if rchi < N else 0",
      "mutated_line": "rchv = A[rchi] if rchi <= N else 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi <= N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "rchv = A[rchi] if rchi < N else 0",
      "mutated_line": "rchv = A[rchi] if rchi >= N else 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi >= N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "rchv = A[rchi] if rchi < N else 0",
      "mutated_line": "rchv = A[rchi] if rchi != N else 0",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi != N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "rchv = A[rchi] if rchi < N else 0",
      "mutated_line": "rchv = A[rchi] if rchi < N else 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 1\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "rchv = A[rchi] if rchi < N else 0",
      "mutated_line": "rchv = A[rchi] if rchi < N else -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else -1\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "rchv = A[rchi] if rchi < N else 0",
      "mutated_line": "rchv = A[rchi] if rchi < N else 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 1\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv != 0 and rchv == 0:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv != 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == 0 and rchv != 0:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv != 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if root >= items_to_leave:",
      "mutated_line": "if root > items_to_leave:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root > items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if root >= items_to_leave:",
      "mutated_line": "if root < items_to_leave:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root < items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if root >= items_to_leave:",
      "mutated_line": "if root == items_to_leave:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root == items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans.append(initial_root + 1)",
      "mutated_line": "ans.append(initial_root - 1)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root - 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans.append(initial_root + 1)",
      "mutated_line": "ans.append(initial_root * 1)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root * 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 3 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 3 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 1 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 1 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 0 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 0 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * 1 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 1 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "lchi = root * 2 + 1",
      "mutated_line": "lchi = root * -2 + 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * -2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == 1 and rchv == 0:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 1 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == -1 and rchv == 0:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == -1 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == 1 and rchv == 0:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 1 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == 0 and rchv == 1:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 1:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == 0 and rchv == -1:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == -1:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if lchv == 0 and rchv == 0:",
      "mutated_line": "if lchv == 0 and rchv == 1:",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 1:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ok = True",
      "mutated_line": "ok = False",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = False\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A[root] = 0",
      "mutated_line": "A[root] = 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 1\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A[root] = 0",
      "mutated_line": "A[root] = -1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = -1\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A[root] = 0",
      "mutated_line": "A[root] = 1",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 1\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans.append(initial_root + 1)",
      "mutated_line": "ans.append(initial_root + 2)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 2)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans.append(initial_root + 1)",
      "mutated_line": "ans.append(initial_root + 0)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 0)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans.append(initial_root + 1)",
      "mutated_line": "ans.append(initial_root + 0)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + 0)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans.append(initial_root + 1)",
      "mutated_line": "ans.append(initial_root + -1)",
      "code": "def minimize_heap_sum(A, h, g):\n    N = len(A)\n    ans = []\n    initial_root = 0\n    items_to_leave = pow(2, g) - 1\n    expected_ans_size = pow(2, h) - pow(2, g)\n    while len(ans) < expected_ans_size:\n        root = initial_root\n        operations = []\n        ok = False\n        while True:\n            lchi = root * 2 + 1\n            rchi = lchi + 1\n            lchv = A[lchi] if lchi < N else 0\n            rchv = A[rchi] if rchi < N else 0\n            if lchv == 0 and rchv == 0:\n                if root >= items_to_leave:\n                    ok = True\n                    A[root] = 0\n                break\n            if lchv > rchv:\n                operations.append((root, lchv))\n                root = lchi\n            else:\n                operations.append((root, rchv))\n                root = rchi\n        if ok:\n            for (index, value) in operations:\n                A[index] = value\n            ans.append(initial_root + -1)\n        else:\n            initial_root += 1\n    min_sum = sum(A[:items_to_leave])\n    return (min_sum, ans)"
    }
  ]
}