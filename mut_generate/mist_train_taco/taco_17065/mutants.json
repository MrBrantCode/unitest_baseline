{
  "task_id": "taco_17065",
  "entry_point": "find_closest_circle_pair_distance",
  "mutant_count": 181,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] + c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] + c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return (((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0]) * c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return (((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0]) * c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def closest_pair_distance(circles, axis=1):",
      "mutated_line": "def closest_pair_distance(circles, axis=2):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=2):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def closest_pair_distance(circles, axis=1):",
      "mutated_line": "def closest_pair_distance(circles, axis=0):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=0):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def closest_pair_distance(circles, axis=1):",
      "mutated_line": "def closest_pair_distance(circles, axis=0):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=0):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "def closest_pair_distance(circles, axis=1):",
      "mutated_line": "def closest_pair_distance(circles, axis=-1):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=-1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n < 3:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n < 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n > 3:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n > 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n == 3:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n == 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 + c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 + c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 * c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 * c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "min_d = float('inf')",
      "mutated_line": "min_d = float('')",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (c1, c2) in combinations(circles, 2):",
      "mutated_line": "for (c1, c2) in combinations(circles, 3):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 3):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (c1, c2) in combinations(circles, 2):",
      "mutated_line": "for (c1, c2) in combinations(circles, 1):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 1):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (c1, c2) in combinations(circles, 2):",
      "mutated_line": "for (c1, c2) in combinations(circles, 0):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 0):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (c1, c2) in combinations(circles, 2):",
      "mutated_line": "for (c1, c2) in combinations(circles, 1):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 1):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (c1, c2) in combinations(circles, 2):",
      "mutated_line": "for (c1, c2) in combinations(circles, -2):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, -2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 4:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 4:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 2:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 2:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 0:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 0:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= 1:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 1:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n <= 3:",
      "mutated_line": "if n <= -3:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= -3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n / 2",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n / 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n * 2",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n * 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(set(x)) > len(set(y)):",
      "mutated_line": "if len(set(x)) >= len(set(y)):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) >= len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(set(x)) > len(set(y)):",
      "mutated_line": "if len(set(x)) <= len(set(y)):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) <= len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(set(x)) > len(set(y)):",
      "mutated_line": "if len(set(x)) != len(set(y)):",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) != len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] + B_circles[0][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] + B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] * B_circles[0][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] * B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) * 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) * 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return (c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2 + 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return (c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2 + 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[1]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[-1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[-1]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[1]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 3",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 3\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 1\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 0",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 0\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // 1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 1\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mid = n // 2",
      "mutated_line": "mid = n // -2",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // -2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if axis == 2:",
      "mutated_line": "if axis != 2:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis != 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "axis1 = 1",
      "mutated_line": "axis1 = 2",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 2\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "axis1 = 1",
      "mutated_line": "axis1 = 0",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 0\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "axis1 = 1",
      "mutated_line": "axis1 = 0",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 0\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "axis1 = 1",
      "mutated_line": "axis1 = -1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = -1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "axis2 = 2",
      "mutated_line": "axis2 = 3",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 3\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "axis2 = 2",
      "mutated_line": "axis2 = 1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 1\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "axis2 = 2",
      "mutated_line": "axis2 = 0",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 0\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "axis2 = 2",
      "mutated_line": "axis2 = 1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 1\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "axis2 = 2",
      "mutated_line": "axis2 = -2",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = -2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if axis == 1:",
      "mutated_line": "if axis != 1:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis != 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "axis1 = 2",
      "mutated_line": "axis1 = 3",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 3\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "axis1 = 2",
      "mutated_line": "axis1 = 1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 1\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "axis1 = 2",
      "mutated_line": "axis1 = 0",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 0\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "axis1 = 2",
      "mutated_line": "axis1 = 1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 1\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "axis1 = 2",
      "mutated_line": "axis1 = -2",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = -2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "axis2 = 1",
      "mutated_line": "axis2 = 2",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 2\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "axis2 = 1",
      "mutated_line": "axis2 = 0",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 0\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "axis2 = 1",
      "mutated_line": "axis2 = 0",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 0\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "axis2 = 1",
      "mutated_line": "axis2 = -1",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = -1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ac_edge = ac[axis1] + ac_r",
      "mutated_line": "ac_edge = ac[axis1] - ac_r",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] - ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ac_edge = ac[axis1] + ac_r",
      "mutated_line": "ac_edge = ac[axis1] * ac_r",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] * ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if B_edge - ac_edge >= dist:",
      "mutated_line": "if B_edge - ac_edge > dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge > dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if B_edge - ac_edge >= dist:",
      "mutated_line": "if B_edge - ac_edge < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge < dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if B_edge - ac_edge >= dist:",
      "mutated_line": "if B_edge - ac_edge == dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge == dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 - (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 - (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 * (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 * (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 1.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 1.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** -0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** -0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 1 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 1 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** -0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** -0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[1] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[1] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[-1] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[-1] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[1] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[1] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if axis == 2:",
      "mutated_line": "if axis == 3:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 3:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if axis == 2:",
      "mutated_line": "if axis == 1:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 1:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if axis == 2:",
      "mutated_line": "if axis == 0:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 0:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if axis == 2:",
      "mutated_line": "if axis == 1:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 1:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if axis == 2:",
      "mutated_line": "if axis == -2:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == -2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if axis == 1:",
      "mutated_line": "if axis == 2:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 2:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if axis == 1:",
      "mutated_line": "if axis == 0:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 0:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if axis == 1:",
      "mutated_line": "if axis == 0:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 0:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if axis == 1:",
      "mutated_line": "if axis == -1:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == -1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] - B_circles[0][1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][1]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] - B_circles[0][-1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][-1]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] - B_circles[0][1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][1]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for ac in A_circles[::-1]:",
      "mutated_line": "for ac in A_circles[::+1]:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::+1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ac_r = ac[0]",
      "mutated_line": "ac_r = ac[1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[1]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ac_r = ac[0]",
      "mutated_line": "ac_r = ac[-1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[-1]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ac_r = ac[0]",
      "mutated_line": "ac_r = ac[1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[1]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if B_edge - ac_edge >= dist:",
      "mutated_line": "if B_edge + ac_edge >= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge + ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if B_edge - ac_edge >= dist:",
      "mutated_line": "if B_edge * ac_edge >= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge * ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if bc[axis1] - bc_r - ac_edge >= dist:",
      "mutated_line": "if bc[axis1] - bc_r - ac_edge > dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge > dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if bc[axis1] - bc_r - ac_edge >= dist:",
      "mutated_line": "if bc[axis1] - bc_r - ac_edge < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge < dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if bc[axis1] - bc_r - ac_edge >= dist:",
      "mutated_line": "if bc[axis1] - bc_r - ac_edge == dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge == dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r <= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r <= dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r >= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r >= dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r != dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r != dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) * 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) * 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return (c1[1] - c2[1] + 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return (c1[1] - c2[1] + 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) * 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) * 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2] + 2)) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2] + 2)) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "A_circles.sort(key=lambda c: c[axis] + c[0])",
      "mutated_line": "A_circles.sort(key=lambda c: c[axis] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] - c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "A_circles.sort(key=lambda c: c[axis] + c[0])",
      "mutated_line": "A_circles.sort(key=lambda c: c[axis] * c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] * c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[1][axis1] - B_circles[0][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[1][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[-1][axis1] - B_circles[0][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[-1][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[1][axis1] - B_circles[0][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[1][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] - B_circles[1][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[1][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] - B_circles[-1][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[-1][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "B_edge = B_circles[0][axis1] - B_circles[0][0]",
      "mutated_line": "B_edge = B_circles[0][axis1] - B_circles[1][0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[1][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ac in A_circles[::-1]:",
      "mutated_line": "for ac in A_circles[::-2]:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-2]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ac in A_circles[::-1]:",
      "mutated_line": "for ac in A_circles[::-0]:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-0]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ac in A_circles[::-1]:",
      "mutated_line": "for ac in A_circles[::-0]:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-0]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ac in A_circles[::-1]:",
      "mutated_line": "for ac in A_circles[::--1]:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::--1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "bc_r = bc[0]",
      "mutated_line": "bc_r = bc[1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[1]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "bc_r = bc[0]",
      "mutated_line": "bc_r = bc[-1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[-1]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "bc_r = bc[0]",
      "mutated_line": "bc_r = bc[1]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[1]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if bc[axis1] - bc_r - ac_edge >= dist:",
      "mutated_line": "if bc[axis1] - bc_r + ac_edge >= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r + ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if bc[axis1] - bc_r - ac_edge >= dist:",
      "mutated_line": "if (bc[axis1] - bc_r) * ac_edge >= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if (bc[axis1] - bc_r) * ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] - bc[axis2]) - ac_r + bc_r < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r + bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if (abs(ac[axis2] - bc[axis2]) - ac_r) * bc_r < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if (abs(ac[axis2] - bc[axis2]) - ac_r) * bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] + c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] + c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] * c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] * c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 3 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 3 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 1 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 1 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 0 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 0 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 1 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 1 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** -2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** -2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] + c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] + c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] * c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] * c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 3) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 3) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 1) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 1) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 0) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 0) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 1) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 1) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** -2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** -2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if bc[axis1] - bc_r - ac_edge >= dist:",
      "mutated_line": "if bc[axis1] + bc_r - ac_edge >= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] + bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if bc[axis1] - bc_r - ac_edge >= dist:",
      "mutated_line": "if bc[axis1] * bc_r - ac_edge >= dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] * bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] - bc[axis2]) + ac_r - bc_r < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) + ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] - bc[axis2]) * ac_r - bc_r < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) * ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[1] + c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] + c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[1] * c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] * c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[2] + c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] + c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[2] * c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] * c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "A_circles.sort(key=lambda c: c[axis] + c[0])",
      "mutated_line": "A_circles.sort(key=lambda c: c[axis] + c[1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[1])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "A_circles.sort(key=lambda c: c[axis] + c[0])",
      "mutated_line": "A_circles.sort(key=lambda c: c[axis] + c[-1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[-1])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "A_circles.sort(key=lambda c: c[axis] + c[0])",
      "mutated_line": "A_circles.sort(key=lambda c: c[axis] + c[1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[1])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[2] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[2] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[0] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[0] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[0] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[0] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[-1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[-1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[2]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[2]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[0]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[0]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[0]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[0]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[-1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[-1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[3] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[3] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[1] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[1] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[0] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[0] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[1] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[1] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[-2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[-2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[3]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[3]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[1]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[1]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[0]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[0]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[1]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[1]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "mutated_line": "return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[-2]) ** 2) ** 0.5 - c1[0] - c2[0]",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[-2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] + bc[axis2]) - ac_r - bc_r < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] + bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:",
      "mutated_line": "if abs(ac[axis2] * bc[axis2]) - ac_r - bc_r < dist:",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] * bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[0] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[0] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[0] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[0] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[-1] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[-1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[1] - c[1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[1])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[1] - c[-1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[-1])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[1] - c[1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[1])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[3] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[3] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[0] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[0] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[1] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[-2] - c[0])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[-2] - c[0])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[2] - c[1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[1])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[2] - c[-1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[-1])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "circles.sort(key=lambda c: c[2] - c[0])",
      "mutated_line": "circles.sort(key=lambda c: c[2] - c[1])",
      "code": "def find_closest_circle_pair_distance(circles):\n\n    def _get_distance(c1, c2):\n        return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n    from itertools import combinations\n\n    def _get_min_distance(circles):\n        min_d = float('inf')\n        for (c1, c2) in combinations(circles, 2):\n            min_d = min(min_d, _get_distance(c1, c2))\n        return min_d\n\n    def closest_pair_distance(circles, axis=1):\n        n = len(circles)\n        if n <= 3:\n            return _get_min_distance(circles)\n        else:\n            mid = n // 2\n            (r, x, y) = zip(*circles)\n            if len(set(x)) > len(set(y)):\n                if axis == 2:\n                    circles.sort(key=lambda c: c[1] - c[0])\n                axis1 = 1\n                axis2 = 2\n            else:\n                if axis == 1:\n                    circles.sort(key=lambda c: c[2] - c[1])\n                axis1 = 2\n                axis2 = 1\n            A_circles = circles[:mid]\n            B_circles = circles[mid:]\n            d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n            d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n            dist = min(d_Amin, d_Bmin)\n            min_d = dist\n            A_circles.sort(key=lambda c: c[axis] + c[0])\n            B_edge = B_circles[0][axis1] - B_circles[0][0]\n            for ac in A_circles[::-1]:\n                ac_r = ac[0]\n                ac_edge = ac[axis1] + ac_r\n                if B_edge - ac_edge >= dist:\n                    break\n                for bc in B_circles:\n                    bc_r = bc[0]\n                    if bc[axis1] - bc_r - ac_edge >= dist:\n                        break\n                    if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                        min_d = min(min_d, _get_distance(ac, bc))\n            return min_d\n    return closest_pair_distance(circles)"
    }
  ]
}