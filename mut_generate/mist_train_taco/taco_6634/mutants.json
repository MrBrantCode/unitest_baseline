{
  "task_id": "taco_6634",
  "entry_point": "smallest_subset_size",
  "mutant_count": 42,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [0] / N",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] / N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [0] + N",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] + N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [0] ** N",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] ** N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 1\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = -1\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 1\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = 2",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 2\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 0\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 0\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = -1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = -1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "ans += len(G[v]) - 1",
      "mutated_line": "ans -= len(G[v]) - 1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans -= len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 1].append(t + 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t + 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 1].append(t * 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t * 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [1] * N",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [1] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [-1] * N",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [-1] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [1] * N",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [1] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans += len(G[v]) - 1",
      "mutated_line": "ans += len(G[v]) + 1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) + 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans += len(G[v]) - 1",
      "mutated_line": "ans += len(G[v]) * 1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) * 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 1].append(t - 2)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 2)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 1].append(t - 0)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 0)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 1].append(t - 0)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 0)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 1].append(t - -1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - -1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans += len(G[v]) - 1",
      "mutated_line": "ans += len(G[v]) - 2",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 2\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans += len(G[v]) - 1",
      "mutated_line": "ans += len(G[v]) - 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 0\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans += len(G[v]) - 1",
      "mutated_line": "ans += len(G[v]) - 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 0\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans += len(G[v]) - 1",
      "mutated_line": "ans += len(G[v]) - -1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - -1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = 2",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 2\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 0\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = 0",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 0\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = -1",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = -1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s + 1].append(t - 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s + 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s * 1].append(t - 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s * 1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 2].append(t - 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 2].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 0].append(t - 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 0].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - 0].append(t - 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - 0].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G[s - 1].append(t - 1)",
      "mutated_line": "G[s - -1].append(t - 1)",
      "code": "def smallest_subset_size(N, M, edges):\n    \"\"\"\n    Calculate the smallest possible size of the subset E' of edges in a directed graph \n    such that the values on the remaining edges can be recovered using the flow conservation law.\n\n    Parameters:\n    - N (int): The number of nodes in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge (s_i, t_i).\n\n    Returns:\n    - int: The smallest possible size of the subset E'.\n    \"\"\"\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for (s, t) in edges:\n        G[s - -1].append(t - 1)\n    used = [0] * N\n    ans = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        que = deque([i])\n        used[i] = 1\n        while que:\n            v = que.popleft()\n            ans += len(G[v]) - 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        ans += 1\n    return ans"
    }
  ]
}