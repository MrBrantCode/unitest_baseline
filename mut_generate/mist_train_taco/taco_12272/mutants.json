{
  "task_id": "taco_12272",
  "entry_point": "find_max_k",
  "mutant_count": 114,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x >= c:",
      "mutated_line": "return 'Infinity'",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x > c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x >= c:",
      "mutated_line": "return 'Infinity'",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x < c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x >= c:",
      "mutated_line": "return 'Infinity'",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x == c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ss = [0] * n",
      "mutated_line": "ss = [0] / n",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] / n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ss = [0] * n",
      "mutated_line": "ss = [0] + n",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] + n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ss = [0] * n",
      "mutated_line": "ss = [0] ** n",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] ** n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return \"Infinity\"",
      "mutated_line": "return ''",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return ''\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[0] * d <= c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d <= c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[0] * d >= c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d >= c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[0] * d != c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d != c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss[0] = a[0]",
      "mutated_line": "ss[1] = a[0]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[1] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss[0] = a[0]",
      "mutated_line": "ss[-1] = a[0]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[-1] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss[0] = a[0]",
      "mutated_line": "ss[1] = a[0]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[1] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss[0] = a[0]",
      "mutated_line": "ss[0] = a[1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[1]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss[0] = a[0]",
      "mutated_line": "ss[0] = a[-1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[-1]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss[0] = a[0]",
      "mutated_line": "ss[0] = a[1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[1]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(2, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(0, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(0, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(-1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i - 1] - a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] - a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i - 1] * a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] * a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 1) / 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) / 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 1) * 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) * 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if l == r:",
      "mutated_line": "if l != r:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l != r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d / (m + 1)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d / (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d * (m + 1)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d * (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n - 1, m)] / y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] / y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n - 1, m)] + y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] + y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n - 1, m)] ** y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] ** y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 1) * y <= d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y <= d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 1) * y >= d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y >= d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 1) * y != d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y != d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv -= ss[min(n, d - y * (m + 1)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv -= ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if otv >= c:",
      "mutated_line": "if otv > c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv > c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if otv >= c:",
      "mutated_line": "if otv < c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv < c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if otv >= c:",
      "mutated_line": "if otv == c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv == c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return bina(0, d, c, d, ss, n)",
      "mutated_line": "return bina(1, d, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(1, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return bina(0, d, c, d, ss, n)",
      "mutated_line": "return bina(-1, d, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(-1, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return bina(0, d, c, d, ss, n)",
      "mutated_line": "return bina(1, d, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(1, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a.sort(reverse=True)",
      "mutated_line": "a.sort(reverse=False)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=False)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[0] / d < c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] / d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[0] + d < c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] + d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[0] ** d < c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] ** d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return \"Impossible\"",
      "mutated_line": "return ''",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return ''\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ss = [0] * n",
      "mutated_line": "ss = [1] * n",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [1] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ss = [0] * n",
      "mutated_line": "ss = [-1] * n",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [-1] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ss = [0] * n",
      "mutated_line": "ss = [1] * n",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [1] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r - 1) // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r - 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r) * 1 // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r) * 1 // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 1) // 3",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 3\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 1) // 1",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 1\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 1) // 0",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 0\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 1) // 1",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 1\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 1) // -2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // -2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d // (m - 1)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m - 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d // (m * 1)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m * 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 1) / y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) / y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if m + 1 + y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if m + 1 + y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 1) ** y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) ** y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i + 1] + a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i + 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i * 1] + a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i * 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l - r + 1) // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l - r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l * r + 1) // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l * r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 2) // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 2) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 0) // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 0) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + 0) // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 0) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = (l + r + 1) // 2",
      "mutated_line": "m = (l + r + -1) // 2",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + -1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d // (m + 2)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 2)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d // (m + 0)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 0)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d // (m + 0)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 0)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = d // (m + 1)",
      "mutated_line": "y = d // (m + -1)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + -1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m - 1) * y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m - 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if m * 1 * y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if m * 1 * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 1)) + 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) + 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 1)) * 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) * 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return bina(l, m - 1, c, d, ss, n)",
      "mutated_line": "return bina(l, m + 1, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m + 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return bina(l, m - 1, c, d, ss, n)",
      "mutated_line": "return bina(l, m * 1, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m * 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[1] * d < c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[1] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[-1] * d < c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[-1] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif a[0] * d < c:",
      "mutated_line": "elif a[1] * d < c:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[1] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i - 2] + a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 2] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i - 0] + a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 0] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i - 0] + a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 0] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ss[i] = ss[i - 1] + a[i]",
      "mutated_line": "ss[i] = ss[i - -1] + a[i]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - -1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n + 1, m)] * y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n + 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n * 1, m)] * y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n * 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 2) * y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 2) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 0) * y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 0) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + 0) * y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 0) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (m + 1) * y < d:",
      "mutated_line": "if (m + -1) * y < d:",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + -1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 1)) - 2]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 2]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 1)) - 0]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 0]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 1)) - 0]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 0]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 1)) - -1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - -1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return bina(l, m - 1, c, d, ss, n)",
      "mutated_line": "return bina(l, m - 2, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 2, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return bina(l, m - 1, c, d, ss, n)",
      "mutated_line": "return bina(l, m - 0, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 0, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return bina(l, m - 1, c, d, ss, n)",
      "mutated_line": "return bina(l, m - 0, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 0, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return bina(l, m - 1, c, d, ss, n)",
      "mutated_line": "return bina(l, m - -1, c, d, ss, n)",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - -1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n - 2, m)] * y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 2, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n - 0, m)] * y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 0, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n - 0, m)] * y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 0, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "otv = ss[min(n - 1, m)] * y",
      "mutated_line": "otv = ss[min(n - -1, m)] * y",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - -1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d + y * (m + 1)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d + y * (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d * (y * (m + 1))) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d * (y * (m + 1))) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y / (m + 1)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y / (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - (y + (m + 1))) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - (y + (m + 1))) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y ** (m + 1)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y ** (m + 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m - 1)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m - 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m * 1)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m * 1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 2)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 2)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 0)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 0)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + 0)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + 0)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "otv += ss[min(n, d - y * (m + 1)) - 1]",
      "mutated_line": "otv += ss[min(n, d - y * (m + -1)) - 1]",
      "code": "def find_max_k(n, c, d, a):\n    a.sort(reverse=True)\n    x = sum(a[:min(n, d)])\n    if x >= c:\n        return 'Infinity'\n    elif a[0] * d < c:\n        return 'Impossible'\n    ss = [0] * n\n    ss[0] = a[0]\n    for i in range(1, n):\n        ss[i] = ss[i - 1] + a[i]\n\n    def bina(l, r, c, d, ss, n):\n        m = (l + r + 1) // 2\n        if l == r:\n            return l\n        y = d // (m + 1)\n        otv = ss[min(n - 1, m)] * y\n        if (m + 1) * y < d:\n            otv += ss[min(n, d - y * (m + -1)) - 1]\n        if otv >= c:\n            return bina(m, r, c, d, ss, n)\n        else:\n            return bina(l, m - 1, c, d, ss, n)\n    return bina(0, d, c, d, ss, n)"
    }
  ]
}