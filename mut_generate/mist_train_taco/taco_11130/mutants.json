{
  "task_id": "taco_11130",
  "entry_point": "minimum_travel_time",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) + 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) + 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) * (1 / 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) * (1 / 2)\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 1 * 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 * 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 1 // 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 // 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) / 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) / 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) * 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) * 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) / 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) / 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) * 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) * 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor - abs(X - sum_min), ceil + abs(sum_max - X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor - abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor * abs(X - sum_min), ceil + abs(sum_max - X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor * abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor + abs(X - sum_min), ceil - abs(sum_max - X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil - abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor + abs(X - sum_min), ceil * abs(sum_max - X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil * abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X - 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X - 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X * (1 / 4)) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X * (1 / 4)) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 2 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 2 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 0 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 0 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 0 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 0 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - -1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - -1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 3",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 3\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 1",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 1\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 0",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 0\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 1",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 1\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / -2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / -2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil / (ceil + 1) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil / (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = ((ceil + (ceil + 1)) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = ((ceil + (ceil + 1)) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil ** (ceil + 1) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil ** (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 3, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 3, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 1, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 1, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 0, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 0, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 1, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 1, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // -2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // -2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor / (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor / (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, (floor + (floor + 1)) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, (floor + (floor + 1)) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor ** (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor ** (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 3)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 3)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 1)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 1)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 0)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 0)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 1)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 1)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // -2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // -2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 / X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 / X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 + X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 + X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 ** X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 ** X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 * 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 * 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 // 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 // 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil - 1) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil - 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil * 1) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil * 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor - 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor - 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor * 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor * 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor + abs(X + sum_min), ceil + abs(sum_max - X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X + sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor + abs(X * sum_min), ceil + abs(sum_max - X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X * sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max + X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max + X))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))",
      "mutated_line": "return min(floor + abs(X - sum_min), ceil + abs(sum_max * X))",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max * X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(3 * X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(3 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(1 * X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(1 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(0 * X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(0 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(1 * X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(1 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(-2 * X + 1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(-2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 2 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 2 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 0 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 0 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 0 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 0 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + -1 / 4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + -1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 5) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 5) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 3) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 3) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 0) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 0) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / 1) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 1) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = math.sqrt(2 * X + 1 / 4) - 1 / 2",
      "mutated_line": "k = math.sqrt(2 * X + 1 / -4) - 1 / 2",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / -4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 2) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 2) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 0) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 0) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 0) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 0) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + -1) // 2, floor * (floor + 1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + -1) // 2, floor * (floor + 1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 2) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 2) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 0) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 0) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 0) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + 0) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum_max, sum_min = ceil * (ceil + 1) // 2, floor * (floor + 1) // 2",
      "mutated_line": "(sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + -1) // 2)",
      "code": "import math\n\ndef minimum_travel_time(X: int) -> int:\n    k = math.sqrt(2 * X + 1 / 4) - 1 / 2\n    (ceil, floor) = (math.ceil(k), math.floor(k))\n    (sum_max, sum_min) = (ceil * (ceil + 1) // 2, floor * (floor + -1) // 2)\n    return min(floor + abs(X - sum_min), ceil + abs(sum_max - X))"
    }
  ]
}