{
  "task_id": "taco_6515",
  "entry_point": "count_ways_to_form_integer",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 - 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 * 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "arr_0 = [0] * x",
      "mutated_line": "arr_0 = [0] / x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] / x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "arr_0 = [0] * x",
      "mutated_line": "arr_0 = [0] + x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] + x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "arr_0 = [0] * x",
      "mutated_line": "arr_0 = [0] ** x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] ** x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "arr_0[digit % x] += 1",
      "mutated_line": "arr_0[digit % x] -= 1",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] -= 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 * 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 + 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 8\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 6\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 0\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 1\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + -7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "arr_0[digit % x] += 1",
      "mutated_line": "arr_0[digit % x] += 2",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 2\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "arr_0[digit % x] += 1",
      "mutated_line": "arr_0[digit % x] += 0",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 0\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "arr_0[digit % x] += 1",
      "mutated_line": "arr_0[digit % x] += 0",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 0\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "arr_0[digit % x] += 1",
      "mutated_line": "arr_0[digit % x] += -1",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += -1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "arr = [0] * len(arr1)",
      "mutated_line": "arr = [0] / len(arr1)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] / len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "arr = [0] * len(arr1)",
      "mutated_line": "arr = [0] + len(arr1)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] + len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "arr = [0] * len(arr1)",
      "mutated_line": "arr = [0] ** len(arr1)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] ** len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res = [0] * x",
      "mutated_line": "res = [0] / x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] / x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res = [0] * x",
      "mutated_line": "res = [0] + x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] + x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res = [0] * x",
      "mutated_line": "res = [0] ** x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] ** x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "res[i * m % x] += arr[i]",
      "mutated_line": "res[i * m % x] -= arr[i]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] -= arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if b == 1:",
      "mutated_line": "if b != 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b != 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 != 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 != 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 11 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 9 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 0 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 1 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = -10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 10 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 8 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 0 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 1 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** -9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "arr_0 = [0] * x",
      "mutated_line": "arr_0 = [1] * x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [1] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "arr_0 = [0] * x",
      "mutated_line": "arr_0 = [-1] * x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [-1] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "arr_0 = [0] * x",
      "mutated_line": "arr_0 = [1] * x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [1] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "arr_0[digit % x] += 1",
      "mutated_line": "arr_0[digit * x] += 1",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit * x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "arr_0[digit % x] += 1",
      "mutated_line": "arr_0[digit + x] += 1",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit + x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[(i + j) % x] -= arr1[i] * arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] -= arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = pow(10, s, x)",
      "mutated_line": "m = pow(11, s, x)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(11, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = pow(10, s, x)",
      "mutated_line": "m = pow(9, s, x)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(9, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = pow(10, s, x)",
      "mutated_line": "m = pow(0, s, x)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(0, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = pow(10, s, x)",
      "mutated_line": "m = pow(1, s, x)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(1, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = pow(10, s, x)",
      "mutated_line": "m = pow(-10, s, x)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(-10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 2:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 2:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 0:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 0:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if b == 1:",
      "mutated_line": "if b == -1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == -1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b * 2 == 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b * 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b + 2 == 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b + 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 2:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 2:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 0:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 0:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 0:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 0:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == -1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == -1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "arr = [0] * len(arr1)",
      "mutated_line": "arr = [1] * len(arr1)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [1] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "arr = [0] * len(arr1)",
      "mutated_line": "arr = [-1] * len(arr1)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [-1] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "arr = [0] * len(arr1)",
      "mutated_line": "arr = [1] * len(arr1)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [1] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[(i + j) % x] += arr1[i] / arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] / arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[(i + j) % x] += arr1[i] + arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] + arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[(i + j) % x] += arr1[i] ** arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] ** arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = [0] * x",
      "mutated_line": "res = [1] * x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [1] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = [0] * x",
      "mutated_line": "res = [-1] * x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [-1] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = [0] * x",
      "mutated_line": "res = [1] * x",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [1] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i * m % x] += arr[i]",
      "mutated_line": "res[i * m * x] += arr[i]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m * x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i * m % x] += arr[i]",
      "mutated_line": "res[i * m + x] += arr[i]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m + x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 3 == 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 3 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 1 == 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 1 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 0 == 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 0 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 1 == 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 1 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % -2 == 1:",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % -2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "sol = solve(b - 1, x, arr_0, mod)",
      "mutated_line": "sol = solve(b + 1, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b + 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "sol = solve(b - 1, x, arr_0, mod)",
      "mutated_line": "sol = solve(b * 1, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b * 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sol = solve(b // 2, x, arr_0, mod)",
      "mutated_line": "sol = solve(b / 2, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b / 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sol = solve(b // 2, x, arr_0, mod)",
      "mutated_line": "sol = solve(b * 2, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b * 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[(i + j) * x] += arr1[i] * arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) * x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[i + j + x] += arr1[i] * arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[i + j + x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i * m % x] += arr[i]",
      "mutated_line": "res[i / m % x] += arr[i]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i / m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i * m % x] += arr[i]",
      "mutated_line": "res[(i + m) % x] += arr[i]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[(i + m) % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i * m % x] += arr[i]",
      "mutated_line": "res[i ** m % x] += arr[i]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i ** m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sol = solve(b - 1, x, arr_0, mod)",
      "mutated_line": "sol = solve(b - 2, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 2, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sol = solve(b - 1, x, arr_0, mod)",
      "mutated_line": "sol = solve(b - 0, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 0, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sol = solve(b - 1, x, arr_0, mod)",
      "mutated_line": "sol = solve(b - 0, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 0, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sol = solve(b - 1, x, arr_0, mod)",
      "mutated_line": "sol = solve(b - -1, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - -1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return cross(move(sol, 1, x), arr_0, x, mod)",
      "mutated_line": "return cross(move(sol, 2, x), arr_0, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 2, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return cross(move(sol, 1, x), arr_0, x, mod)",
      "mutated_line": "return cross(move(sol, 0, x), arr_0, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 0, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return cross(move(sol, 1, x), arr_0, x, mod)",
      "mutated_line": "return cross(move(sol, 0, x), arr_0, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 0, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return cross(move(sol, 1, x), arr_0, x, mod)",
      "mutated_line": "return cross(move(sol, -1, x), arr_0, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, -1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sol = solve(b // 2, x, arr_0, mod)",
      "mutated_line": "sol = solve(b // 3, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 3, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sol = solve(b // 2, x, arr_0, mod)",
      "mutated_line": "sol = solve(b // 1, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 1, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sol = solve(b // 2, x, arr_0, mod)",
      "mutated_line": "sol = solve(b // 0, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 0, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sol = solve(b // 2, x, arr_0, mod)",
      "mutated_line": "sol = solve(b // 1, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 1, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sol = solve(b // 2, x, arr_0, mod)",
      "mutated_line": "sol = solve(b // -2, x, arr_0, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // -2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return cross(move(sol, b // 2, x), sol, x, mod)",
      "mutated_line": "return cross(move(sol, b / 2, x), sol, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b / 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return cross(move(sol, b // 2, x), sol, x, mod)",
      "mutated_line": "return cross(move(sol, b * 2, x), sol, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b * 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[(i - j) % x] += arr1[i] * arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i - j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "arr[(i + j) % x] += arr1[i] * arr2[j]",
      "mutated_line": "arr[i * j % x] += arr1[i] * arr2[j]",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[i * j % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return cross(move(sol, b // 2, x), sol, x, mod)",
      "mutated_line": "return cross(move(sol, b // 3, x), sol, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 3, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return cross(move(sol, b // 2, x), sol, x, mod)",
      "mutated_line": "return cross(move(sol, b // 1, x), sol, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 1, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return cross(move(sol, b // 2, x), sol, x, mod)",
      "mutated_line": "return cross(move(sol, b // 0, x), sol, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 0, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return cross(move(sol, b // 2, x), sol, x, mod)",
      "mutated_line": "return cross(move(sol, b // 1, x), sol, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // 1, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return cross(move(sol, b // 2, x), sol, x, mod)",
      "mutated_line": "return cross(move(sol, b // -2, x), sol, x, mod)",
      "code": "def count_ways_to_form_integer(n, b, k, x, digits):\n    mod = 10 ** 9 + 7\n    arr_0 = [0] * x\n    for digit in digits:\n        arr_0[digit % x] += 1\n\n    def cross(arr1, arr2, x, mod):\n        arr = [0] * len(arr1)\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                arr[(i + j) % x] += arr1[i] * arr2[j]\n        for i in range(len(arr)):\n            arr[i] %= mod\n        return arr\n\n    def move(arr, s, x):\n        m = pow(10, s, x)\n        res = [0] * x\n        for i in range(x):\n            res[i * m % x] += arr[i]\n        return res\n\n    def solve(b, x, arr_0, mod):\n        if b == 1:\n            return arr_0\n        if b % 2 == 1:\n            sol = solve(b - 1, x, arr_0, mod)\n            return cross(move(sol, 1, x), arr_0, x, mod)\n        else:\n            sol = solve(b // 2, x, arr_0, mod)\n            return cross(move(sol, b // -2, x), sol, x, mod)\n    sol = solve(b, x, arr_0, mod)\n    return sol[k]"
    }
  ]
}