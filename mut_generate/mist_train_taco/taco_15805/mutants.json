{
  "task_id": "taco_15805",
  "entry_point": "min_time_to_cross_road",
  "mutant_count": 259,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) - [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) - [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = ([-10 ** 9] + sorted(safety_islands)) * [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = ([-10 ** 9] + sorted(safety_islands)) * [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 10 * 9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 * 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 10 + 9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 + 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[1][0] = 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 1\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[1][0] = -1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = -1\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[1][0] = 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 1\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] - sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] - sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] * sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] * sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 11 ** 9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 11 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 9 ** 9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 9 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 0 ** 9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 0 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 1 ** 9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 1 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = -10 ** 9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = -10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 10 ** 10",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 10\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 10 ** 8",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 8\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 10 ** 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 0\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 10 ** 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 1\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "inf = 10 ** 9",
      "mutated_line": "inf = 10 ** -9",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** -9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) / (g + 1) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) / (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) + (g + 1) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) + (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) ** (g + 1) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) ** (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[1][1] = 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][1] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[1][-1] = 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][-1] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[1][1] = 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][1] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] + safety_islands[v - 1]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] + safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] * safety_islands[v - 1]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] * safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v + 1] + safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] + safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v + 1] * safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] * safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if time == g:",
      "mutated_line": "if time != g:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time != g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans <= inf else -1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans <= inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans >= inf else -1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans >= inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans != inf else -1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans < inf else +1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else +1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 * 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 * 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 + 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 + 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g - 1) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g - 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g * 1) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g * 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[2][0] = 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[2][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[0][0] = 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[0][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[0][0] = 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[0][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[1][0] = 0",
      "mutated_line": "dp[-1][0] = 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[-1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g or dp[v - 1][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g or dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g or dp[v + 1][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g or dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g or dp[v - 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g or dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g or dp[v + 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g or dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) - i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) - i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) * i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) * i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans < inf else -2",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -2"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans < inf else -0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans < inf else -0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans if ans < inf else -1",
      "mutated_line": "return ans if ans < inf else --1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else --1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [+10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [+10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [11 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [11 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [9 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [9 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [0 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [0 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [1 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [1 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [-10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [-10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 10]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 10]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 8]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 8]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 0]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 0]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 1]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 1]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** -9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** -9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('', [inf]) * (g + 1) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 2) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 2) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 0) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 0) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 0) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 0) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + -1) for _ in range(m + 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + -1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m - 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m - 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m * 2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m * 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dq = deque([(1, 0)])",
      "mutated_line": "dq = deque([(2, 0)])",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(2, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dq = deque([(1, 0)])",
      "mutated_line": "dq = deque([(0, 0)])",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(0, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dq = deque([(1, 0)])",
      "mutated_line": "dq = deque([(0, 0)])",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(0, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dq = deque([(1, 0)])",
      "mutated_line": "dq = deque([(-1, 0)])",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(-1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dq = deque([(1, 0)])",
      "mutated_line": "dq = deque([(1, 1)])",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 1)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dq = deque([(1, 0)])",
      "mutated_line": "dq = deque([(1, -1)])",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, -1)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dq = deque([(1, 0)])",
      "mutated_line": "dq = deque([(1, 1)])",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 1)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] - safety_islands[v + 1]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v + 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] - safety_islands[v * 1]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v * 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v - 1] - safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v - 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v * 1] - safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v * 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist < g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist < g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist > g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist > g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist == g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist == g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] >= dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] >= dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] <= dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] <= dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] != dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] != dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 1][p_dist] = dp[v][time] - 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] - 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 1][p_dist] = dp[v][time] * 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] * 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist < g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist < g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist > g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist > g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist == g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist == g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] >= dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] >= dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] <= dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] <= dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] != dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] != dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 1][n_dist] = dp[v][time] - 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] - 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 1][n_dist] = dp[v][time] * 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] * 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist < g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist < g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist > g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist > g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist == g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist == g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] >= dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] >= dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] <= dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] <= dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] != dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] != dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist < g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist < g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist > g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist > g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist == g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist == g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] >= dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] >= dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] <= dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] <= dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] != dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] != dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] / (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] / (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] + (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] + (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] ** (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] ** (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-(10 * 9)] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-(10 * 9)] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-(10 + 9)] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-(10 + 9)] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 3)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 3)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 1)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 1)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 0)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 0)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 1)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 1)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]",
      "mutated_line": "dp = [array('i', [inf]) * (g + 1) for _ in range(m + -2)]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + -2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] - safety_islands[v - 2]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 2]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] - safety_islands[v - 0]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 0]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] - safety_islands[v - 0]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 0]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p_dist = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "p_dist = safety_islands[v] - safety_islands[v - -1]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - -1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v + 2] - safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 2] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v + 0] - safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 0] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v + 0] - safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 0] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n_dist = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "n_dist = safety_islands[v + -1] - safety_islands[v]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + -1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] - 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] - 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] * 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] * 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 1][p_dist] = dp[v][time] + 2",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 2\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 1][p_dist] = dp[v][time] + 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 0\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 1][p_dist] = dp[v][time] + 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 0\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 1][p_dist] = dp[v][time] + -1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + -1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] - 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] - 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] * 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] * 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 1][n_dist] = dp[v][time] + 2",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 2\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 1][n_dist] = dp[v][time] + 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 0\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 1][n_dist] = dp[v][time] + 0",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 0\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 1][n_dist] = dp[v][time] + -1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + -1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time - p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time - p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time * p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time * p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v - 1][time - p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time - p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v - 1][time * p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time * p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time - n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time - n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time * n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time * n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v + 1][time - n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time - n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v + 1][time * n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time * n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g - r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g - r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g * r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g * r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g - 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g - 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g * 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g * 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-11 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-11 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-9 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-9 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-0 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-0 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-1 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-1 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [--10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [--10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 10] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 10] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 8] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 8] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 0] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 0] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** 1] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 1] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]",
      "mutated_line": "safety_islands = [-10 ** -9] + sorted(safety_islands) + [10 ** 9]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** -9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 2:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 2:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 0:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 0:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 0:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 0:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + -1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + -1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 1][p_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v + 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v * 1][p_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v * 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dq.append((v - 1, p_dist))",
      "mutated_line": "dq.append((v + 1, p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v + 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dq.append((v - 1, p_dist))",
      "mutated_line": "dq.append((v * 1, p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v * 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 2:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 2:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 0:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 0:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 0:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 0:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + -1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + -1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 1][n_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v - 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v * 1][n_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v * 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dq.append((v + 1, n_dist))",
      "mutated_line": "dq.append((v - 1, n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v - 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dq.append((v + 1, n_dist))",
      "mutated_line": "dq.append((v * 1, n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v * 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 1][time - p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time - p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 1][time * p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time * p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v + 1][time + p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v + 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v * 1][time + p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v * 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v + 1, time + p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v * 1, time + p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v * 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v - 1, time - p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time - p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v - 1, time * p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time * p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 1][time - n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time - n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 1][time * n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time * n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v - 1][time + n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v - 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v * 1][time + n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v * 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v - 1, time + n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v * 1, time + n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v * 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v + 1, time - n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time - n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v + 1, time * n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time * n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 2)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 2)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 0)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 0)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 0)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 0)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + -1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + -1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v + 1][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v + 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v * 1][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v * 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 2][p_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 2][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 0][p_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 0][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - 0][p_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 0][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[v - 1][p_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v - -1][p_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - -1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dq.append((v - 1, p_dist))",
      "mutated_line": "dq.append((v - 2, p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 2, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dq.append((v - 1, p_dist))",
      "mutated_line": "dq.append((v - 0, p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 0, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dq.append((v - 1, p_dist))",
      "mutated_line": "dq.append((v - 0, p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 0, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dq.append((v - 1, p_dist))",
      "mutated_line": "dq.append((v - -1, p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - -1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v - 1][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v - 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v * 1][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v * 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 2][n_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 2][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 0][n_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 0][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + 0][n_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 0][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[v + 1][n_dist] = dp[v][time] + 1",
      "mutated_line": "dp[v + -1][n_dist] = dp[v][time] + 1",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + -1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dq.append((v + 1, n_dist))",
      "mutated_line": "dq.append((v + 2, n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 2, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dq.append((v + 1, n_dist))",
      "mutated_line": "dq.append((v + 0, n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 0, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dq.append((v + 1, n_dist))",
      "mutated_line": "dq.append((v + 0, n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 0, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dq.append((v + 1, n_dist))",
      "mutated_line": "dq.append((v + -1, n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + -1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v + 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v + 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v * 1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v * 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v - 2][time + p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 2][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v - 0][time + p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 0][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v - 0][time + p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 0][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[v - 1][time + p_dist] = dp[v][time]",
      "mutated_line": "dp[v - -1][time + p_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - -1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v - 2, time + p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 2, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v - 0, time + p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 0, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v - 0, time + p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 0, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dq.appendleft((v - 1, time + p_dist))",
      "mutated_line": "dq.appendleft((v - -1, time + p_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - -1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v - 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v - 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v * 1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v * 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v + 2][time + n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 2][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v + 0][time + n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 0][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v + 0][time + n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 0][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v + 1][time + n_dist] = dp[v][time]",
      "mutated_line": "dp[v + -1][time + n_dist] = dp[v][time]",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + -1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v + 2, time + n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 2, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v + 0, time + n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 0, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v + 0, time + n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 0, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dq.appendleft((v + 1, time + n_dist))",
      "mutated_line": "dq.appendleft((v + -1, time + n_dist))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + -1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[+2][i] * (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[+2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 2][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 2][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 0][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 0][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - 0][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 0][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:",
      "mutated_line": "if p_dist <= g and dp[v - -1][p_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - -1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 2][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 2][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 0][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 0][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + 0][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 0][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:",
      "mutated_line": "if n_dist <= g and dp[v + -1][n_dist] > dp[v][time] + 1:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + -1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 2][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 2][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 0][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 0][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - 0][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 0][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:",
      "mutated_line": "if time + p_dist <= g and dp[v - -1][time + p_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - -1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 2][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 2][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 0][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 0][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + 0][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 0][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:",
      "mutated_line": "if time + n_dist <= g and dp[v + -1][time + n_dist] > dp[v][time]:",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + -1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-3][i] * (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-3][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-1][i] * (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-1][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-0][i] * (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-0][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[-1][i] * (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[-1][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = min((dp[-2][i] * (g + r) + i for i in range(g + 1)))",
      "mutated_line": "ans = min((dp[--2][i] * (g + r) + i for i in range(g + 1)))",
      "code": "import sys\nfrom array import array\nfrom collections import deque\n\ndef min_time_to_cross_road(n: int, m: int, safety_islands: list[int], g: int, r: int) -> int:\n    safety_islands = [-10 ** 9] + sorted(safety_islands) + [10 ** 9]\n    inf = 10 ** 9\n    dp = [array('i', [inf]) * (g + 1) for _ in range(m + 2)]\n    dp[1][0] = 0\n    dq = deque([(1, 0)])\n    while dq:\n        (v, time) = dq.popleft()\n        p_dist = safety_islands[v] - safety_islands[v - 1]\n        n_dist = safety_islands[v + 1] - safety_islands[v]\n        if time == g:\n            if p_dist <= g and dp[v - 1][p_dist] > dp[v][time] + 1:\n                dp[v - 1][p_dist] = dp[v][time] + 1\n                dq.append((v - 1, p_dist))\n            if n_dist <= g and dp[v + 1][n_dist] > dp[v][time] + 1:\n                dp[v + 1][n_dist] = dp[v][time] + 1\n                dq.append((v + 1, n_dist))\n        else:\n            if time + p_dist <= g and dp[v - 1][time + p_dist] > dp[v][time]:\n                dp[v - 1][time + p_dist] = dp[v][time]\n                dq.appendleft((v - 1, time + p_dist))\n            if time + n_dist <= g and dp[v + 1][time + n_dist] > dp[v][time]:\n                dp[v + 1][time + n_dist] = dp[v][time]\n                dq.appendleft((v + 1, time + n_dist))\n    ans = min((dp[--2][i] * (g + r) + i for i in range(g + 1)))\n    return ans if ans < inf else -1"
    }
  ]
}