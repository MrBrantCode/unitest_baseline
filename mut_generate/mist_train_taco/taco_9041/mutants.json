{
  "task_id": "taco_9041",
  "entry_point": "min_stones_to_unify_board",
  "mutant_count": 10,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\"\"\"\n    transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([2 for (a, b) in zip(S, S[1:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([2 for (a, b) in zip(S, S[1:]) if a != b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([0 for (a, b) in zip(S, S[1:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([0 for (a, b) in zip(S, S[1:]) if a != b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([0 for (a, b) in zip(S, S[1:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([0 for (a, b) in zip(S, S[1:]) if a != b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([-1 for (a, b) in zip(S, S[1:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([-1 for (a, b) in zip(S, S[1:]) if a != b])\n    return transitions"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a == b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([1 for (a, b) in zip(S, S[1:]) if a == b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([1 for (a, b) in zip(S, S[2:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([1 for (a, b) in zip(S, S[2:]) if a != b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([1 for (a, b) in zip(S, S[0:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([1 for (a, b) in zip(S, S[0:]) if a != b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([1 for (a, b) in zip(S, S[0:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([1 for (a, b) in zip(S, S[0:]) if a != b])\n    return transitions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transitions = len([1 for (a, b) in zip(S, S[1:]) if a != b])",
      "mutated_line": "transitions = len([1 for (a, b) in zip(S, S[-1:]) if a != b])",
      "code": "def min_stones_to_unify_board(S: str) -> int:\n    \"\"\"\n    Calculate the minimum number of new stones needed to make all stones on the board the same color.\n\n    Args:\n        S (str): A string representing the state of the board, where each character is either 'B' (black) or 'W' (white).\n\n    Returns:\n        int: The minimum number of new stones that Jiro needs to place.\n    \"\"\"\n    transitions = len([1 for (a, b) in zip(S, S[-1:]) if a != b])\n    return transitions"
    }
  ]
}