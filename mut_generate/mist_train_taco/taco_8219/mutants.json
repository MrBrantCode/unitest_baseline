{
  "task_id": "taco_8219",
  "entry_point": "calculate_optimal_sweetness",
  "mutant_count": 53,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 * 10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 * 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 + 10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 + 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "wlst += ws[f]",
      "mutated_line": "wlst -= ws[f]",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst -= ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "plst += ps[f]",
      "mutated_line": "plst -= ps[f]",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst -= ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] / (m + 1)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] / (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] + (m + 1)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] + (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] ** (m + 1)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] ** (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 1\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = -1",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = -1\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 1\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 11 ** 10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 11 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 9 ** 10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 9 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 0 ** 10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 0 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 1 ** 10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 1 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = -10 ** 10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = -10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 11",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 11\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 9",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 9\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 0",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 0\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 1",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 1\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** -10",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** -10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] * (m - 1)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m - 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] * (m * 1)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m * 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[1] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[-1] = 0",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[-1] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[1] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [+INF] * (m + 1)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [+INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] * (m + 2)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 2)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] * (m + 0)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 0)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] * (m + 0)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 0)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [-INF] * (m + 1)",
      "mutated_line": "dp = [-INF] * (m + -1)",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + -1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m + p, -1, -1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m + p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m * p, -1, -1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m * p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, +1, -1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, +1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -1, +1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, +1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp[i + p] < dp[i] + w:",
      "mutated_line": "if dp[i + p] <= dp[i] + w:",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] <= dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp[i + p] < dp[i] + w:",
      "mutated_line": "if dp[i + p] >= dp[i] + w:",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] >= dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp[i + p] < dp[i] + w:",
      "mutated_line": "if dp[i + p] != dp[i] + w:",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] != dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -2, -1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -2, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -0, -1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -0, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -0, -1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -0, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, --1, -1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, --1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -1, -2):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -2):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -1, -0):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -0):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -1, -0):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -0):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(m - p, -1, -1):",
      "mutated_line": "for i in range(m - p, -1, --1):",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, --1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp[i + p] < dp[i] + w:",
      "mutated_line": "if dp[i + p] < dp[i] - w:",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] - w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp[i + p] < dp[i] + w:",
      "mutated_line": "if dp[i + p] < dp[i] * w:",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] * w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i + p] = dp[i] + w",
      "mutated_line": "dp[i + p] = dp[i] - w",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] - w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i + p] = dp[i] + w",
      "mutated_line": "dp[i + p] = dp[i] * w",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i + p] = dp[i] * w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp[i + p] < dp[i] + w:",
      "mutated_line": "if dp[i - p] < dp[i] + w:",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i - p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dp[i + p] < dp[i] + w:",
      "mutated_line": "if dp[i * p] < dp[i] + w:",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i * p] < dp[i] + w:\n                dp[i + p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i + p] = dp[i] + w",
      "mutated_line": "dp[i - p] = dp[i] + w",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i - p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i + p] = dp[i] + w",
      "mutated_line": "dp[i * p] = dp[i] + w",
      "code": "def calculate_optimal_sweetness(s, d, m, ws, ps, fs):\n    INF = 10 ** 10\n    wlst = []\n    plst = []\n    for f in fs:\n        wlst += ws[f]\n        plst += ps[f]\n    dp = [-INF] * (m + 1)\n    dp[0] = 0\n    for (w, p) in zip(wlst, plst):\n        for i in range(m - p, -1, -1):\n            if dp[i + p] < dp[i] + w:\n                dp[i * p] = dp[i] + w\n    max_score = max(dp)\n    min_cost = dp.index(max_score)\n    return (max_score, min_cost)"
    }
  ]
}