{
  "task_id": "taco_13100",
  "entry_point": "count_beautiful_paths",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 - 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 * 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "counts = [0] * N",
      "mutated_line": "counts = [0] / N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] / N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "counts = [0] * N",
      "mutated_line": "counts = [0] + N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] + N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "counts = [0] * N",
      "mutated_line": "counts = [0] ** N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] ** N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = sum(counts) % MOD",
      "mutated_line": "ans = sum(counts) * MOD",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) * MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = sum(counts) % MOD",
      "mutated_line": "ans = sum(counts) + MOD",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) + MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if len(set(S)) == 1:",
      "mutated_line": "for (key, val) in extras_[ord(S[0]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) != 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 * 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 + 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 8\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 6\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 0\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 1\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + -7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "orda = ord('a')",
      "mutated_line": "orda = ord('')",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "U = [u - 1 for u in U]",
      "mutated_line": "U = [u + 1 for u in U]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u + 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "U = [u - 1 for u in U]",
      "mutated_line": "U = [u * 1 for u in U]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u * 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "V = [v - 1 for v in V]",
      "mutated_line": "V = [v + 1 for v in V]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v + 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "V = [v - 1 for v in V]",
      "mutated_line": "V = [v * 1 for v in V]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v * 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if vertex[u] == vertex[v]:",
      "mutated_line": "if vertex[u] != vertex[v]:",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] != vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if v == S[0]:",
      "mutated_line": "if v != S[0]:",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v != S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] -= 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] -= 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, L):",
      "mutated_line": "for i in range(2, L):",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(2, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, L):",
      "mutated_line": "for i in range(0, L):",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(0, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, L):",
      "mutated_line": "for i in range(0, L):",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(0, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, L):",
      "mutated_line": "for i in range(-1, L):",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(-1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "targ = ord(S[i]) - orda",
      "mutated_line": "targ = ord(S[i]) + orda",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) + orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "targ = ord(S[i]) - orda",
      "mutated_line": "targ = ord(S[i]) * orda",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) * orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "new_counts = [0] * N",
      "mutated_line": "new_counts = [0] / N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] / N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "new_counts = [0] * N",
      "mutated_line": "new_counts = [0] + N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] + N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "new_counts = [0] * N",
      "mutated_line": "new_counts = [0] ** N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] ** N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if len(set(S)) == 1:",
      "mutated_line": "for (key, val) in extras_[ord(S[0]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 2:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if len(set(S)) == 1:",
      "mutated_line": "for (key, val) in extras_[ord(S[0]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 0:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if len(set(S)) == 1:",
      "mutated_line": "for (key, val) in extras_[ord(S[0]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 0:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if len(set(S)) == 1:",
      "mutated_line": "for (key, val) in extras_[ord(S[0]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == -1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "ans -= pow(val, L - 1, MOD)",
      "mutated_line": "ans += pow(val, L - 1, MOD)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans += pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 11 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 9 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 0 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 1 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = -10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 10 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 8 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 0 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 1 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** -9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "counts = [0] * N",
      "mutated_line": "counts = [1] * N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [1] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "counts = [0] * N",
      "mutated_line": "counts = [-1] * N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [-1] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "counts = [0] * N",
      "mutated_line": "counts = [1] * N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [1] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "U = [u - 1 for u in U]",
      "mutated_line": "U = [u - 2 for u in U]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 2 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "U = [u - 1 for u in U]",
      "mutated_line": "U = [u - 0 for u in U]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 0 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "U = [u - 1 for u in U]",
      "mutated_line": "U = [u - 0 for u in U]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 0 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "U = [u - 1 for u in U]",
      "mutated_line": "U = [u - -1 for u in U]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - -1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "V = [v - 1 for v in V]",
      "mutated_line": "V = [v - 2 for v in V]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 2 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "V = [v - 1 for v in V]",
      "mutated_line": "V = [v - 0 for v in V]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 0 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "V = [v - 1 for v in V]",
      "mutated_line": "V = [v - 0 for v in V]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 0 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "V = [v - 1 for v in V]",
      "mutated_line": "V = [v - -1 for v in V]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - -1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) - 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) - 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) * 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) * 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += 2",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 2\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += 0",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 0\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += 0",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 0\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += -1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += -1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "new_counts[x] += counts[j]",
      "mutated_line": "new_counts[x] -= counts[j]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] -= counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "extras_ = [{} for _ in range(26)]",
      "mutated_line": "extras_ = [{} for _ in range(27)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(27)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "extras_ = [{} for _ in range(26)]",
      "mutated_line": "extras_ = [{} for _ in range(25)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(25)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "extras_ = [{} for _ in range(26)]",
      "mutated_line": "extras_ = [{} for _ in range(0)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(0)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "extras_ = [{} for _ in range(26)]",
      "mutated_line": "extras_ = [{} for _ in range(1)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(1)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "extras_ = [{} for _ in range(26)]",
      "mutated_line": "extras_ = [{} for _ in range(-26)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(-26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 2",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 2\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 0",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 0\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 0",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 0\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + -1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + -1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v == S[0]:",
      "mutated_line": "if v == S[1]:",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[1]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v == S[0]:",
      "mutated_line": "if v == S[-1]:",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[-1]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v == S[0]:",
      "mutated_line": "if v == S[1]:",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[1]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_counts = [0] * N",
      "mutated_line": "new_counts = [1] * N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [1] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_counts = [0] * N",
      "mutated_line": "new_counts = [-1] * N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [-1] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "new_counts = [0] * N",
      "mutated_line": "new_counts = [1] * N",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [1] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans -= pow(val, L - 1, MOD)",
      "mutated_line": "ans -= pow(val, L + 1, MOD)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L + 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans -= pow(val, L - 1, MOD)",
      "mutated_line": "ans -= pow(val, L * 1, MOD)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L * 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[[] for _ in range(26)] for _ in range(N)]",
      "mutated_line": "G = [[[] for _ in range(27)] for _ in range(N)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(27)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[[] for _ in range(26)] for _ in range(N)]",
      "mutated_line": "G = [[[] for _ in range(25)] for _ in range(N)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(25)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[[] for _ in range(26)] for _ in range(N)]",
      "mutated_line": "G = [[[] for _ in range(0)] for _ in range(N)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(0)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[[] for _ in range(26)] for _ in range(N)]",
      "mutated_line": "G = [[[] for _ in range(1)] for _ in range(N)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(1)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G = [[[] for _ in range(26)] for _ in range(N)]",
      "mutated_line": "G = [[[] for _ in range(-26)] for _ in range(N)]",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(-26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "G[u][ord(vertex[v]) - orda].append(v)",
      "mutated_line": "G[u][ord(vertex[v]) + orda].append(v)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) + orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "G[u][ord(vertex[v]) - orda].append(v)",
      "mutated_line": "G[u][ord(vertex[v]) * orda].append(v)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) * orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "G[v][ord(vertex[u]) - orda].append(u)",
      "mutated_line": "G[v][ord(vertex[u]) + orda].append(u)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) + orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "G[v][ord(vertex[u]) - orda].append(u)",
      "mutated_line": "G[v][ord(vertex[u]) * orda].append(u)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) * orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) + orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) + orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) * orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) * orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 1) + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 1) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, -1) + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, -1) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 1) + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 1) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for key, val in extras_[ord(S[0]) - orda].items():",
      "mutated_line": "for (key, val) in extras_[ord(S[0]) + orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) + orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for key, val in extras_[ord(S[0]) - orda].items():",
      "mutated_line": "for (key, val) in extras_[ord(S[0]) * orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) * orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans -= pow(val, L - 1, MOD)",
      "mutated_line": "ans -= pow(val, L - 2, MOD)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 2, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans -= pow(val, L - 1, MOD)",
      "mutated_line": "ans -= pow(val, L - 0, MOD)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 0, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans -= pow(val, L - 1, MOD)",
      "mutated_line": "ans -= pow(val, L - 0, MOD)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 0, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans -= pow(val, L - 1, MOD)",
      "mutated_line": "ans -= pow(val, L - -1, MOD)",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - -1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) + orda].get(key, 0) + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) + orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1",
      "mutated_line": "extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) * orda].get(key, 0) + 1",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) * orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[0]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for key, val in extras_[ord(S[0]) - orda].items():",
      "mutated_line": "for (key, val) in extras_[ord(S[1]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[1]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for key, val in extras_[ord(S[0]) - orda].items():",
      "mutated_line": "for (key, val) in extras_[ord(S[-1]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[-1]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for key, val in extras_[ord(S[0]) - orda].items():",
      "mutated_line": "for (key, val) in extras_[ord(S[1]) - orda].items():",
      "code": "def count_beautiful_paths(N, M, L, S, vertex, U, V):\n    MOD = 10 ** 9 + 7\n    counts = [0] * N\n    G = [[[] for _ in range(26)] for _ in range(N)]\n    orda = ord('a')\n    extras_ = [{} for _ in range(26)]\n    U = [u - 1 for u in U]\n    V = [v - 1 for v in V]\n    for i in range(M):\n        (u, v) = (U[i], V[i])\n        G[u][ord(vertex[v]) - orda].append(v)\n        G[v][ord(vertex[u]) - orda].append(u)\n        if vertex[u] == vertex[v]:\n            key = (min(u, v), max(u, v))\n            extras_[ord(vertex[u]) - orda][key] = extras_[ord(vertex[u]) - orda].get(key, 0) + 1\n    for (i, v) in enumerate(vertex):\n        if v == S[0]:\n            counts[i] += 1\n    for i in range(1, L):\n        targ = ord(S[i]) - orda\n        new_counts = [0] * N\n        for j in range(N):\n            for x in G[j][targ]:\n                new_counts[x] += counts[j]\n                new_counts[x] %= MOD\n        counts = list(new_counts)\n    ans = sum(counts) % MOD\n    if len(set(S)) == 1:\n        for (key, val) in extras_[ord(S[1]) - orda].items():\n            ans -= pow(val, L - 1, MOD)\n            ans %= MOD\n    return ans"
    }
  ]
}