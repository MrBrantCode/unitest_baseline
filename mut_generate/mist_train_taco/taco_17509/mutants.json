{
  "task_id": "taco_17509",
  "entry_point": "check_reverse_polish_notation",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return 'correct'",
      "mutated_line": "return ''",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif token in var_dict:",
      "mutated_line": "elif token not in var_dict:",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token not in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))",
      "mutated_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) - 1))",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) - 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))",
      "mutated_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) * 1))",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) * 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if token == '/':",
      "mutated_line": "if token != '/':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token != '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))",
      "mutated_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 2))",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 2))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))",
      "mutated_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 0))",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 0))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))",
      "mutated_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 0))",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 0))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))",
      "mutated_line": "var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + -1))",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + -1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if token == '/':",
      "mutated_line": "if token == '':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 in b:",
      "mutated_line": "if 0 not in b:",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 not in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif token == '+':",
      "mutated_line": "elif token != '+':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token != '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 in b:",
      "mutated_line": "if 1 in b:",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 1 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 in b:",
      "mutated_line": "if -1 in b:",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if -1 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 in b:",
      "mutated_line": "if 1 in b:",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 1 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'error'",
      "mutated_line": "return ''",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return ''\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif token == '+':",
      "mutated_line": "elif token == '':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif token == '-':",
      "mutated_line": "elif token != '-':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token != '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif token == '-':",
      "mutated_line": "elif token == '':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "elif token == '*':",
      "mutated_line": "elif token != '*':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token != '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai // bi * 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi * 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai // bi + 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi + 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif token == '*':",
      "mutated_line": "elif token == '':",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai / bi % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai / bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai * bi % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai // bi % 257)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 257)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai // bi % 255)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 255)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai // bi % 0)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 0)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai // bi % 1)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 1)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "result_set.add(ai // bi % 256)",
      "mutated_line": "result_set.add(ai // bi % -256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % -256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add((ai + bi) * 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) * 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add(ai + bi + 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai + bi + 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add((ai - bi) % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add(ai * bi % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add((ai + bi) % 257)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 257)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add((ai + bi) % 255)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 255)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add((ai + bi) % 0)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 0)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add((ai + bi) % 1)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 1)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "result_set.add((ai + bi) % 256)",
      "mutated_line": "result_set.add((ai + bi) % -256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % -256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add((ai - bi) * 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) * 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add(ai - bi + 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai - bi + 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add((ai + bi) % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add(ai * bi % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add((ai - bi) % 257)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 257)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add((ai - bi) % 255)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 255)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add((ai - bi) % 0)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 0)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add((ai - bi) % 1)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 1)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result_set.add((ai - bi) % 256)",
      "mutated_line": "result_set.add((ai - bi) % -256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % -256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai * bi * 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi * 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai * bi + 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi + 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai / bi % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai / bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add((ai + bi) % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai ** bi % 256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai ** bi % 256)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai * bi % 257)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 257)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai * bi % 255)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 255)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai * bi % 0)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 0)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai * bi % 1)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % 1)\n            stack.append(result_set)\n    return 'correct'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result_set.add(ai * bi % 256)",
      "mutated_line": "result_set.add(ai * bi % -256)",
      "code": "def check_reverse_polish_notation(variables, expression):\n    var_dict = {}\n    for (var_name, lower_bound, upper_bound) in variables:\n        var_dict[var_name] = set(range(int(lower_bound), int(upper_bound) + 1))\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(set([int(token)]))\n        elif token in var_dict:\n            stack.append(var_dict[token])\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            result_set = set()\n            if token == '/':\n                if 0 in b:\n                    return 'error'\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai // bi % 256)\n            elif token == '+':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai + bi) % 256)\n            elif token == '-':\n                for ai in a:\n                    for bi in b:\n                        result_set.add((ai - bi) % 256)\n            elif token == '*':\n                for ai in a:\n                    for bi in b:\n                        result_set.add(ai * bi % -256)\n            stack.append(result_set)\n    return 'correct'"
    }
  ]
}