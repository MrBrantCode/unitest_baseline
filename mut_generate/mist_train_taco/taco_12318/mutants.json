{
  "task_id": "taco_12318",
  "entry_point": "find_monitor_break_time",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if q == 0:",
      "mutated_line": "if q != 0:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q != 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "inf = len(times) + 1",
      "mutated_line": "(ok, ng) = (inf, 0)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) - 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "inf = len(times) + 1",
      "mutated_line": "(ok, ng) = (inf, 0)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) * 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) >= 1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) >= 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) <= 1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) <= 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) != 1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) != 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if q == 0:",
      "mutated_line": "if q == 1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 1:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if q == 0:",
      "mutated_line": "if q == -1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == -1:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if q == 0:",
      "mutated_line": "if q == 1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 1:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return +1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "imos[x][y] += 1",
      "mutated_line": "imos[x][y] -= 1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] -= 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return True\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "inf = len(times) + 1",
      "mutated_line": "(ok, ng) = (inf, 0)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 2\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "inf = len(times) + 1",
      "mutated_line": "(ok, ng) = (inf, 0)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 0\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "inf = len(times) + 1",
      "mutated_line": "(ok, ng) = (inf, 0)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 0\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "inf = len(times) + 1",
      "mutated_line": "(ok, ng) = (inf, 0)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + -1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ok, ng = inf, 0",
      "mutated_line": "(ok, ng) = (inf, 1)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 1)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ok, ng = inf, 0",
      "mutated_line": "(ok, ng) = (inf, -1)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, -1)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ok, ng = inf, 0",
      "mutated_line": "(ok, ng) = (inf, 1)",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 1)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > 2:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 2:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > 0:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 0:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > 0:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 0:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > -1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > -1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if mid >= k * k and solve(mid):",
      "mutated_line": "if mid >= k * k or solve(mid):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k or solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 1] if ok == inf else -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok == inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 1] if ok != inf else +1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else +1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -2\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -0\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -0\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return --1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "times = [pixel[2] for pixel in broken_pixels]",
      "mutated_line": "times = [pixel[3] for pixel in broken_pixels]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[3] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "times = [pixel[2] for pixel in broken_pixels]",
      "mutated_line": "times = [pixel[1] for pixel in broken_pixels]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[1] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "times = [pixel[2] for pixel in broken_pixels]",
      "mutated_line": "times = [pixel[0] for pixel in broken_pixels]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[0] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "times = [pixel[2] for pixel in broken_pixels]",
      "mutated_line": "times = [pixel[1] for pixel in broken_pixels]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[1] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "times = [pixel[2] for pixel in broken_pixels]",
      "mutated_line": "times = [pixel[-2] for pixel in broken_pixels]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[-2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] / (m + 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] / (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] + (m + 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] + (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] ** (m + 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] ** (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "imos[x][y] += 1",
      "mutated_line": "imos[x][y] += 2",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 2\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "imos[x][y] += 1",
      "mutated_line": "imos[x][y] += 0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 0\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "imos[x][y] += 1",
      "mutated_line": "imos[x][y] += 0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 0\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "imos[x][y] += 1",
      "mutated_line": "imos[x][y] += -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += -1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n - 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n * 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "imos[i][j + 1] += imos[i][j]",
      "mutated_line": "imos[i][j + 1] -= imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] -= imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(m + 1):",
      "mutated_line": "for j in range(m - 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m - 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(m + 1):",
      "mutated_line": "for j in range(m * 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m * 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "imos[i + 1][j] += imos[i][j]",
      "mutated_line": "imos[i + 1][j] -= imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] -= imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in range(k, n + 1):",
      "mutated_line": "for i in range(k, n - 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n - 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in range(k, n + 1):",
      "mutated_line": "for i in range(k, n * 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n * 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok + ng) > 1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok + ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok * ng) > 1:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok * ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mid = (ok + ng) >> 1",
      "mutated_line": "mid = ok - ng >> 1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok - ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mid = (ok + ng) >> 1",
      "mutated_line": "mid = ok * ng >> 1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok * ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (ok + ng) >> 1",
      "mutated_line": "mid = ok + ng >> 2",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 2\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (ok + ng) >> 1",
      "mutated_line": "mid = ok + ng >> 0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 0\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (ok + ng) >> 1",
      "mutated_line": "mid = ok + ng >> 0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 0\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (ok + ng) >> 1",
      "mutated_line": "mid = ok + ng >> -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> -1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if mid >= k * k and solve(mid):",
      "mutated_line": "if mid > k * k and solve(mid):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid > k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if mid >= k * k and solve(mid):",
      "mutated_line": "if mid < k * k and solve(mid):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid < k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if mid >= k * k and solve(mid):",
      "mutated_line": "if mid == k * k and solve(mid):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid == k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok + 1] if ok != inf else -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok + 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok * 1] if ok != inf else -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok * 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 1] if ok != inf else -2",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -2"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 1] if ok != inf else -0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 1] if ok != inf else -0",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 1] if ok != inf else --1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else --1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m - 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m - 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m * 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m * 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 2):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 0):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 0):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + -1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(m + 1):",
      "mutated_line": "for j in range(m + 2):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 2):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(m + 1):",
      "mutated_line": "for j in range(m + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 0):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(m + 1):",
      "mutated_line": "for j in range(m + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 0):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(m + 1):",
      "mutated_line": "for j in range(m + -1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + -1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(k, n + 1):",
      "mutated_line": "for i in range(k, n + 2):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 2):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(k, n + 1):",
      "mutated_line": "for i in range(k, n + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 0):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(k, n + 1):",
      "mutated_line": "for i in range(k, n + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 0):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(k, n + 1):",
      "mutated_line": "for i in range(k, n + -1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + -1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(k, m + 1):",
      "mutated_line": "for j in range(k, m - 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m - 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(k, m + 1):",
      "mutated_line": "for j in range(k, m * 1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m * 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] != k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] != k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if mid >= k * k and solve(mid):",
      "mutated_line": "if mid >= k / k and solve(mid):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k / k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if mid >= k * k and solve(mid):",
      "mutated_line": "if mid >= k + k and solve(mid):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k + k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if mid >= k * k and solve(mid):",
      "mutated_line": "if mid >= k ** k and solve(mid):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k ** k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 2] if ok != inf else -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 2] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 0] if ok != inf else -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 0] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - 0] if ok != inf else -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 0] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return times[ok - 1] if ok != inf else -1",
      "mutated_line": "return times[ok - -1] if ok != inf else -1",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - -1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "broken_pixels.sort(key=lambda x: x[2])",
      "mutated_line": "broken_pixels.sort(key=lambda x: x[3])",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[3])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "broken_pixels.sort(key=lambda x: x[2])",
      "mutated_line": "broken_pixels.sort(key=lambda x: x[1])",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[1])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "broken_pixels.sort(key=lambda x: x[2])",
      "mutated_line": "broken_pixels.sort(key=lambda x: x[0])",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[0])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "broken_pixels.sort(key=lambda x: x[2])",
      "mutated_line": "broken_pixels.sort(key=lambda x: x[1])",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[1])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "broken_pixels.sort(key=lambda x: x[2])",
      "mutated_line": "broken_pixels.sort(key=lambda x: x[-2])",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[-2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[1] * (m + 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[1] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[-1] * (m + 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[-1] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[1] * (m + 1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[1] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 2) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 2) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 0) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 0) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 0) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 0) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + -1) for _ in range(n + 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + -1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 1) for _ in range(n - 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n - 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 1) for _ in range(n * 1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n * 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "imos[i][j + 1] += imos[i][j]",
      "mutated_line": "imos[i][j - 1] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j - 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "imos[i][j + 1] += imos[i][j]",
      "mutated_line": "imos[i][j * 1] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j * 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(k, m + 1):",
      "mutated_line": "for j in range(k, m + 2):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 2):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(k, m + 1):",
      "mutated_line": "for j in range(k, m + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 0):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(k, m + 1):",
      "mutated_line": "for j in range(k, m + 0):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 0):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(k, m + 1):",
      "mutated_line": "for j in range(k, m + -1):",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + -1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] - imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] - imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if (imos[i][j] - imos[i - k][j] - imos[i][j - k]) * imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if (imos[i][j] - imos[i - k][j] - imos[i][j - k]) * imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k / k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k / k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k + k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k + k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k ** k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k ** k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return False\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 1) for _ in range(n + 2)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 2)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 1) for _ in range(n + 0)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 0)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 1) for _ in range(n + 0)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 0)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "imos = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "imos = [[0] * (m + 1) for _ in range(n + -1)]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + -1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "imos[i][j + 1] += imos[i][j]",
      "mutated_line": "imos[i][j + 2] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 2] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "imos[i][j + 1] += imos[i][j]",
      "mutated_line": "imos[i][j + 0] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 0] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "imos[i][j + 1] += imos[i][j]",
      "mutated_line": "imos[i][j + 0] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 0] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "imos[i][j + 1] += imos[i][j]",
      "mutated_line": "imos[i][j + -1] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + -1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "imos[i + 1][j] += imos[i][j]",
      "mutated_line": "imos[i - 1][j] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i - 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "imos[i + 1][j] += imos[i][j]",
      "mutated_line": "imos[i * 1][j] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i * 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] + imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] + imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if (imos[i][j] - imos[i - k][j]) * imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if (imos[i][j] - imos[i - k][j]) * imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "imos[i + 1][j] += imos[i][j]",
      "mutated_line": "imos[i + 2][j] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 2][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "imos[i + 1][j] += imos[i][j]",
      "mutated_line": "imos[i + 0][j] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 0][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "imos[i + 1][j] += imos[i][j]",
      "mutated_line": "imos[i + 0][j] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 0][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "imos[i + 1][j] += imos[i][j]",
      "mutated_line": "imos[i + -1][j] += imos[i][j]",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + -1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] + imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] + imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] * imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] * imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j + k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j + k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j * k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j * k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j + k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j + k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j * k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j * k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i + k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i + k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i * k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i * k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i + k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i + k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if imos[i][j] - imos[i - k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "mutated_line": "if imos[i][j] - imos[i * k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:",
      "code": "def find_monitor_break_time(n, m, k, q, broken_pixels):\n    if q == 0:\n        return -1\n    broken_pixels.sort(key=lambda x: x[2])\n    times = [pixel[2] for pixel in broken_pixels]\n\n    def solve(ti):\n        imos = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(ti):\n            (x, y, _) = broken_pixels[i]\n            imos[x][y] += 1\n        for i in range(n + 1):\n            for j in range(m):\n                imos[i][j + 1] += imos[i][j]\n        for j in range(m + 1):\n            for i in range(n):\n                imos[i + 1][j] += imos[i][j]\n        for i in range(k, n + 1):\n            for j in range(k, m + 1):\n                if imos[i][j] - imos[i * k][j] - imos[i][j - k] + imos[i - k][j - k] == k * k:\n                    return True\n        return False\n    inf = len(times) + 1\n    (ok, ng) = (inf, 0)\n    while abs(ok - ng) > 1:\n        mid = ok + ng >> 1\n        if mid >= k * k and solve(mid):\n            ok = mid\n        else:\n            ng = mid\n    return times[ok - 1] if ok != inf else -1"
    }
  ]
}