{
  "task_id": "taco_14538",
  "entry_point": "calculate_dancer_stopping_positions",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])",
      "mutated_line": "Dancer = namedtuple('', ['category', 'x', 'y', 'idx', 'group'])",
      "code": "from collections import namedtuple\nDancer = namedtuple('', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "end_pos = [None] * n",
      "mutated_line": "end_pos = [None] / n",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] / n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "end_pos = [None] * n",
      "mutated_line": "end_pos = [None] + n",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] + n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "end_pos = [None] * n",
      "mutated_line": "end_pos = [None] ** n",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] ** n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])",
      "mutated_line": "Dancer = namedtuple('Dancer', ['', 'x', 'y', 'idx', 'group'])",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])",
      "mutated_line": "Dancer = namedtuple('Dancer', ['category', '', 'y', 'idx', 'group'])",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', '', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])",
      "mutated_line": "Dancer = namedtuple('Dancer', ['category', 'x', '', 'idx', 'group'])",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', '', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])",
      "mutated_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', '', 'group'])",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', '', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])",
      "mutated_line": "Dancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', ''])",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', ''])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if group == 1:",
      "mutated_line": "if group != 1:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group != 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if dancer.x == 0:",
      "mutated_line": "if dancer.x != 0:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x != 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if group == 1:",
      "mutated_line": "if group == 2:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 2:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if group == 1:",
      "mutated_line": "if group == 0:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 0:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if group == 1:",
      "mutated_line": "if group == 0:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 0:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if group == 1:",
      "mutated_line": "if group == -1:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == -1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return Dancer(time - pos, x, y, idx, group)",
      "mutated_line": "return Dancer(time + pos, x, y, idx, group)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time + pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return Dancer(time - pos, x, y, idx, group)",
      "mutated_line": "return Dancer(time * pos, x, y, idx, group)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time * pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if dancer.x == 0:",
      "mutated_line": "if dancer.x == 1:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 1:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if dancer.x == 0:",
      "mutated_line": "if dancer.x == -1:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == -1:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if dancer.x == 0:",
      "mutated_line": "if dancer.x == 1:",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 1:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = pos, 0",
      "mutated_line": "(x, y) = (pos, 1)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 1)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = pos, 0",
      "mutated_line": "(x, y) = (pos, -1)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, -1)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = pos, 0",
      "mutated_line": "(x, y) = (pos, 1)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 1)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = 0, pos",
      "mutated_line": "(x, y) = (1, pos)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (1, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = 0, pos",
      "mutated_line": "(x, y) = (-1, pos)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (-1, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x, y = 0, pos",
      "mutated_line": "(x, y) = (1, pos)",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (1, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))",
      "mutated_line": "dancers_in = sorted(dancers, key=lambda d: (d.category, +d.group, d.x, -d.y))",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, +d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))",
      "mutated_line": "dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, +d.y))",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, +d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, -d.y))",
      "mutated_line": "dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, +d.y))",
      "code": "from collections import namedtuple\nDancer = namedtuple('Dancer', ['category', 'x', 'y', 'idx', 'group'])\n\ndef calculate_dancer_stopping_positions(n, w, h, dancers):\n\n    def create_dancer(idx, group, pos, time):\n        (x, y) = (None, None)\n        if group == 1:\n            (x, y) = (pos, 0)\n        else:\n            (x, y) = (0, pos)\n        return Dancer(time - pos, x, y, idx, group)\n    dancers = [create_dancer(idx, group, pos, time) for (idx, (group, pos, time)) in enumerate(dancers)]\n    dancers_in = sorted(dancers, key=lambda d: (d.category, -d.group, d.x, -d.y))\n    dancers_out = sorted(dancers, key=lambda d: (d.category, d.group, d.x, +d.y))\n    end_pos = [None] * n\n\n    def get_end_pos(dancer):\n        (x, y) = (None, None)\n        if dancer.x == 0:\n            (x, y) = (w, dancer.y)\n        else:\n            (x, y) = (dancer.x, h)\n        return (x, y)\n    for i in range(n):\n        end_pos[dancers_in[i].idx] = get_end_pos(dancers_out[i])\n    return end_pos"
    }
  ]
}