{
  "task_id": "taco_5199",
  "entry_point": "find_minimum_meeting_distance",
  "mutant_count": 206,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if N == 0:",
      "mutated_line": "if N != 0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N != 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 * 18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 * 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 + 18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 + 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "UOI",
      "lineno": 55,
      "original_line": "return -1.0",
      "mutated_line": "return +1.0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return +1.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 1:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if N == 0:",
      "mutated_line": "if N == -1:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == -1:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 1:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0.0",
      "mutated_line": "return 1.0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 1.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0.0",
      "mutated_line": "return -1.0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return -1.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0.0",
      "mutated_line": "return 1",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 1\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N + 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N * 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if y0 != y1:",
      "mutated_line": "if y0 == y1:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 == y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if py == qy:",
      "mutated_line": "if py != qy:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py != qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 2) * 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) * 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return (px - qx) ** 2 + (py - qy) ** 2 + 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return (px - qx) ** 2 + (py - qy) ** 2 + 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 11 ** 18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 11 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 9 ** 18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 9 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 0 ** 18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 0 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 1 ** 18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 1 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = -10 ** 18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = -10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 19",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 19\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 17",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 17\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 0\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 1",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 1\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** -18",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** -18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L - 1): 1}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 1}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L - 1): -1}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): -1}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L - 1): 1}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 1}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if cost < dist[a, b]:",
      "mutated_line": "if cost <= dist[a, b]:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost <= dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if cost < dist[a, b]:",
      "mutated_line": "if cost >= dist[a, b]:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost >= dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if cost < dist[a, b]:",
      "mutated_line": "if cost != dist[a, b]:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost != dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a == b:",
      "mutated_line": "if a != b:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a != b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return -1.0",
      "mutated_line": "return -2.0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -2.0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return -1.0",
      "mutated_line": "return -0.0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -0.0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return -1.0",
      "mutated_line": "return -0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return -1.0",
      "mutated_line": "return --1.0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return --1.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 2):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 2):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 0):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 0):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - -1):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - -1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(x1, y1) = points[i + 1]",
      "mutated_line": "(x1, y1) = points[i - 1]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i - 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(x1, y1) = points[i + 1]",
      "mutated_line": "(x1, y1) = points[i * 1]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i * 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 - (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 - (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 * (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 * (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 1.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 1.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** -0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** -0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 1",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 1\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** -0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** -0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(1, 0, L - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(1, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(-1, 0, L - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(-1, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(1, 0, L - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(1, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 1, L - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 1, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, -1, L - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, -1, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 1, L - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 1, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 0, L + 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L + 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 0, L * 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L * 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(1, L - 1): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(1, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(-1, L - 1): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(-1, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(1, L - 1): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(1, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L + 1): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L + 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L * 1): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L * 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((2, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((2, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((0, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((0, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((0, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((0, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((-1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((-1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, +1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, +1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (2, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (2, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (0, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (0, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (0, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (0, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (-1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (-1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 1), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 1), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, -1), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, -1), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 1), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 1), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (1, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (1, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (-1, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (-1, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (1, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (1, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, +1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, +1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (+1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (+1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 1), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 1), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, -1), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, -1), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 1), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 1), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 2), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 2), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 0), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 0), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 0), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 0), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, -1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, -1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (2, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (2, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (0, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (0, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (0, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (0, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (-1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (-1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 2), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 2), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 0), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 0), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 0), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 0), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, -1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, -1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (+1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (+1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, +1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, +1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (+1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (+1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 2))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 0))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 0))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, -1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, -1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "na = a + da",
      "mutated_line": "na = a - da",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a - da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "na = a + da",
      "mutated_line": "na = a * da",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a * da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "nb = b + db",
      "mutated_line": "nb = b - db",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b - db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "nb = b + db",
      "mutated_line": "nb = b * db",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b * db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if cy != dy:",
      "mutated_line": "if cy == dy:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy == dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)",
      "mutated_line": "n_cost = cost + f(ax, ay, cx, cy) - f(bx, by, dx, dy)",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) - f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)",
      "mutated_line": "n_cost = (cost + f(ax, ay, cx, cy)) * f(bx, by, dx, dy)",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = (cost + f(ax, ay, cx, cy)) * f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if n_cost < dist.get(key, INF):",
      "mutated_line": "if n_cost <= dist.get(key, INF):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost <= dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if n_cost < dist.get(key, INF):",
      "mutated_line": "if n_cost >= dist.get(key, INF):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost >= dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if n_cost < dist.get(key, INF):",
      "mutated_line": "if n_cost != dist.get(key, INF):",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost != dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(x1, y1) = points[i + 1]",
      "mutated_line": "(x1, y1) = points[i + 2]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 2]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(x1, y1) = points[i + 1]",
      "mutated_line": "(x1, y1) = points[i + 0]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 0]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(x1, y1) = points[i + 1]",
      "mutated_line": "(x1, y1) = points[i + 0]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 0]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(x1, y1) = points[i + 1]",
      "mutated_line": "(x1, y1) = points[i + -1]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + -1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if y0 < y < y1 or y1 < y < y0:",
      "mutated_line": "if y0 < y < y1 and y1 < y < y0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 and y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return abs(px - qx)",
      "mutated_line": "return abs(px + qx)",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px + qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return abs(px - qx)",
      "mutated_line": "return abs(px * qx)",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px * qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) * 2 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) * 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return (px - qx + 2 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return (px - qx + 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) * 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) * 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy + 2)) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy + 2)) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 0, L - 2)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 2)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 0, L - 0)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 0)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 0, L - 0)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 0)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que = [(0, 0, L - 1)]",
      "mutated_line": "que = [(0, 0, L - -1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - -1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L - 2): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 2): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L - 0): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 0): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L - 0): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 0): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist = {(0, L - 1): 0}",
      "mutated_line": "dist = {(0, L - -1): 0}",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - -1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -2), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -2), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -0), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -0), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -0), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -0), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, --1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, --1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -2), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -2), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -0), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -0), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -0), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -0), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, --1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, --1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-2, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-2, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-0, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-0, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-0, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-0, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (--1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (--1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-2, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-2, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-0, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-0, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-0, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-0, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (--1, -1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (--1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -2), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -2), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -0), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -0), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -0), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -0), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, --1), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, --1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-2, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-2, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-0, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-0, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))",
      "mutated_line": "dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (--1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (--1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if not 0 <= na <= nb < L:",
      "mutated_line": "if not 0 < na <= nb < L:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 < na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if not 0 <= na <= nb < L:",
      "mutated_line": "if not 0 > na <= nb < L:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 > na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if not 0 <= na <= nb < L:",
      "mutated_line": "if not 0 == na <= nb < L:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 == na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)",
      "mutated_line": "n_cost = cost - f(ax, ay, cx, cy) + f(bx, by, dx, dy)",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost - f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)",
      "mutated_line": "n_cost = cost * f(ax, ay, cx, cy) + f(bx, by, dx, dy)",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost * f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y0 < y < y1 or y1 < y < y0:",
      "mutated_line": "if y0 <= y < y1 or y1 < y < y0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 <= y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y0 < y < y1 or y1 < y < y0:",
      "mutated_line": "if y0 >= y < y1 or y1 < y < y0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 >= y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y0 < y < y1 or y1 < y < y0:",
      "mutated_line": "if y0 != y < y1 or y1 < y < y0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 != y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y0 < y < y1 or y1 < y < y0:",
      "mutated_line": "if y0 < y < y1 or y1 <= y < y0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 <= y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y0 < y < y1 or y1 < y < y0:",
      "mutated_line": "if y0 < y < y1 or y1 >= y < y0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 >= y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y0 < y < y1 or y1 < y < y0:",
      "mutated_line": "if y0 < y < y1 or y1 != y < y0:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 != y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) - x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) - x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) * x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) * x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "assert x0 < x < x1 or x1 < x < x0",
      "mutated_line": "assert x0 < x < x1 and x1 < x < x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 and x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px + qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px + qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px * qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px * qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 3 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 3 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 1 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 1 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 0 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 0 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 1 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 1 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** -2 + (py - qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** -2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py + qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py + qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py * qy) ** 2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py * qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 3) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 3) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 1) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 1) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 0) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 0) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** 1) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 1) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5",
      "mutated_line": "return ((px - qx) ** 2 + (py - qy) ** -2) ** 0.5",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** -2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not 0 <= na <= nb < L:",
      "mutated_line": "if not 1 <= na <= nb < L:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 1 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not 0 <= na <= nb < L:",
      "mutated_line": "if not -1 <= na <= nb < L:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not -1 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not 0 <= na <= nb < L:",
      "mutated_line": "if not 1 <= na <= nb < L:",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 1 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 - y0) / (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) / (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 - y0) + (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) + (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = ((x1 - x0) / (y1 - y0)) ** (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = ((x1 - x0) / (y1 - y0)) ** (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert x0 < x < x1 or x1 < x < x0",
      "mutated_line": "assert x0 <= x < x1 or x1 < x < x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 <= x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert x0 < x < x1 or x1 < x < x0",
      "mutated_line": "assert x0 >= x < x1 or x1 < x < x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 >= x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert x0 < x < x1 or x1 < x < x0",
      "mutated_line": "assert x0 != x < x1 or x1 < x < x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 != x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert x0 < x < x1 or x1 < x < x0",
      "mutated_line": "assert x0 < x < x1 or x1 <= x < x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 <= x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert x0 < x < x1 or x1 < x < x0",
      "mutated_line": "assert x0 < x < x1 or x1 >= x < x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 >= x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "assert x0 < x < x1 or x1 < x < x0",
      "mutated_line": "assert x0 < x < x1 or x1 != x < x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 != x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) * (y1 - y0) * (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) * (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) // (y1 - y0) * (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) // (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 - y0) * (y + y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y + y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 - y0) * (y * y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 - y0) * (y * y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 + x0) / (y1 - y0) * (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 + x0) / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = x1 * x0 / (y1 - y0) * (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = x1 * x0 / (y1 - y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 + y0) * (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 + y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = (x1 - x0) / (y1 - y0) * (y - y0) + x0",
      "mutated_line": "x = (x1 - x0) / (y1 * y0) * (y - y0) + x0",
      "code": "from heapq import heappush, heappop\n\ndef find_minimum_meeting_distance(points):\n    N = len(points)\n    if N == 0:\n        return 0.0\n    YS = set((y for (x, y) in points))\n    Q = points[:]\n    for i in range(N - 1):\n        (x0, y0) = points[i]\n        (x1, y1) = points[i + 1]\n        if y0 != y1:\n            for y in YS:\n                if y0 < y < y1 or y1 < y < y0:\n                    x = (x1 - x0) / (y1 * y0) * (y - y0) + x0\n                    assert x0 < x < x1 or x1 < x < x0\n                    Q.append((x, y))\n    Q.sort()\n\n    def f(px, py, qx, qy):\n        if py == qy:\n            return abs(px - qx)\n        return ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n    L = len(Q)\n    INF = 10 ** 18\n    que = [(0, 0, L - 1)]\n    dist = {(0, L - 1): 0}\n    dd = ((1, -1), (1, 0), (0, -1), (-1, 0), (0, 1), (1, 1), (-1, -1), (-1, 1))\n    while que:\n        (cost, a, b) = heappop(que)\n        if cost < dist[a, b]:\n            continue\n        if a == b:\n            return cost\n        (ax, ay) = Q[a]\n        (bx, by) = Q[b]\n        for (da, db) in dd:\n            na = a + da\n            nb = b + db\n            if not 0 <= na <= nb < L:\n                continue\n            (cx, cy) = Q[na]\n            (dx, dy) = Q[nb]\n            if cy != dy:\n                continue\n            n_cost = cost + f(ax, ay, cx, cy) + f(bx, by, dx, dy)\n            key = (na, nb)\n            if n_cost < dist.get(key, INF):\n                dist[key] = n_cost\n                heappush(que, (n_cost, na, nb))\n    return -1.0"
    }
  ]
}