{
  "task_id": "taco_17872",
  "entry_point": "find_max_peas_and_path",
  "mutant_count": 216,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 2,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k -= 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 2\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 0\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 0\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += -1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "empty = -1",
      "mutated_line": "empty = +1",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = +1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if ans == empty:",
      "mutated_line": "if ans != empty:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans != empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "path += prev[i][p_j][p_mod][2]",
      "mutated_line": "path -= prev[i][p_j][p_mod][2]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path -= prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "empty = -1",
      "mutated_line": "empty = -2",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -2\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "empty = -1",
      "mutated_line": "empty = -0",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -0\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "empty = -1",
      "mutated_line": "empty = -0",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -0\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "empty = -1",
      "mutated_line": "empty = --1",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = --1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n + 1, 0, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n + 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n * 1, 0, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n * 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 1, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 1, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, +1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, +1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, '')",
      "mutated_line": "(ans, p_j, p_mod, path) = (empty, 1, 0, '')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 1, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, '')",
      "mutated_line": "(ans, p_j, p_mod, path) = (empty, -1, 0, '')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, -1, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, '')",
      "mutated_line": "(ans, p_j, p_mod, path) = (empty, 1, 0, '')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 1, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, '')",
      "mutated_line": "(ans, p_j, p_mod, path) = (empty, 0, 1, '')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 1, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, '')",
      "mutated_line": "(ans, p_j, p_mod, path) = (empty, 0, -1, '')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, -1, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, '')",
      "mutated_line": "(ans, p_j, p_mod, path) = (empty, 0, 1, '')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 1, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, '')",
      "mutated_line": "(ans, p_j, p_mod, path) = (empty, 0, 0, 'MUTATED')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, 'MUTATED')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans <= dp[0][j][0]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans <= dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans >= dp[0][j][0]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans >= dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans != dp[0][j][0]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans != dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return +1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(2, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(0, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(0, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(-1, n - 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(-1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n + 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n * 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j - 1, path[::-1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j - 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j * 1, path[::-1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j * 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[[empty] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dp = [[[empty] / k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] / k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[[empty] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dp = [[[empty] + k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] + k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[[empty] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "dp = [[[empty] ** k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] ** k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, -1, '*')] / k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] / k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, -1, '*')] + k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] + k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, -1, '*')] ** k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] ** k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-1][i] * k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] * k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-1][i] + k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] + k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 2, 0, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 2, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 0, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 0, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - -1, 0, -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - -1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -2):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -2):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -0):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -0):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, --1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, --1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -2\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -0\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -0\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return --1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 2):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 2):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 0):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 0):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - -1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path += prev[i][p_j][p_mod][2]",
      "mutated_line": "path += prev[i][p_j][p_mod][3]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][3]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path += prev[i][p_j][p_mod][2]",
      "mutated_line": "path += prev[i][p_j][p_mod][1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][1]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path += prev[i][p_j][p_mod][2]",
      "mutated_line": "path += prev[i][p_j][p_mod][0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][0]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path += prev[i][p_j][p_mod][2]",
      "mutated_line": "path += prev[i][p_j][p_mod][1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][1]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "path += prev[i][p_j][p_mod][2]",
      "mutated_line": "path += prev[i][p_j][p_mod][-2]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][-2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 2, path[::-1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 2, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 0, path[::-1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 0, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 0, path[::-1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 0, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + -1, path[::-1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + -1, path[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-1][i] % k] = board[+1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[+1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dp[i][j][mod] == empty:",
      "mutated_line": "if dp[i][j][mod] != empty:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] != empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans < dp[0][j][1]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][1]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans < dp[0][j][-1]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][-1]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans < dp[0][j][1]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][1]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = dp[0][j][0]",
      "mutated_line": "ans = dp[0][j][1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][1]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = dp[0][j][0]",
      "mutated_line": "ans = dp[0][j][-1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][-1]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = dp[0][j][0]",
      "mutated_line": "ans = dp[0][j][1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][1]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(p_j, p_mod, path) = prev[0][j][0]",
      "mutated_line": "(p_j, p_mod, path) = prev[0][j][1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][1]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(p_j, p_mod, path) = prev[0][j][0]",
      "mutated_line": "(p_j, p_mod, path) = prev[0][j][-1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][-1]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(p_j, p_mod, path) = prev[0][j][0]",
      "mutated_line": "(p_j, p_mod, path) = prev[0][j][1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][1]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:2]",
      "mutated_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:3]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:3]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:2]",
      "mutated_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:1]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:2]",
      "mutated_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:0]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:2]",
      "mutated_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:1]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:1]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:2]",
      "mutated_line": "(p_j, p_mod) = prev[i][p_j][p_mod][:-2]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:-2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 1, path[::+1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::+1])"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[+1][i][board[-1][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[+1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-1][i] % k] = board[-2][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-2][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-1][i] % k] = board[-0][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-0][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-1][i] % k] = board[-0][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-0][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-1][i] % k] = board[--1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[--1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j + 1, j + 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j + 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j * 1, j + 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j * 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 1, j - 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j - 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 1, j * 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j * 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m or dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m or dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 1, path[::-2])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-2])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 1, path[::-0])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-0])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 1, path[::-0])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-0])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return ans, p_j + 1, path[::-1]",
      "mutated_line": "return (ans, p_j + 1, path[::--1])",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::--1])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(+1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(+1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, +1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, +1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, -1, '')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-2][i][board[-1][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-2][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-0][i][board[-1][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-0][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-0][i][board[-1][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-0][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[--1][i][board[-1][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[--1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[+1][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[+1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 2, j + 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 2, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 0, j + 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 0, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 0, j + 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 0, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - -1, j + 1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - -1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 1, j + 2):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 2):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 1, j + 0):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 0):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 1, j + 0):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 0):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for tj in (j - 1, j + 1):",
      "mutated_line": "for tj in (j - 1, j + -1):",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + -1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 < tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 < tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 > tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 > tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 == tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 == tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] <= val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] <= val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] >= val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] >= val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] != val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] != val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val - board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val - board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val * board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val * board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans < dp[1][j][0]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[1][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans < dp[-1][j][0]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[-1][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ans < dp[0][j][0]:",
      "mutated_line": "if ans < dp[1][j][0]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[1][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = dp[0][j][0]",
      "mutated_line": "ans = dp[1][j][0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[1][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = dp[0][j][0]",
      "mutated_line": "ans = dp[-1][j][0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[-1][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = dp[0][j][0]",
      "mutated_line": "ans = dp[1][j][0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[1][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(p_j, p_mod, path) = prev[0][j][0]",
      "mutated_line": "(p_j, p_mod, path) = prev[1][j][0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[1][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(p_j, p_mod, path) = prev[0][j][0]",
      "mutated_line": "(p_j, p_mod, path) = prev[-1][j][0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[-1][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(p_j, p_mod, path) = prev[0][j][0]",
      "mutated_line": "(p_j, p_mod, path) = prev[1][j][0]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[1][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-2, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-2, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-0, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-0, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-0, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-0, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(--1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(--1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, -2, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -2, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, -0, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -0, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, -0, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -0, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "mutated_line": "prev = [[[(-1, --1, '*')] * k for _ in range(m)] for _ in range(n)]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, --1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-2][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-2][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-0][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-0][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[-0][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-0][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp[-1][i][board[-1][i] % k] = board[-1][i]",
      "mutated_line": "dp[-1][i][board[--1][i] % k] = board[-1][i]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[--1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 1 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 1 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if -1 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if -1 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 1 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 1 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val - board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val - board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val * board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val * board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) * k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) * k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][mod + board[i - 1][tj] + k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][mod + board[i - 1][tj] + k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) * k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) * k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][mod + board[i - 1][tj] + k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][mod + board[i - 1][tj] + k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) * k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) * k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][mod + board[i - 1][tj] + k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][mod + board[i - 1][tj] + k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod - board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod - board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][mod * board[i - 1][tj] % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][mod * board[i - 1][tj] % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod - board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod - board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][mod * board[i - 1][tj] % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][mod * board[i - 1][tj] % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj <= j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj <= j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj >= j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj >= j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj != j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj != j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, '' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, '' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else '')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else '')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod - board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod - board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][mod * board[i - 1][tj] % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][mod * board[i - 1][tj] % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i + 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i + 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i * 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i * 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i + 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i + 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i * 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i * 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i + 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i + 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i * 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i * 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i + 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i + 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i * 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i * 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i + 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i + 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i * 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i * 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 2][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 2][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 0][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 0][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 0][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 0][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - -1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - -1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 2][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 2][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 0][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 0][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 0][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 0][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - -1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - -1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 2][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 2][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 0][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 0][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 0][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 0][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - -1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - -1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 2][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 2][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 0][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 0][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 0][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 0][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - -1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - -1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 2][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 2][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 0][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 0][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 0][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 0][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - -1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - -1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i + 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i + 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i * 1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i * 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i + 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i + 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i * 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i * 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i + 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i + 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i * 1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i * 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 2][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 2][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 0][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 0][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - 0][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 0][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]",
      "mutated_line": "dp[i - 1][tj][(mod + board[i - -1][tj]) % k] = val + board[i - 1][tj]",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - -1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 2][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 2][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 0][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 0][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - 0][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 0][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "mutated_line": "prev[i - 1][tj][(mod + board[i - -1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - -1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 2][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 2][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 0][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 0][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 0][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 0][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - 1][tj]) % k] < val + board[i - 1][tj]:",
      "mutated_line": "if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - -1][tj]) % k] < val + board[i - 1][tj]:",
      "code": "def find_max_peas_and_path(n, m, k, board):\n    k += 1\n    empty = -1\n    dp = [[[empty] * k for _ in range(m)] for _ in range(n)]\n    prev = [[[(-1, -1, '*')] * k for _ in range(m)] for _ in range(n)]\n    for i in range(m):\n        dp[-1][i][board[-1][i] % k] = board[-1][i]\n    for i in range(n - 1, 0, -1):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] == empty:\n                    continue\n                val = dp[i][j][mod]\n                for tj in (j - 1, j + 1):\n                    if 0 <= tj < m and dp[i - 1][tj][(mod + board[i - -1][tj]) % k] < val + board[i - 1][tj]:\n                        dp[i - 1][tj][(mod + board[i - 1][tj]) % k] = val + board[i - 1][tj]\n                        prev[i - 1][tj][(mod + board[i - 1][tj]) % k] = (j, mod, 'L' if tj < j else 'R')\n    (ans, p_j, p_mod, path) = (empty, 0, 0, '')\n    for j in range(m):\n        if ans < dp[0][j][0]:\n            ans = dp[0][j][0]\n            (p_j, p_mod, path) = prev[0][j][0]\n    if ans == empty:\n        return -1\n    for i in range(1, n - 1):\n        path += prev[i][p_j][p_mod][2]\n        (p_j, p_mod) = prev[i][p_j][p_mod][:2]\n    return (ans, p_j + 1, path[::-1])"
    }
  ]
}