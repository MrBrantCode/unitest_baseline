{
  "task_id": "taco_815",
  "entry_point": "calculate_minimum_cost",
  "mutant_count": 141,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if sum(initial_digits) != sum(target_digits):",
      "mutated_line": "if sum(initial_digits) == sum(target_digits):",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) == sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n != 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [-1] / n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] / n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [-1] + n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] + n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [-1] ** n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] ** n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "Depth = [0] * n",
      "mutated_line": "Depth = [0] / n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] / n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "Depth = [0] * n",
      "mutated_line": "Depth = [0] + n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] + n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "Depth = [0] * n",
      "mutated_line": "Depth = [0] ** n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] ** n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ToOne = [0] * n",
      "mutated_line": "ToOne = [0] / n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] / n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ToOne = [0] * n",
      "mutated_line": "ToOne = [0] + n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] + n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ToOne = [0] * n",
      "mutated_line": "ToOne = [0] ** n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] ** n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ToZero = [0] * n",
      "mutated_line": "ToZero = [0] / n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] / n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ToZero = [0] * n",
      "mutated_line": "ToZero = [0] + n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] + n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ToZero = [0] * n",
      "mutated_line": "ToZero = [0] ** n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] ** n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 1\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = -1\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 1\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return +1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 2:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 0:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 0:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == -1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 1\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return -1\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 1\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(1)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(-1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(-1)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(1)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans -= change * cost * 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans -= change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "ToOne[par] -= change",
      "mutated_line": "ToOne[par] += change",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] += change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 56,
      "original_line": "ToZero[par] -= change",
      "mutated_line": "ToZero[par] += change",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] += change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -2\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -0\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -0\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return --1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 1].append(v + 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v + 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 1].append(v * 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v * 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 1].append(u + 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u + 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 1].append(u * 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u * 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [+1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [+1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "Depth = [0] * n",
      "mutated_line": "Depth = [1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [1] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "Depth = [0] * n",
      "mutated_line": "Depth = [-1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [-1] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "Depth = [0] * n",
      "mutated_line": "Depth = [1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [1] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if to == Par[fr]:",
      "mutated_line": "if to != Par[fr]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to != Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Depth[to] = Depth[fr] + 1",
      "mutated_line": "Depth[to] = Depth[fr] - 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] - 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Depth[to] = Depth[fr] + 1",
      "mutated_line": "Depth[to] = Depth[fr] * 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] * 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ToOne = [0] * n",
      "mutated_line": "ToOne = [1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [1] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ToOne = [0] * n",
      "mutated_line": "ToOne = [-1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [-1] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ToOne = [0] * n",
      "mutated_line": "ToOne = [1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [1] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ToZero = [0] * n",
      "mutated_line": "ToZero = [1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [1] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ToZero = [0] * n",
      "mutated_line": "ToZero = [-1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [-1] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ToZero = [0] * n",
      "mutated_line": "ToZero = [1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [1] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d - 1)[::-1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d - 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d * 1)[::-1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d * 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 1)[::+1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::+1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 0 or b == 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 or b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "ToOne[par] += 1",
      "mutated_line": "ToOne[par] -= 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] -= 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "ToOne[par] += ToOne[chi]",
      "mutated_line": "ToOne[par] -= ToOne[chi]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] -= ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "ToZero[par] += ToZero[chi]",
      "mutated_line": "ToZero[par] -= ToZero[chi]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] -= ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change * cost / 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost / 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change * cost + 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost + 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += (change * cost) ** 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += (change * cost) ** 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 1].append(v - 2)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 2)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 1].append(v - 0)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 0)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 1].append(v - 0)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 0)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 1].append(v - -1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - -1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 1].append(u - 2)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 2)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 1].append(u - 0)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 0)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 1].append(u - 0)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 0)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 1].append(u - -1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - -1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [-2] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-2] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [-0] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-0] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [-0] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-0] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "Par = [-1] * n",
      "mutated_line": "Par = [--1] * n",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [--1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Depth[to] = Depth[fr] + 1",
      "mutated_line": "Depth[to] = Depth[fr] + 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 2\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Depth[to] = Depth[fr] + 1",
      "mutated_line": "Depth[to] = Depth[fr] + 0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 0\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Depth[to] = Depth[fr] + 1",
      "mutated_line": "Depth[to] = Depth[fr] + 0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 0\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "Depth[to] = Depth[fr] + 1",
      "mutated_line": "Depth[to] = Depth[fr] + -1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + -1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [[] for _ in range(d + 1)]",
      "mutated_line": "D = [[] for _ in range(d - 1)]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d - 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [[] for _ in range(d + 1)]",
      "mutated_line": "D = [[] for _ in range(d * 1)]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d * 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 2)[::-1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 2)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 0)[::-1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 0)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 0)[::-1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 0)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + -1)[::-1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + -1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 1)[::-2]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-2]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 1)[::-0]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-0]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 1)[::-0]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-0]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(d + 1)[::-1]:",
      "mutated_line": "for i in range(d + 1)[::--1]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::--1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a != 0 and b == 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a != 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 0 and b != 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b != 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ToOne[par] += 1",
      "mutated_line": "ToOne[par] += 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 2\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ToOne[par] += 1",
      "mutated_line": "ToOne[par] += 0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 0\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ToOne[par] += 1",
      "mutated_line": "ToOne[par] += 0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 0\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ToOne[par] += 1",
      "mutated_line": "ToOne[par] += -1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += -1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 1 or b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 or b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "ToZero[par] += 1",
      "mutated_line": "ToZero[par] -= 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] -= 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if chi == Par[par]:",
      "mutated_line": "if chi != Par[par]:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi != Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change / cost * 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change / cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += (change + cost) * 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += (change + cost) * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change ** cost * 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change ** cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change * cost * 3",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 3\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change * cost * 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 1\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change * cost * 0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 0\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change * cost * 1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 1\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans += change * cost * 2",
      "mutated_line": "ans += change * cost * -2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * -2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u + 1].append(v - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u + 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u * 1].append(v - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u * 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v + 1].append(u - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v + 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v * 1].append(u - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v * 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [[] for _ in range(d + 1)]",
      "mutated_line": "D = [[] for _ in range(d + 2)]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 2)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [[] for _ in range(d + 1)]",
      "mutated_line": "D = [[] for _ in range(d + 0)]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 0)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [[] for _ in range(d + 1)]",
      "mutated_line": "D = [[] for _ in range(d + 0)]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 0)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [[] for _ in range(d + 1)]",
      "mutated_line": "D = [[] for _ in range(d + -1)]",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + -1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 1 and b == 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 1 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == -1 and b == 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == -1 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 1 and b == 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 1 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 0 and b == 2:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 2:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 0 and b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 0:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 0 and b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 0:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if a == 0 and b == 1:",
      "mutated_line": "if a == 0 and b == -1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == -1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a != 1 and b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a != 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 1 and b != 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b != 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ToZero[par] += 1",
      "mutated_line": "ToZero[par] += 2",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 2\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ToZero[par] += 1",
      "mutated_line": "ToZero[par] += 0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 0\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ToZero[par] += 1",
      "mutated_line": "ToZero[par] += 0",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 0\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ToZero[par] += 1",
      "mutated_line": "ToZero[par] += -1",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += -1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 2].append(v - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 2].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 0].append(v - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 0].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - 0].append(v - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 0].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Edges[u - 1].append(v - 1)",
      "mutated_line": "Edges[u - -1].append(v - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - -1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 2].append(u - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 2].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 0].append(u - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 0].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - 0].append(u - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 0].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Edges[v - 1].append(u - 1)",
      "mutated_line": "Edges[v - -1].append(u - 1)",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - -1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 2 and b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 2 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 0 and b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 0 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 0 and b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 0 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == -1 and b == 0:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == -1 and b == 0:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 1 and b == 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 1:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 1 and b == -1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == -1:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a == 1 and b == 0:",
      "mutated_line": "elif a == 1 and b == 1:",
      "code": "def calculate_minimum_cost(n, costs, initial_digits, target_digits, edges):\n    if sum(initial_digits) != sum(target_digits):\n        return -1\n    if n == 1:\n        return 0\n    Edges = [[] for _ in range(n)]\n    for (u, v) in edges:\n        Edges[u - 1].append(v - 1)\n        Edges[v - 1].append(u - 1)\n    Chi = [[] for _ in range(n)]\n    Par = [-1] * n\n    Depth = [0] * n\n    q = deque()\n    q.append(0)\n    while q:\n        fr = q.popleft()\n        for to in Edges[fr]:\n            if to == Par[fr]:\n                continue\n            Chi[fr].append(to)\n            Par[to] = fr\n            costs[to] = min(costs[to], costs[fr])\n            Depth[to] = Depth[fr] + 1\n            q.append(to)\n    d = max(Depth)\n    D = [[] for _ in range(d + 1)]\n    for i in range(n):\n        depth = Depth[i]\n        D[depth].append(i)\n    ToOne = [0] * n\n    ToZero = [0] * n\n    ans = 0\n    for i in range(d + 1)[::-1]:\n        for par in D[i]:\n            (a, b, cost) = (initial_digits[par], target_digits[par], costs[par])\n            if a == 0 and b == 1:\n                ToOne[par] += 1\n            elif a == 1 and b == 1:\n                ToZero[par] += 1\n            for chi in Edges[par]:\n                if chi == Par[par]:\n                    continue\n                ToOne[par] += ToOne[chi]\n                ToZero[par] += ToZero[chi]\n            change = min(ToOne[par], ToZero[par])\n            ans += change * cost * 2\n            ToOne[par] -= change\n            ToZero[par] -= change\n    return ans"
    }
  ]
}