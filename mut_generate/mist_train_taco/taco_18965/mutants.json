{
  "task_id": "taco_18965",
  "entry_point": "min_coprocessor_calls",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "total = -1",
      "mutated_line": "total = +1",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = +1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(done) < n:",
      "mutated_line": "while len(done) <= n:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) <= n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(done) < n:",
      "mutated_line": "while len(done) >= n:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) >= n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(done) < n:",
      "mutated_line": "while len(done) != n:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) != n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "total += 1",
      "mutated_line": "total -= 1",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total -= 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if a in root:",
      "mutated_line": "if a not in root:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a not in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "total = -1",
      "mutated_line": "total = -2",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -2\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "total = -1",
      "mutated_line": "total = -0",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -0\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "total = -1",
      "mutated_line": "total = -0",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -0\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "total = -1",
      "mutated_line": "total = --1",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = --1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "total += 1",
      "mutated_line": "total += 2",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 2\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "total += 1",
      "mutated_line": "total += 0",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 0\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "total += 1",
      "mutated_line": "total += 0",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 0\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "total += 1",
      "mutated_line": "total += -1",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += -1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if e[nxt] == 0:",
      "mutated_line": "if e[nxt] != 0:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] != 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if e[nxt] == 1:",
      "mutated_line": "if e[nxt] != 1:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] != 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if e[nxt] == 0:",
      "mutated_line": "if e[nxt] == 1:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 1:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if e[nxt] == 0:",
      "mutated_line": "if e[nxt] == -1:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == -1:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if e[nxt] == 0:",
      "mutated_line": "if e[nxt] == 1:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 1:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if e[nxt] == 1:",
      "mutated_line": "if e[nxt] == 2:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 2:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if e[nxt] == 1:",
      "mutated_line": "if e[nxt] == 0:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 0:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if e[nxt] == 1:",
      "mutated_line": "if e[nxt] == 0:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == 0:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if e[nxt] == 1:",
      "mutated_line": "if e[nxt] == -1:",
      "code": "from collections import deque\n\ndef min_coprocessor_calls(n, m, e, dependencies):\n    graph = [set() for _ in range(n)]\n    reverse = [set() for _ in range(n)]\n    root = set(range(n))\n    for (a, b) in dependencies:\n        graph[b].add(a)\n        reverse[a].add(b)\n        if a in root:\n            root.remove(a)\n    done = set()\n    qMain = deque(list(root))\n    qCo = deque()\n    total = -1\n    while len(done) < n:\n        total += 1\n        while qCo:\n            nxt = qCo.popleft()\n            if e[nxt] == 0:\n                qMain.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qCo.append(x)\n        while qMain:\n            nxt = qMain.popleft()\n            if e[nxt] == -1:\n                qCo.append(nxt)\n            else:\n                done.add(nxt)\n                for x in graph[nxt]:\n                    reverse[x].remove(nxt)\n                    if not reverse[x]:\n                        qMain.append(x)\n    return total"
    }
  ]
}