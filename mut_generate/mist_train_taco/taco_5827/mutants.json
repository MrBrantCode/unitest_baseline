{
  "task_id": "taco_5827",
  "entry_point": "find_min_distances",
  "mutant_count": 165,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "le = -1",
      "mutated_line": "le = +1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = +1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "nd = [-1 for _ in range(len(sequence))]",
      "mutated_line": "nd = [+1 for _ in range(len(sequence))]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [+1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if sequence[i] in vi:",
      "mutated_line": "if sequence[i] not in vi:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] not in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(2 * 19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 * 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(2 + 19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 + 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "le = -1",
      "mutated_line": "le = -2",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -2\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "le = -1",
      "mutated_line": "le = -0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -0\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "le = -1",
      "mutated_line": "le = -0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -0\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "le = -1",
      "mutated_line": "le = --1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = --1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if nd[r] != -1:",
      "mutated_line": "if nd[r] == -1:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] == -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 10 * 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 * 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 10 + 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 + 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < self.n:",
      "mutated_line": "while i <= self.n:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i <= self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < self.n:",
      "mutated_line": "while i >= self.n:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i >= self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < self.n:",
      "mutated_line": "while i != self.n:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i != self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 10 * 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 * 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 10 + 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 + 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while r >= 0:",
      "mutated_line": "while r > 0:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r > 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while r >= 0:",
      "mutated_line": "while r < 0:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r < 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while r >= 0:",
      "mutated_line": "while r == 0:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r == 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nd = [-1 for _ in range(len(sequence))]",
      "mutated_line": "nd = [-2 for _ in range(len(sequence))]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-2 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nd = [-1 for _ in range(len(sequence))]",
      "mutated_line": "nd = [-0 for _ in range(len(sequence))]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-0 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nd = [-1 for _ in range(len(sequence))]",
      "mutated_line": "nd = [-0 for _ in range(len(sequence))]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-0 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nd = [-1 for _ in range(len(sequence))]",
      "mutated_line": "nd = [--1 for _ in range(len(sequence))]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [--1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(3 ** 19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(3 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(1 ** 19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(1 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(0 ** 19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(0 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(1 ** 19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(1 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(-2 ** 19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(-2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(2 ** 20)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 20)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(2 ** 18)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 18)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(2 ** 0)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 0)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(2 ** 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 1)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "der = Fenwick(2 ** 19)",
      "mutated_line": "der = Fenwick(2 ** -19)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** -19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "if nd[r] != -1:",
      "mutated_line": "if nd[r] != +1:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != +1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if l > le:",
      "mutated_line": "if l >= le:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l >= le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if l > le:",
      "mutated_line": "if l <= le:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l <= le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if l > le:",
      "mutated_line": "if l != le:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l != le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn != 10 ** 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn != 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [10 * 9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 * 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [10 + 9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 + 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 11 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 11 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 9 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 9 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 0 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 0 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 1 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 1 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = -10 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = -10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 10 ** 10",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 10\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 10 ** 8",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 8\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 10 ** 0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 0\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 10 ** 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 1\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.w = 10 ** 9",
      "mutated_line": "self.w = 10 ** -9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** -9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i & i + 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i & i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i ^ i + 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i ^ i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 11 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 11 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 9 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 9 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 0 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 0 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 1 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 1 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = -10 ** 9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = -10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 10 ** 10",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 10\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 10 ** 8",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 8\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 10 ** 0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 0\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 10 ** 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 1\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = 10 ** 9",
      "mutated_line": "ans = 10 ** -9",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** -9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while r >= 0:",
      "mutated_line": "while r >= 1:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 1:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while r >= 0:",
      "mutated_line": "while r >= -1:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= -1:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while r >= 0:",
      "mutated_line": "while r >= 1:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 1:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ans > self.a[r]:",
      "mutated_line": "if ans >= self.a[r]:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans >= self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ans > self.a[r]:",
      "mutated_line": "if ans <= self.a[r]:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans <= self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ans > self.a[r]:",
      "mutated_line": "if ans != self.a[r]:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans != self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if ans == self.w:",
      "mutated_line": "if ans != self.w:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans != self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 1) + 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) + 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 1) * 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) * 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 1].append((l + 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l + 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 1].append((l * 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l * 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if nd[r] != -1:",
      "mutated_line": "if nd[r] != -2:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -2:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if nd[r] != -1:",
      "mutated_line": "if nd[r] != -0:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -0:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if nd[r] != -1:",
      "mutated_line": "if nd[r] != -0:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -0:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if nd[r] != -1:",
      "mutated_line": "if nd[r] != --1:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != --1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 - nd[r] - 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] - 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag((500000 - nd[r]) * 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag((500000 - nd[r]) * 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 - nd[r] + 1, r + nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r + nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 - nd[r] + 1, r * nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r * nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "ans[ind] = -1",
      "mutated_line": "ans[ind] = +1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = +1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500000 - l - 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l - 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol((500000 - l) * 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol((500000 - l) * 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 10 * 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 * 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 10 + 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 + 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "zn = -1",
      "mutated_line": "zn = +1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = +1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [11 ** 9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [11 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [9 ** 9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [9 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [0 ** 9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [0 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [1 ** 9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [1 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [-10 ** 9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [-10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [10 ** 10 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 10 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [10 ** 8 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 8 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [10 ** 0 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 0 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [10 ** 1 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 1 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [10 ** 9 for _ in range(n)]",
      "mutated_line": "self.a = [10 ** -9 for _ in range(n)]",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** -9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i | i - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i - 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i | i * 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i * 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r | r + 1) - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r | r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 1) - 2",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 2\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 1) - 0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 0\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 1) - 0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 0\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 1) - -1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - -1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r + 1].append((l - 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r + 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r * 1].append((l - 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r * 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 1].append((l - 2, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 2, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 1].append((l - 0, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 0, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 1].append((l - 0, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 0, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 1].append((l - -1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - -1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 + nd[r] + 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 + nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 * nd[r] + 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 * nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 - nd[r] + 2, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 2, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 - nd[r] + 0, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 0, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 - nd[r] + 0, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 0, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500000 - nd[r] + -1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + -1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans[ind] = -1",
      "mutated_line": "ans[ind] = -2",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -2\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans[ind] = -1",
      "mutated_line": "ans[ind] = -0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -0\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans[ind] = -1",
      "mutated_line": "ans[ind] = -0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -0\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans[ind] = -1",
      "mutated_line": "ans[ind] = --1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = --1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500000 + l + 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 + l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500000 * l + 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 * l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500000 - l + 2)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 2)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500000 - l + 0)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 0)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500000 - l + 0)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 0)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500000 - l + -1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + -1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 11 ** 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 11 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 9 ** 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 9 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 0 ** 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 0 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 1 ** 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 1 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == -10 ** 9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == -10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 10 ** 10:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 10:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 10 ** 8:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 8:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 10 ** 0:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 0:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 10 ** 1:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 1:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if zn == 10 ** 9:",
      "mutated_line": "if zn == 10 ** -9:",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** -9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "zn = -1",
      "mutated_line": "zn = -2",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -2\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "zn = -1",
      "mutated_line": "zn = -0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -0\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "zn = -1",
      "mutated_line": "zn = -0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -0\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "zn = -1",
      "mutated_line": "zn = --1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = --1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i | i + 2",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 2\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i | i + 0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 0\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i | i + 0",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 0\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = i | i + 1",
      "mutated_line": "i = i | i + -1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + -1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r - 1) - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r - 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r * 1) - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r * 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 2].append((l - 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 2].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 0].append((l - 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 0].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - 0].append((l - 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 0].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "och[r - 1].append((l - 1, i))",
      "mutated_line": "och[r - -1].append((l - 1, i))",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - -1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(500001 - nd[r] + 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500001 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(499999 - nd[r] + 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(499999 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(0 - nd[r] + 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(0 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(1 - nd[r] + 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(1 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "der.zag(500000 - nd[r] + 1, r - nd[r])",
      "mutated_line": "der.zag(-500000 - nd[r] + 1, r - nd[r])",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(-500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(500001 - l + 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500001 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(499999 - l + 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(499999 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(0 - l + 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(0 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(1 - l + 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(1 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "zn = der.pol(500000 - l + 1)",
      "mutated_line": "zn = der.pol(-500000 - l + 1)",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(-500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 2) - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 2) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 0) - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 0) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + 0) - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + 0) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = (r & r + 1) - 1",
      "mutated_line": "r = (r & r + -1) - 1",
      "code": "def find_min_distances(n, m, sequence, queries):\n\n    class Fenwick:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [10 ** 9 for _ in range(n)]\n            self.w = 10 ** 9\n\n        def zag(self, i, zn):\n            self.w = min(self.w, zn)\n            while i < self.n:\n                self.a[i] = min(self.a[i], zn)\n                i = i | i + 1\n\n        def pol(self, r):\n            ans = 10 ** 9\n            while r >= 0:\n                if ans > self.a[r]:\n                    ans = self.a[r]\n                if ans == self.w:\n                    break\n                r = (r & r + -1) - 1\n            return ans\n    nd = [-1 for _ in range(len(sequence))]\n    vi = {}\n    for i in range(len(sequence)):\n        if sequence[i] in vi:\n            nd[i] = vi[sequence[i]]\n        vi[sequence[i]] = i\n    och = [[] for _ in range(n)]\n    for i in range(m):\n        (l, r) = queries[i]\n        och[r - 1].append((l - 1, i))\n    der = Fenwick(2 ** 19)\n    ans = [None for _ in range(m)]\n    le = -1\n    for r in range(n):\n        if nd[r] != -1:\n            der.zag(500000 - nd[r] + 1, r - nd[r])\n            le = max(le, nd[r])\n        for (l, ind) in och[r]:\n            if l > le:\n                ans[ind] = -1\n                continue\n            zn = der.pol(500000 - l + 1)\n            if zn == 10 ** 9:\n                zn = -1\n            ans[ind] = zn\n    return ans"
    }
  ]
}