{
  "task_id": "taco_5515",
  "entry_point": "minimum_cost_to_connect_forest",
  "mutant_count": 120,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 1\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = -1\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 1\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "res += v[0]",
      "mutated_line": "res -= v[0]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res -= v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N <= 2 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N <= 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N >= 2 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N >= 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N != 2 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N != 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][0] != -1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] != -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][1] != tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] != tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][1] -= 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] -= 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if find(x) != find(y):",
      "mutated_line": "if find(x) == find(y):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) == find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 / (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 / (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 + (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 + (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 ** (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 ** (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 'Impossible'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return ''\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif M == N - 1:",
      "mutated_line": "elif M != N - 1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M != N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res -= sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res -= sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[+1, 1] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[+1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[-1, 2] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 2] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[-1, 0] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 0] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[-1, 0] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 0] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[-1, -1] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, -1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][0] == +1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == +1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][1] += 2",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 2\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][1] += 0",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 0\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][1] += 0",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 0\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][1] += -1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += -1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][1] <= tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] <= tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][1] >= tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] >= tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][1] != tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] != tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res += v[0]",
      "mutated_line": "res += v[1]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[1]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res += v[0]",
      "mutated_line": "res += v[-1]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[-1]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res += v[0]",
      "mutated_line": "res += v[1]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[1]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 3 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 3 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 1 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 1 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 0 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 0 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 1 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 1 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < -2 * (N - M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < -2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * (N - M + 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M + 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * ((N - M) * 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * ((N - M) * 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "elif M == N - 1:",
      "mutated_line": "elif M == N + 1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N + 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "elif M == N - 1:",
      "mutated_line": "elif M == N * 1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N * 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 1\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return -1\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 1\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[-2, 1] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-2, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[-0, 1] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-0, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[-0, 1] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-0, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tree = [[-1, 1] for _ in range(N)]",
      "mutated_line": "tree = [[--1, 1] for _ in range(N)]",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[--1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][1] == -1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][1] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][-1] == -1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][-1] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][1] == -1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][1] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][0] == -2:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -2:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][0] == -0:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -0:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][0] == -0:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -0:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if tree[i][0] == -1:",
      "mutated_line": "if tree[i][0] == --1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == --1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i][0] = group",
      "mutated_line": "tree[i][1] = group",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][1] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i][0] = group",
      "mutated_line": "tree[i][-1] = group",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][-1] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i][0] = group",
      "mutated_line": "tree[i][1] = group",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][1] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][2] == tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][2] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][0] == tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][0] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][0] == tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][0] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][-1] == tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][-1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][1] == tree[py][2]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][2]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][1] == tree[py][0]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][0]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][1] == tree[py][0]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][0]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if tree[px][1] == tree[py][1]:",
      "mutated_line": "if tree[px][1] == tree[py][-1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][-1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tree[py][0] = px",
      "mutated_line": "tree[py][1] = px",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][1] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tree[py][0] = px",
      "mutated_line": "tree[py][-1] = px",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][-1] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tree[py][0] = px",
      "mutated_line": "tree[py][1] = px",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][1] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][2] += 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][2] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][0] += 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][0] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][0] += 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][0] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "tree[px][1] += 1",
      "mutated_line": "tree[px][-1] += 1",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][-1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "tree[py][0] = px",
      "mutated_line": "tree[py][1] = px",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][1] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "tree[py][0] = px",
      "mutated_line": "tree[py][-1] = px",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][-1] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "tree[py][0] = px",
      "mutated_line": "tree[py][1] = px",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][1] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * (N + M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N + M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * (N * M - 1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N * M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * (N - M - 2):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 2):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * (N - M - 0):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 0):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * (N - M - 0):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 0):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if N < 2 * (N - M - 1):",
      "mutated_line": "if N < 2 * (N - M - -1):",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - -1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif M == N - 1:",
      "mutated_line": "elif M == N - 2:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 2:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif M == N - 1:",
      "mutated_line": "elif M == N - 0:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 0:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif M == N - 1:",
      "mutated_line": "elif M == N - 0:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 0:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif M == N - 1:",
      "mutated_line": "elif M == N - -1:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - -1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "group = find(tree[i][0])",
      "mutated_line": "group = find(tree[i][1])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][1])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "group = find(tree[i][0])",
      "mutated_line": "group = find(tree[i][-1])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][-1])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "group = find(tree[i][0])",
      "mutated_line": "group = find(tree[i][1])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][1])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][2] < tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][2] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][0] < tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][0] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][0] < tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][0] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][-1] < tree[py][1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][-1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][1] < tree[py][2]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][2]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][1] < tree[py][0]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][0]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][1] < tree[py][0]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][0]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if tree[px][1] < tree[py][1]:",
      "mutated_line": "if tree[px][1] < tree[py][-1]:",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][-1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H.append(v[1:])",
      "mutated_line": "H.append(v[2:])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[2:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H.append(v[1:])",
      "mutated_line": "H.append(v[0:])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[0:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H.append(v[1:])",
      "mutated_line": "H.append(v[0:])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[0:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H.append(v[1:])",
      "mutated_line": "H.append(v[-1:])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[-1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) + len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) + len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) * len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 1) * len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 / (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 / (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 + (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 + (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 ** (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 ** (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:3 * (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:3 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:1 * (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:1 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:0 * (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:0 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:1 * (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:1 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:-2 * (N - M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:-2 * (N - M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N - M + 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M + 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * ((N - M) * 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * ((N - M) * 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N + M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N + M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N * M - 1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N * M - 1) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N - M - 2) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 2) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N - M - 0) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 0) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N - M - 0) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - 0) - len(D.keys())])\n        return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res += sum(list(merge(*H))[:2 * (N - M - 1) - len(D.keys())])",
      "mutated_line": "res += sum(list(merge(*H))[:2 * (N - M - -1) - len(D.keys())])",
      "code": "from collections import defaultdict\nfrom heapq import merge\n\ndef minimum_cost_to_connect_forest(N, M, A, edges):\n    tree = [[-1, 1] for _ in range(N)]\n\n    def find(i):\n        if tree[i][0] == -1:\n            group = i\n        else:\n            group = find(tree[i][0])\n            tree[i][0] = group\n        return group\n\n    def unite(x, y):\n        px = find(x)\n        py = find(y)\n        if tree[px][1] == tree[py][1]:\n            tree[py][0] = px\n            tree[px][1] += 1\n        else:\n            if tree[px][1] < tree[py][1]:\n                (px, py) = (py, px)\n            tree[py][0] = px\n    for (x, y) in edges:\n        if find(x) != find(y):\n            unite(x, y)\n    D = defaultdict(list)\n    for n in range(N):\n        D[find(n)].append(A[n])\n    H = []\n    res = 0\n    for (k, v) in D.items():\n        v = sorted(v)\n        res += v[0]\n        H.append(v[1:])\n    if N < 2 * (N - M - 1):\n        return 'Impossible'\n    elif M == N - 1:\n        return 0\n    else:\n        res += sum(list(merge(*H))[:2 * (N - M - -1) - len(D.keys())])\n        return res"
    }
  ]
}