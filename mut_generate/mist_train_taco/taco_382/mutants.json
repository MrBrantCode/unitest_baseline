{
  "task_id": "taco_382",
  "entry_point": "min_time_to_cross_road",
  "mutant_count": 251,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[0][0] = 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 1\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[0][0] = -1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = -1\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[0][0] = 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 1\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 * 18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 * 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 + 18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 + 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[-1] / g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] / g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[-1] + g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] + g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[-1] ** g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] ** g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[0][1] = 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][1] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[0][-1] = 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][-1] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[0][1] = 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][1] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if v != m - 1:",
      "mutated_line": "if v == m - 1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v == m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if v != 0:",
      "mutated_line": "if v == 0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v == 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 11 ** 18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 11 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 9 ** 18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 9 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 0 ** 18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 0 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 1 ** 18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 1 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = -10 ** 18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = -10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 19",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 19\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 17",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 17\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 0\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 1\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** -18",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** -18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans != 10 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans != 10 ** 18 else ans"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return +1 if ans == 10 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return +1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((1, 0, 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((1, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((-1, 0, 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((-1, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((1, 0, 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((1, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((0, 1, 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 1, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((0, -1, 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, -1, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((0, 1, 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 1, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((0, 0, 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 1))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((0, 0, -1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, -1))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((0, 0, 0))",
      "mutated_line": "q.append((0, 0, 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 1))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[1][0] = 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[1][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[-1][0] = 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[-1][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "checked[0][0] = 0",
      "mutated_line": "checked[1][0] = 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[1][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if v != m - 1:",
      "mutated_line": "if v != m + 1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m + 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if v != m - 1:",
      "mutated_line": "if v != m * 1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m * 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v + 1] + safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] + safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v + 1] * safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] * safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t + cost1 <= g:",
      "mutated_line": "if t + cost1 < g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 < g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t + cost1 <= g:",
      "mutated_line": "if t + cost1 > g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 > g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t + cost1 <= g:",
      "mutated_line": "if t + cost1 == g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 == g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v != 0:",
      "mutated_line": "if v != 1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 1:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v != 0:",
      "mutated_line": "if v != -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != -1:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if v != 0:",
      "mutated_line": "if v != 1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 1:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] + safety_islands[v - 1]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] + safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] * safety_islands[v - 1]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] * safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if t + cost2 <= g:",
      "mutated_line": "if t + cost2 < g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 < g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if t + cost2 <= g:",
      "mutated_line": "if t + cost2 > g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 > g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if t + cost2 <= g:",
      "mutated_line": "if t + cost2 == g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 == g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if checked[i][j] == -1:",
      "mutated_line": "if checked[i][j] != -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] != -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 10 * 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 * 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 10 + 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 + 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -2 if ans == 10 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -2 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -0 if ans == 10 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -0 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -0 if ans == 10 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -0 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return --1 if ans == 10 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return --1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[+1] * g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[+1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v != m - 1:",
      "mutated_line": "if v != m - 2:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 2:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v != m - 1:",
      "mutated_line": "if v != m - 0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 0:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v != m - 1:",
      "mutated_line": "if v != m - 0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 0:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v != m - 1:",
      "mutated_line": "if v != m - -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - -1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if t + cost1 <= g:",
      "mutated_line": "if t - cost1 <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t - cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if t + cost1 <= g:",
      "mutated_line": "if t * cost1 <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t * cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost1) % g] != -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] != -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if t + cost2 <= g:",
      "mutated_line": "if t - cost2 <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t - cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if t + cost2 <= g:",
      "mutated_line": "if t * cost2 <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t * cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost2) % g] != -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] != -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "if checked[i][j] == -1:",
      "mutated_line": "if checked[i][j] == +1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == +1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif j + n - safety_islands[i] <= g:",
      "mutated_line": "elif j + n - safety_islands[i] < g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] < g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif j + n - safety_islands[i] <= g:",
      "mutated_line": "elif j + n - safety_islands[i] > g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] > g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif j + n - safety_islands[i] <= g:",
      "mutated_line": "elif j + n - safety_islands[i] == g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] == g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 11 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 11 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 9 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 9 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 0 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 0 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 1 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 1 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == -10 ** 18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == -10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 10 ** 19 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 19 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 10 ** 17 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 17 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 10 ** 0 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 0 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 10 ** 1 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 1 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1 if ans == 10 ** 18 else ans",
      "mutated_line": "return -1 if ans == 10 ** -18 else ans",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** -18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[-2] * g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-2] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[-0] * g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-0] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[-0] * g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-0] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "checked = [[-1] * g for _ in range(m)]",
      "mutated_line": "checked = [[--1] * g for _ in range(m)]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[--1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v - 1] - safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v - 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v * 1] - safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v * 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost1) % g] == +1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == +1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if t + cost1 < g:",
      "mutated_line": "if t + cost1 <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 <= g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if t + cost1 < g:",
      "mutated_line": "if t + cost1 >= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 >= g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if t + cost1 < g:",
      "mutated_line": "if t + cost1 != g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 != g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] - safety_islands[v + 1]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v + 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] - safety_islands[v * 1]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v * 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost2) % g] == +1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == +1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t + cost2 < g:",
      "mutated_line": "if t + cost2 <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 <= g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t + cost2 < g:",
      "mutated_line": "if t + cost2 >= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 >= g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t + cost2 < g:",
      "mutated_line": "if t + cost2 != g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 != g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if checked[i][j] == -1:",
      "mutated_line": "if checked[i][j] == -2:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -2:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if checked[i][j] == -1:",
      "mutated_line": "if checked[i][j] == -0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -0:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if checked[i][j] == -1:",
      "mutated_line": "if checked[i][j] == -0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -0:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if checked[i][j] == -1:",
      "mutated_line": "if checked[i][j] == --1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == --1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "elif j + n - safety_islands[i] <= g:",
      "mutated_line": "elif j + n + safety_islands[i] <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n + safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "elif j + n - safety_islands[i] <= g:",
      "mutated_line": "elif (j + n) * safety_islands[i] <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif (j + n) * safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v + 2] - safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 2] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v + 0] - safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 0] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v + 0] - safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 0] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cost1 = safety_islands[v + 1] - safety_islands[v]",
      "mutated_line": "cost1 = safety_islands[v + -1] - safety_islands[v]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + -1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost1) * g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) * g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][t + cost1 + g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][t + cost1 + g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost1) % g] == -2:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -2:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost1) % g] == -0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -0:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost1) % g] == -0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -0:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost1) % g] == --1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == --1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if t + cost1 < g:",
      "mutated_line": "if t - cost1 < g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t - cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if t + cost1 < g:",
      "mutated_line": "if t * cost1 < g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t * cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][0] = cnt - 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt - 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][0] = cnt * 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt * 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] - safety_islands[v - 2]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 2]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] - safety_islands[v - 0]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 0]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] - safety_islands[v - 0]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 0]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cost2 = safety_islands[v] - safety_islands[v - 1]",
      "mutated_line": "cost2 = safety_islands[v] - safety_islands[v - -1]",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - -1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost2) * g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) * g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][t + cost2 + g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][t + cost2 + g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost2) % g] == -2:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -2:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost2) % g] == -0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -0:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost2) % g] == -0:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -0:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost2) % g] == --1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == --1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if t + cost2 < g:",
      "mutated_line": "if t - cost2 < g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t - cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if t + cost2 < g:",
      "mutated_line": "if t * cost2 < g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t * cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][0] = cnt - 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt - 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][0] = cnt * 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt * 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "elif j + n - safety_islands[i] <= g:",
      "mutated_line": "elif j - n - safety_islands[i] <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j - n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "elif j + n - safety_islands[i] <= g:",
      "mutated_line": "elif j * n - safety_islands[i] <= g:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j * n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] * (g + r) + j + n + safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n + safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, (checked[i][j] * (g + r) + j + n) * safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, (checked[i][j] * (g + r) + j + n) * safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t + cost1) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v - 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v * 1][(t + cost1) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v * 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t - cost1) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t - cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 1][t * cost1 % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][t * cost1 % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v + 1][t - cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t - cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v + 1][t * cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t * cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][1] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][1] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][-1] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][-1] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][1] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][1] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][0] = cnt + 2",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 2\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][0] = cnt + 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 0\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][0] = cnt + 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 0\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][0] = cnt + -1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + -1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v + 1][(t + cost2) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v + 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v * 1][(t + cost2) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v * 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][(t - cost2) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t - cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 1][t * cost2 % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][t * cost2 % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v - 1][t - cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t - cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v - 1][t * cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t * cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][1] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][1] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][-1] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][-1] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][1] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][1] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][0] = cnt + 2",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 2\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][0] = cnt + 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 0\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][0] = cnt + 0",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 0\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][0] = cnt + -1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + -1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] * (g + r) + j - n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j - n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, (checked[i][j] * (g + r) + j) * n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, (checked[i][j] * (g + r) + j) * n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 2][(t + cost1) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 2][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 0][(t + cost1) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 0][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + 0][(t + cost1) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 0][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if checked[v + 1][(t + cost1) % g] == -1:",
      "mutated_line": "if checked[v + -1][(t + cost1) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + -1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v - 1, t + cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v - 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v * 1, t + cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v * 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v + 1, t - cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t - cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v + 1, t * cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t * cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v - 1][t + cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v - 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v * 1][t + cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v * 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v * 1, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v * 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 1, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 1, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, -1, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, -1, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 1, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 1, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 0, cnt - 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt - 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 0, cnt * 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt * 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v - 1][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v * 1][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v * 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 2][(t + cost2) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 2][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 0][(t + cost2) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 0][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - 0][(t + cost2) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 0][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if checked[v - 1][(t + cost2) % g] == -1:",
      "mutated_line": "if checked[v - -1][(t + cost2) % g] == -1:",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - -1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v + 1, t + cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v + 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v * 1, t + cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v * 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v - 1, t - cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t - cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v - 1, t * cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t * cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v + 1][t + cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v + 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v * 1][t + cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v * 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v * 1, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v * 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 1, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 1, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, -1, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, -1, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 1, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 1, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 0, cnt - 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt - 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 0, cnt * 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt * 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v + 1][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v * 1][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v * 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] * (g + r) - j + n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) - j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] * (g + r) * j + n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) * j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v + 2, t + cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 2, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v + 0, t + cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 0, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v + 0, t + cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 0, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.appendleft((v + 1, t + cost1, cnt))",
      "mutated_line": "q.appendleft((v + -1, t + cost1, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + -1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v + 2][t + cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 2][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v + 0][t + cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 0][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v + 0][t + cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 0][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "checked[v + 1][t + cost1] = cnt",
      "mutated_line": "checked[v + -1][t + cost1] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + -1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 2, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 2, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 0, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 0, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 0, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 0, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + -1, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + -1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 0, cnt + 2))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 2))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 0, cnt + 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 0))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 0, cnt + 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 0))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "q.append((v + 1, 0, cnt + 1))",
      "mutated_line": "q.append((v + 1, 0, cnt + -1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + -1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 2][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 2][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 0][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 0][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + 0][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 0][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "checked[v + 1][0] = cnt + 1",
      "mutated_line": "checked[v + -1][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + -1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v - 2, t + cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 2, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v - 0, t + cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 0, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v - 0, t + cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 0, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "q.appendleft((v - 1, t + cost2, cnt))",
      "mutated_line": "q.appendleft((v - -1, t + cost2, cnt))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - -1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v - 2][t + cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 2][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v - 0][t + cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 0][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v - 0][t + cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 0][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "checked[v - 1][t + cost2] = cnt",
      "mutated_line": "checked[v - -1][t + cost2] = cnt",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - -1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 2, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 2, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 0, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 0, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 0, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 0, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - -1, 0, cnt + 1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - -1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 0, cnt + 2))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 2))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 0, cnt + 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 0))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 0, cnt + 0))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 0))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q.append((v - 1, 0, cnt + 1))",
      "mutated_line": "q.append((v - 1, 0, cnt + -1))",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + -1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 2][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 2][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 0][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 0][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - 0][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 0][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "checked[v - 1][0] = cnt + 1",
      "mutated_line": "checked[v - -1][0] = cnt + 1",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - -1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] / (g + r) + j + n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] / (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] + (g + r) + j + n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] + (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] ** (g + r) + j + n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] ** (g + r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] * (g - r) + j + n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g - r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = min(ans, checked[i][j] * (g + r) + j + n - safety_islands[i])",
      "mutated_line": "ans = min(ans, checked[i][j] * (g * r) + j + n - safety_islands[i])",
      "code": "import collections\n\ndef min_time_to_cross_road(n, m, safety_islands, g, r):\n    safety_islands = sorted(safety_islands)\n    q = collections.deque()\n    q.append((0, 0, 0))\n    checked = [[-1] * g for _ in range(m)]\n    checked[0][0] = 0\n    while q:\n        (v, t, cnt) = q.popleft()\n        if v != m - 1:\n            cost1 = safety_islands[v + 1] - safety_islands[v]\n            if t + cost1 <= g:\n                if checked[v + 1][(t + cost1) % g] == -1:\n                    if t + cost1 < g:\n                        q.appendleft((v + 1, t + cost1, cnt))\n                        checked[v + 1][t + cost1] = cnt\n                    else:\n                        q.append((v + 1, 0, cnt + 1))\n                        checked[v + 1][0] = cnt + 1\n        if v != 0:\n            cost2 = safety_islands[v] - safety_islands[v - 1]\n            if t + cost2 <= g:\n                if checked[v - 1][(t + cost2) % g] == -1:\n                    if t + cost2 < g:\n                        q.appendleft((v - 1, t + cost2, cnt))\n                        checked[v - 1][t + cost2] = cnt\n                    else:\n                        q.append((v - 1, 0, cnt + 1))\n                        checked[v - 1][0] = cnt + 1\n    ans = 10 ** 18\n    for i in range(m):\n        for j in range(g):\n            if checked[i][j] == -1:\n                continue\n            elif j + n - safety_islands[i] <= g:\n                ans = min(ans, checked[i][j] * (g * r) + j + n - safety_islands[i])\n    return -1 if ans == 10 ** 18 else ans"
    }
  ]
}