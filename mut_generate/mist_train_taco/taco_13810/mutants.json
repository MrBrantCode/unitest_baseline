{
  "task_id": "taco_13810",
  "entry_point": "min_leaves_after_operations",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] / (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] / (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] + (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] + (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] ** (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] ** (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] / (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] / (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] + (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] + (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] ** (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] ** (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] / (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] / (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] + (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] + (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] ** (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] ** (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth[1] = 0",
      "mutated_line": "depth[1] = 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 1\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth[1] = 0",
      "mutated_line": "depth[1] = -1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = -1\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth[1] = 0",
      "mutated_line": "depth[1] = 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 1\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] / (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] / (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] + (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] + (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] ** (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] ** (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bud_cnts = 0",
      "mutated_line": "bud_cnts = 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 1\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bud_cnts = 0",
      "mutated_line": "bud_cnts = -1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = -1\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bud_cnts = 0",
      "mutated_line": "bud_cnts = 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 1\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves + bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves + bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = (n - 1 - direct_leaves) * (bud_cnts * 2)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = (n - 1 - direct_leaves) * (bud_cnts * 2)\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = leaves_without_bud + bud_contribution",
      "mutated_line": "ans = leaves_without_bud - bud_contribution",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud - bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = leaves_without_bud + bud_contribution",
      "mutated_line": "ans = leaves_without_bud * bud_contribution",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud * bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] * (n - 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n - 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] * (n * 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n * 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] * (n - 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n - 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] * (n * 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n * 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] * (n - 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n - 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] * (n * 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n * 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth[1] = 0",
      "mutated_line": "depth[2] = 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[2] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth[1] = 0",
      "mutated_line": "depth[0] = 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[0] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth[1] = 0",
      "mutated_line": "depth[0] = 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[0] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth[1] = 0",
      "mutated_line": "depth[-1] = 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[-1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] * (n - 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n - 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] * (n * 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n * 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth >= 2 or not pruned[node] or (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 or not pruned[node] or (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "bud_cnts += 1",
      "mutated_line": "bud_cnts -= 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts -= 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "child_cnts[two_up] -= 1",
      "mutated_line": "child_cnts[two_up] += 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] += 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "direct_leaves = child_cnts[1]",
      "mutated_line": "direct_leaves = child_cnts[2]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[2]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "direct_leaves = child_cnts[1]",
      "mutated_line": "direct_leaves = child_cnts[0]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[0]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "direct_leaves = child_cnts[1]",
      "mutated_line": "direct_leaves = child_cnts[0]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[0]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "direct_leaves = child_cnts[1]",
      "mutated_line": "direct_leaves = child_cnts[-1]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[-1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 + direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 + direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = (n - 1) * direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = (n - 1) * direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts / 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts / 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - (bud_cnts + 2)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - (bud_cnts + 2)\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts ** 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts ** 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "leaves_without_bud = max(1, direct_leaves)",
      "mutated_line": "leaves_without_bud = max(2, direct_leaves)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(2, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "leaves_without_bud = max(1, direct_leaves)",
      "mutated_line": "leaves_without_bud = max(0, direct_leaves)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(0, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "leaves_without_bud = max(1, direct_leaves)",
      "mutated_line": "leaves_without_bud = max(0, direct_leaves)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(0, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "leaves_without_bud = max(1, direct_leaves)",
      "mutated_line": "leaves_without_bud = max(-1, direct_leaves)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(-1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [+1] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [+1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] * (n + 2)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 2)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 0)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 0)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-1] * (n + -1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + -1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [1] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [1] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [-1] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [1] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [1] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] * (n + 2)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 2)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 0)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 0)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "child_cnts = [0] * (n + 1)",
      "mutated_line": "child_cnts = [0] * (n + -1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + -1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [+1] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [+1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] * (n + 2)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 2)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 0)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 0)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-1] * (n + -1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + -1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(2, -1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(2, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(0, -1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(0, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(0, -1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(0, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(-1, -1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(-1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(1, +1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, +1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if nex != p:",
      "mutated_line": "if nex == p:",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex == p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "child_cnts[node] += 1",
      "mutated_line": "child_cnts[node] -= 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] -= 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "node_depths.sort(reverse=True)",
      "mutated_line": "node_depths.sort(reverse=False)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=False)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [True] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [True] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] * (n + 2)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 2)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 0)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] * (n + 0)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 0)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pruned = [False] * (n + 1)",
      "mutated_line": "pruned = [False] * (n + -1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + -1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth > 2 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth > 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth < 2 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth < 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth == 2 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth == 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bud_cnts += 1",
      "mutated_line": "bud_cnts += 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 2\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bud_cnts += 1",
      "mutated_line": "bud_cnts += 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 0\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bud_cnts += 1",
      "mutated_line": "bud_cnts += 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 0\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bud_cnts += 1",
      "mutated_line": "bud_cnts += -1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += -1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "child_cnts[two_up] -= 1",
      "mutated_line": "child_cnts[two_up] -= 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 2\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "child_cnts[two_up] -= 1",
      "mutated_line": "child_cnts[two_up] -= 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 0\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "child_cnts[two_up] -= 1",
      "mutated_line": "child_cnts[two_up] -= 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 0\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "child_cnts[two_up] -= 1",
      "mutated_line": "child_cnts[two_up] -= -1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= -1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "pruned[par[node]] = True",
      "mutated_line": "pruned[par[node]] = False",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = False\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n + 1 - direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n + 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n * 1 - direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n * 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 3",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 3\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 1\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 0\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 1\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * -2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * -2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-2] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-2] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-0] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-0] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [-0] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-0] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "par = [-1] * (n + 1)",
      "mutated_line": "par = [--1] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [--1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-2] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-2] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-0] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-0] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [-0] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-0] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [-1] * (n + 1)",
      "mutated_line": "depth = [--1] * (n + 1)",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [--1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(1, -2)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -2)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(1, -0)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -0)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(1, -0)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -0)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(1, -1)]",
      "mutated_line": "stack = [(1, --1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, --1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "child_cnts[node] += 1",
      "mutated_line": "child_cnts[node] += 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 2\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "child_cnts[node] += 1",
      "mutated_line": "child_cnts[node] += 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 0\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "child_cnts[node] += 1",
      "mutated_line": "child_cnts[node] += 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 0\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "child_cnts[node] += 1",
      "mutated_line": "child_cnts[node] += -1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += -1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "depth[nex] = depth[node] + 1",
      "mutated_line": "depth[nex] = depth[node] - 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] - 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "depth[nex] = depth[node] + 1",
      "mutated_line": "depth[nex] = depth[node] * 1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] * 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(2, n + 1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(2, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(0, n + 1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(0, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(0, n + 1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(0, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(-1, n + 1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(-1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(1, n - 1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n - 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(1, n * 1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n * 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth >= 3 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 3 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth >= 1 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 1 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth >= 0 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 0 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth >= 1 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 1 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if depth >= 2 and not pruned[node] and not pruned[par[node]]:",
      "mutated_line": "if depth >= -2 and (not pruned[node]) and (not pruned[par[node]]):",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= -2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 2 - direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 2 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 0 - direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 0 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - 0 - direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 0 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "bud_contribution = n - 1 - direct_leaves - bud_cnts * 2",
      "mutated_line": "bud_contribution = n - -1 - direct_leaves - bud_cnts * 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - -1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "depth[nex] = depth[node] + 1",
      "mutated_line": "depth[nex] = depth[node] + 2",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 2\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "depth[nex] = depth[node] + 1",
      "mutated_line": "depth[nex] = depth[node] + 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 0\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "depth[nex] = depth[node] + 1",
      "mutated_line": "depth[nex] = depth[node] + 0",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 0\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "depth[nex] = depth[node] + 1",
      "mutated_line": "depth[nex] = depth[node] + -1",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + -1\n    node_depths = [(depth[node], node) for node in range(1, n + 1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(1, n + 2)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 2)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(1, n + 0)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 0)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(1, n + 0)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + 0)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node_depths = [(depth[node], node) for node in range(1, n + 1)]",
      "mutated_line": "node_depths = [(depth[node], node) for node in range(1, n + -1)]",
      "code": "def min_leaves_after_operations(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    par = [-1] * (n + 1)\n    child_cnts = [0] * (n + 1)\n    depth = [-1] * (n + 1)\n    depth[1] = 0\n    stack = [(1, -1)]\n    while stack:\n        (node, p) = stack.pop()\n        par[node] = p\n        for nex in adj[node]:\n            if nex != p:\n                child_cnts[node] += 1\n                stack.append((nex, node))\n                depth[nex] = depth[node] + 1\n    node_depths = [(depth[node], node) for node in range(1, n + -1)]\n    node_depths.sort(reverse=True)\n    pruned = [False] * (n + 1)\n    bud_cnts = 0\n    for (depth, node) in node_depths:\n        if depth >= 2 and (not pruned[node]) and (not pruned[par[node]]):\n            bud_cnts += 1\n            two_up = par[par[node]]\n            child_cnts[two_up] -= 1\n            pruned[par[node]] = True\n    direct_leaves = child_cnts[1]\n    bud_contribution = n - 1 - direct_leaves - bud_cnts * 2\n    leaves_without_bud = max(1, direct_leaves)\n    ans = leaves_without_bud + bud_contribution\n    return ans"
    }
  ]
}