{
  "task_id": "taco_3636",
  "entry_point": "find_max_shut_down_roads",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] / (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] / (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] + (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] + (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] ** (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] ** (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] / (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] / (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] + (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] + (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] ** (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] ** (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] / (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] / (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] + (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] + (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] ** (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] ** (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [inf] * n",
      "mutated_line": "dist = [inf] / n",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] / n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [inf] * n",
      "mutated_line": "dist = [inf] + n",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] + n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [inf] * n",
      "mutated_line": "dist = [inf] ** n",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] ** n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = int(1e9)",
      "mutated_line": "inf = int(1000000001.0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000001.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = int(1e9)",
      "mutated_line": "inf = int(999999999.0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(999999999.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = int(1e9)",
      "mutated_line": "inf = int(0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = int(1e9)",
      "mutated_line": "inf = int(1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = int(1e9)",
      "mutated_line": "inf = int(-1000000000.0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(-1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] * (n + 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n + 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] * (n * 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n * 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] * (n + 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n + 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] * (n * 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n * 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] * (n + 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n + 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] * (n * 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n * 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "l[i] = u - 1",
      "mutated_line": "l[i] = u + 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u + 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "l[i] = u - 1",
      "mutated_line": "l[i] = u * 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u * 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r[i] = v - 1",
      "mutated_line": "r[i] = v + 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v + 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "r[i] = v - 1",
      "mutated_line": "r[i] = v * 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v * 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "station_index = station - 1",
      "mutated_line": "station_index = station + 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station + 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "station_index = station - 1",
      "mutated_line": "station_index = station * 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station * 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[station_index] = 0",
      "mutated_line": "dist[station_index] = 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 1\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[station_index] = 0",
      "mutated_line": "dist[station_index] = -1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = -1\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[station_index] = 0",
      "mutated_line": "dist[station_index] = 1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 1\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i - 1 for i in range(n - 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i - 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i * 1 for i in range(n - 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i * 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [1] * (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [1] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [-1] * (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [-1] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [1] * (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [1] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] * (n - 2)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 2)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] * (n - 0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 0)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] * (n - 0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 0)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l = [0] * (n - 1)",
      "mutated_line": "l = [0] * (n - -1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - -1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [1] * (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [1] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [-1] * (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [-1] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [1] * (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [1] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] * (n - 2)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 2)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] * (n - 0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 0)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] * (n - 0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 0)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = [0] * (n - 1)",
      "mutated_line": "r = [0] * (n - -1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - -1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [False] * (n - 1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [False] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] * (n - 2)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 2)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] * (n - 0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 0)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] * (n - 0)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 0)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "need = [True] * (n - 1)",
      "mutated_line": "need = [True] * (n - -1)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - -1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l[i] = u - 1",
      "mutated_line": "l[i] = u - 2",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 2\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l[i] = u - 1",
      "mutated_line": "l[i] = u - 0",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 0\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l[i] = u - 1",
      "mutated_line": "l[i] = u - 0",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 0\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "l[i] = u - 1",
      "mutated_line": "l[i] = u - -1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - -1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r[i] = v - 1",
      "mutated_line": "r[i] = v - 2",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 2\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r[i] = v - 1",
      "mutated_line": "r[i] = v - 0",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 0\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r[i] = v - 1",
      "mutated_line": "r[i] = v - 0",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 0\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r[i] = v - 1",
      "mutated_line": "r[i] = v - -1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - -1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "station_index = station - 1",
      "mutated_line": "station_index = station - 2",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 2\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "station_index = station - 1",
      "mutated_line": "station_index = station - 0",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 0\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "station_index = station - 1",
      "mutated_line": "station_index = station - 0",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 0\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "station_index = station - 1",
      "mutated_line": "station_index = station - -1",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - -1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "y = l[edge] ^ r[edge] ^ x",
      "mutated_line": "y = l[edge] ^ r[edge] | x",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] | x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] >= 1 + dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] >= 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] <= 1 + dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] <= 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] != 1 + dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] != 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 2 for i in range(n - 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 2 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 0 for i in range(n - 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 0 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 0 for i in range(n - 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 0 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + -1 for i in range(n - 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + -1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "y = l[edge] ^ r[edge] ^ x",
      "mutated_line": "y = (l[edge] | r[edge]) ^ x",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = (l[edge] | r[edge]) ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] > 1 - dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 - dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] > 1 * dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 * dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist[y] = 1 + dist[x]",
      "mutated_line": "dist[y] = 1 - dist[x]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 - dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist[y] = 1 + dist[x]",
      "mutated_line": "dist[y] = 1 * dist[x]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 * dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "need[edge] = False",
      "mutated_line": "need[edge] = True",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = True\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 1 for i in range(n + 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n + 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 1 for i in range(n * 1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n * 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[u - 1].append(i)",
      "mutated_line": "g[u + 1].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u + 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[u - 1].append(i)",
      "mutated_line": "g[u * 1].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u * 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "g[v - 1].append(i)",
      "mutated_line": "g[v + 1].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v + 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "g[v - 1].append(i)",
      "mutated_line": "g[v * 1].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v * 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] > 2 + dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 2 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] > 0 + dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 0 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] > 0 + dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 0 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if dist[y] > 1 + dist[x]:",
      "mutated_line": "if dist[y] > -1 + dist[x]:",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > -1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist[y] = 1 + dist[x]",
      "mutated_line": "dist[y] = 2 + dist[x]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 2 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist[y] = 1 + dist[x]",
      "mutated_line": "dist[y] = 0 + dist[x]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 0 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist[y] = 1 + dist[x]",
      "mutated_line": "dist[y] = 0 + dist[x]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 0 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist[y] = 1 + dist[x]",
      "mutated_line": "dist[y] = -1 + dist[x]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = -1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 1 for i in range(n - 2) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 2) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 1 for i in range(n - 0) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 0) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 1 for i in range(n - 0) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 0) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]",
      "mutated_line": "shut_down_road_indices = [i + 1 for i in range(n - -1) if need[i]]",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - -1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[u - 1].append(i)",
      "mutated_line": "g[u - 2].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 2].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[u - 1].append(i)",
      "mutated_line": "g[u - 0].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 0].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[u - 1].append(i)",
      "mutated_line": "g[u - 0].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 0].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[u - 1].append(i)",
      "mutated_line": "g[u - -1].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - -1].append(i)\n        g[v - 1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g[v - 1].append(i)",
      "mutated_line": "g[v - 2].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 2].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g[v - 1].append(i)",
      "mutated_line": "g[v - 0].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 0].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g[v - 1].append(i)",
      "mutated_line": "g[v - 0].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - 0].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g[v - 1].append(i)",
      "mutated_line": "g[v - -1].append(i)",
      "code": "import math\nfrom collections import deque\n\ndef find_max_shut_down_roads(n, k, d, police_stations, roads):\n    inf = int(1000000000.0)\n    g = [[] for _ in range(n)]\n    l = [0] * (n - 1)\n    r = [0] * (n - 1)\n    need = [True] * (n - 1)\n    dist = [inf] * n\n    for (i, (u, v)) in enumerate(roads):\n        l[i] = u - 1\n        r[i] = v - 1\n        g[u - 1].append(i)\n        g[v - -1].append(i)\n    queue = deque()\n    for station in police_stations:\n        station_index = station - 1\n        queue.append(station_index)\n        dist[station_index] = 0\n    while queue:\n        x = queue.popleft()\n        for edge in g[x]:\n            y = l[edge] ^ r[edge] ^ x\n            if dist[y] > 1 + dist[x]:\n                dist[y] = 1 + dist[x]\n                queue.append(y)\n                need[edge] = False\n    max_roads_to_shut_down = sum(need)\n    shut_down_road_indices = [i + 1 for i in range(n - 1) if need[i]]\n    return (max_roads_to_shut_down, shut_down_road_indices)"
    }
  ]
}