{
  "task_id": "taco_6166",
  "entry_point": "generate_max_bridges_graph",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "m -= n - 1",
      "mutated_line": "m += n - 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m += n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m -= n - 1",
      "mutated_line": "m -= n + 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n + 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m -= n - 1",
      "mutated_line": "m -= n * 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n * 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = 3",
      "mutated_line": "c = 4",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 4\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = 3",
      "mutated_line": "c = 2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 2\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = 3",
      "mutated_line": "c = 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 0\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = 3",
      "mutated_line": "c = 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 1\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = 3",
      "mutated_line": "c = -3",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = -3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 or c < n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 or c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c -= 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(2, n):",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(2, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(0, n):",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(0, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(0, n):",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(0, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for j in range(1, n):",
      "mutated_line": "for j in range(-1, n):",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(-1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m -= n - 1",
      "mutated_line": "m -= n - 2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 2\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m -= n - 1",
      "mutated_line": "m -= n - 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 0\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m -= n - 1",
      "mutated_line": "m -= n - 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 0\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m -= n - 1",
      "mutated_line": "m -= n - -1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - -1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m == 0 and c < n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m == 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c <= n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c <= n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c >= n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c >= n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c != n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c != n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = c - 2",
      "mutated_line": "j = c + 2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c + 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = c - 2",
      "mutated_line": "j = c * 2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c * 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while j > 0:",
      "mutated_line": "while j >= 0:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j >= 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while j > 0:",
      "mutated_line": "while j <= 0:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j <= 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while j > 0:",
      "mutated_line": "while j != 0:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j != 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j += 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 2\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 0\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 0\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += -1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans[j] = [j + 1]",
      "mutated_line": "ans[j] = [j - 1]",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j - 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans[j] = [j + 1]",
      "mutated_line": "ans[j] = [j * 1]",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j * 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 1 and c < n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 1 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != -1 and c < n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != -1 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 1 and c < n + 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 1 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c < n - 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n - 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c < n * 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n * 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = c - 2",
      "mutated_line": "j = c - 3",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 3\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = c - 2",
      "mutated_line": "j = c - 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 1\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = c - 2",
      "mutated_line": "j = c - 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 0\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = c - 2",
      "mutated_line": "j = c - 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 1\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = c - 2",
      "mutated_line": "j = c - -2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - -2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while j > 0:",
      "mutated_line": "while j > 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 1:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while j > 0:",
      "mutated_line": "while j > -1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > -1:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while j > 0:",
      "mutated_line": "while j > 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 1:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if c not in ans[j]:",
      "mutated_line": "if c in ans[j]:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "m -= 1",
      "mutated_line": "m += 1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m += 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m != 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 2\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 0\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 0\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= -1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans[j] = [j + 1]",
      "mutated_line": "ans[j] = [j + 2]",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 2]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans[j] = [j + 1]",
      "mutated_line": "ans[j] = [j + 0]",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 0]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans[j] = [j + 1]",
      "mutated_line": "ans[j] = [j + 0]",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 0]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans[j] = [j + 1]",
      "mutated_line": "ans[j] = [j + -1]",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + -1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c < n + 2:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 2:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c < n + 0:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 0:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c < n + 0:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 0:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while m != 0 and c < n + 1:",
      "mutated_line": "while m != 0 and c < n + -1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + -1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m -= 1",
      "mutated_line": "m -= 2",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 2\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m -= 1",
      "mutated_line": "m -= 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 0\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m -= 1",
      "mutated_line": "m -= 0",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 0\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m -= 1",
      "mutated_line": "m -= -1",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= -1\n            if m == 0:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 1:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == -1:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def generate_max_bridges_graph(n, m):\n    ans = {}\n    for j in range(1, n):\n        ans[j] = [j + 1]\n    m -= n - 1\n    c = 3\n    while m != 0 and c < n + 1:\n        j = c - 2\n        while j > 0:\n            if c not in ans[j]:\n                ans[j].append(c)\n                m -= 1\n            if m == 1:\n                break\n            j -= 1\n        c += 1\n    edges = []\n    for u in ans:\n        for v in ans[u]:\n            edges.append((u, v))\n    return edges"
    }
  ]
}