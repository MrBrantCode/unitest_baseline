{
  "task_id": "taco_8360",
  "entry_point": "longest_word_chain",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [1] / n",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] / n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [1] + n",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] + n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [1] ** n",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] ** n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_length = 1",
      "mutated_line": "max_length = 2",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 2\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_length = 1",
      "mutated_line": "max_length = 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 0\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_length = 1",
      "mutated_line": "max_length = 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 0\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_length = 1",
      "mutated_line": "max_length = -1",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = -1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(word1) != len(word2) + 1:",
      "mutated_line": "if len(word1) == len(word2) + 1:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) == len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while i < len(word1):",
      "mutated_line": "while i <= len(word1):",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i <= len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while i < len(word1):",
      "mutated_line": "while i >= len(word1):",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i >= len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while i < len(word1):",
      "mutated_line": "while i != len(word1):",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i != len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "return i == len(word1) and j == len(word2)",
      "mutated_line": "return i == len(word1) or j == len(word2)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) or j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(2, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(0, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(0, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(-1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if len(word1) != len(word2) + 1:",
      "mutated_line": "if len(word1) != len(word2) - 1:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) - 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if len(word1) != len(word2) + 1:",
      "mutated_line": "if len(word1) != len(word2) * 1:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) * 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return True\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (1, 0)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (1, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (-1, 0)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (-1, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (1, 0)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (1, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (0, 1)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 1)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (0, -1)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, -1)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(i, j) = (0, 0)",
      "mutated_line": "(i, j) = (0, 1)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 1)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if j < len(word2) and word1[i] == word2[j]:",
      "mutated_line": "if j < len(word2) or word1[i] == word2[j]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) or word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i -= 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j -= 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i -= 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return i == len(word1) and j == len(word2)",
      "mutated_line": "return i != len(word1) and j == len(word2)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i != len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return i == len(word1) and j == len(word2)",
      "mutated_line": "return i == len(word1) and j != len(word2)",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j != len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [2] * n",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [2] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [0] * n",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [0] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [0] * n",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [0] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [1] * n",
      "mutated_line": "dp = [-1] * n",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [-1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) or 1 + dp[j] > dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) or 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(word1) != len(word2) + 1:",
      "mutated_line": "if len(word1) != len(word2) + 2:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 2:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(word1) != len(word2) + 1:",
      "mutated_line": "if len(word1) != len(word2) + 0:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 0:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(word1) != len(word2) + 1:",
      "mutated_line": "if len(word1) != len(word2) + 0:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 0:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if len(word1) != len(word2) + 1:",
      "mutated_line": "if len(word1) != len(word2) + -1:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + -1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if j < len(word2) and word1[i] == word2[j]:",
      "mutated_line": "if j <= len(word2) and word1[i] == word2[j]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j <= len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if j < len(word2) and word1[i] == word2[j]:",
      "mutated_line": "if j >= len(word2) and word1[i] == word2[j]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j >= len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if j < len(word2) and word1[i] == word2[j]:",
      "mutated_line": "if j != len(word2) and word1[i] == word2[j]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j != len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if j < len(word2) and word1[i] == word2[j]:",
      "mutated_line": "if j < len(word2) and word1[i] != word2[j]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] != word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 2\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 0\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 0\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += -1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 2\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 0\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 0\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += -1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 2\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 0\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 0\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += -1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] >= dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] >= dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] <= dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] <= dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] != dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] != dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i] = 1 + dp[j]",
      "mutated_line": "dp[i] = 1 - dp[j]",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 - dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i] = 1 + dp[j]",
      "mutated_line": "dp[i] = 1 * dp[j]",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 * dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if max_length < dp[i]:",
      "mutated_line": "if max_length <= dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length <= dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if max_length < dp[i]:",
      "mutated_line": "if max_length >= dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length >= dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if max_length < dp[i]:",
      "mutated_line": "if max_length != dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length != dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 1 - dp[j] > dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 - dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 1 * dp[j] > dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 * dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i] = 1 + dp[j]",
      "mutated_line": "dp[i] = 2 + dp[j]",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 2 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i] = 1 + dp[j]",
      "mutated_line": "dp[i] = 0 + dp[j]",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 0 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i] = 1 + dp[j]",
      "mutated_line": "dp[i] = 0 + dp[j]",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = 0 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i] = 1 + dp[j]",
      "mutated_line": "dp[i] = -1 + dp[j]",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:\n                dp[i] = -1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 2 + dp[j] > dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 2 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 0 + dp[j] > dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 0 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and 0 + dp[j] > dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and 0 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if is_predecessor(words[i], words[j]) and 1 + dp[j] > dp[i]:",
      "mutated_line": "if is_predecessor(words[i], words[j]) and -1 + dp[j] > dp[i]:",
      "code": "def longest_word_chain(words):\n\n    def is_predecessor(word1, word2):\n        if len(word1) != len(word2) + 1:\n            return False\n        (i, j) = (0, 0)\n        while i < len(word1):\n            if j < len(word2) and word1[i] == word2[j]:\n                i += 1\n                j += 1\n            else:\n                i += 1\n        return i == len(word1) and j == len(word2)\n    n = len(words)\n    dp = [1] * n\n    max_length = 1\n    words.sort(key=len)\n    for i in range(1, n):\n        for j in range(i):\n            if is_predecessor(words[i], words[j]) and -1 + dp[j] > dp[i]:\n                dp[i] = 1 + dp[j]\n                if max_length < dp[i]:\n                    max_length = dp[i]\n    return max_length"
    }
  ]
}