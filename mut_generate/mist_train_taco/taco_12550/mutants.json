{
  "task_id": "taco_12550",
  "entry_point": "minimize_max_consecutive_block",
  "mutant_count": 123,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' / (N // 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' / (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' + N // 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' + N // 2\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' ** (N // 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' ** (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' / (N // 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' / (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' + N // 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' + N // 2\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' ** (N // 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' ** (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 != 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 != 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "a += '0'",
      "mutated_line": "a -= '0'",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a -= '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "b += '1'",
      "mutated_line": "b -= '1'",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b -= '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if n1 <= K or n2 <= K:",
      "mutated_line": "if n1 <= K and n2 <= K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K and n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 2\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 0\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 0\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = -1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while l < r:",
      "mutated_line": "while l <= r:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l <= r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while l < r:",
      "mutated_line": "while l >= r:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l >= r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while l < r:",
      "mutated_line": "while l != r:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l != r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "flips = 0",
      "mutated_line": "flips = 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 1\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "flips = 0",
      "mutated_line": "flips = -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = -1\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "flips = 0",
      "mutated_line": "flips = 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 1\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '' * (N // 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' * (N / 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N / 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' * (N * 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N * 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '' * (N // 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' * (N / 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N / 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' * (N * 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N * 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N * 2 == 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N * 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N + 2 == 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N + 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == 2:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 2:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == 0:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 0:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == 0:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 0:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == -1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == -1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "a += '0'",
      "mutated_line": "a += ''",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += ''\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b += '1'",
      "mutated_line": "b += ''",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += ''\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n1 <= K or n2 <= K:",
      "mutated_line": "if n1 < K or n2 <= K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 < K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n1 <= K or n2 <= K:",
      "mutated_line": "if n1 > K or n2 <= K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 > K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n1 <= K or n2 <= K:",
      "mutated_line": "if n1 == K or n2 <= K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 == K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n1 <= K or n2 <= K:",
      "mutated_line": "if n1 <= K or n2 < K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 < K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n1 <= K or n2 <= K:",
      "mutated_line": "if n1 <= K or n2 > K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 > K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n1 <= K or n2 <= K:",
      "mutated_line": "if n1 <= K or n2 == K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 == K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 2\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 0\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 0\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return -1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(2, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(0, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(0, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(-1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if schedule[i] != schedule[i - 1]:",
      "mutated_line": "if schedule[i] == schedule[i - 1]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] == schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count -= 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l, r = 2, N",
      "mutated_line": "(l, r) = (3, N)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (3, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l, r = 2, N",
      "mutated_line": "(l, r) = (1, N)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (1, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l, r = 2, N",
      "mutated_line": "(l, r) = (0, N)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (0, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l, r = 2, N",
      "mutated_line": "(l, r) = (1, N)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (1, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l, r = 2, N",
      "mutated_line": "(l, r) = (-2, N)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (-2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) / 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) / 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) * 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) * 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 1\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = -1\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 1\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if c > K:",
      "mutated_line": "if c >= K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c >= K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if c > K:",
      "mutated_line": "if c <= K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c <= K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if c > K:",
      "mutated_line": "if c != K:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c != K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if pattern[i] != schedule[i]:",
      "mutated_line": "if pattern[i] == schedule[i]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] == schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "flips += 1",
      "mutated_line": "flips -= 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips -= 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' * (N // 3)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 3)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' * (N // 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 1)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' * (N // 0)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 0)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' * (N // 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 1)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = '01' * (N // 2)",
      "mutated_line": "a = '01' * (N // -2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // -2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' * (N // 3)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 3)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' * (N // 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 1)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' * (N // 0)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 0)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' * (N // 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 1)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = '10' * (N // 2)",
      "mutated_line": "b = '10' * (N // -2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // -2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 3 == 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 3 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 1 == 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 1 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 0 == 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 0 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 1 == 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 1 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % -2 == 1:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % -2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 1",
      "mutated_line": "count = 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 2\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 0\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 0\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 1",
      "mutated_line": "count = -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = -1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 2\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 0\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 0\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += -1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l - r) // 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l - r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = l * r // 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = l * r // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 3",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 3\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 1\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 0\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 1\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // -2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // -2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if i > mid:",
      "mutated_line": "if i >= mid:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i >= mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if i > mid:",
      "mutated_line": "if i <= mid:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i <= mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if i > mid:",
      "mutated_line": "if i != mid:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i != mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c -= i // (mid + 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c -= i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid - 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid - 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid * 1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid * 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "flips += 1",
      "mutated_line": "flips += 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 2\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "flips += 1",
      "mutated_line": "flips += 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 0\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "flips += 1",
      "mutated_line": "flips += 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 0\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "flips += 1",
      "mutated_line": "flips += -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += -1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if schedule[i] != schedule[i - 1]:",
      "mutated_line": "if schedule[i] != schedule[i + 1]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i + 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if schedule[i] != schedule[i - 1]:",
      "mutated_line": "if schedule[i] != schedule[i * 1]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i * 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i / (mid + 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i / (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i * (mid + 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i * (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + 2",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 2\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 0\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + 0",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 0\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "l = mid + 1",
      "mutated_line": "l = mid + -1",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + -1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if schedule[i] != schedule[i - 1]:",
      "mutated_line": "if schedule[i] != schedule[i - 2]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 2]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if schedule[i] != schedule[i - 1]:",
      "mutated_line": "if schedule[i] != schedule[i - 0]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 0]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if schedule[i] != schedule[i - 1]:",
      "mutated_line": "if schedule[i] != schedule[i - 0]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 0]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if schedule[i] != schedule[i - 1]:",
      "mutated_line": "if schedule[i] != schedule[i - -1]:",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - -1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i // (mid - 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid - 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i // (mid * 1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid * 1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i // (mid + 2)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 2)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i // (mid + 0)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 0)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i // (mid + 0)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + 0)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += i // (mid + 1)",
      "mutated_line": "c += i // (mid + -1)",
      "code": "def minimize_max_consecutive_block(N, K, schedule):\n\n    def count_flips(pattern):\n        flips = 0\n        for i in range(N):\n            if pattern[i] != schedule[i]:\n                flips += 1\n        return flips\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N % 2 == 1:\n        a += '0'\n        b += '1'\n    n1 = count_flips(a)\n    n2 = count_flips(b)\n    if n1 <= K or n2 <= K:\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, N):\n        if schedule[i] != schedule[i - 1]:\n            blocks.append(count)\n            count = 1\n        else:\n            count += 1\n    blocks.append(count)\n    (l, r) = (2, N)\n    while l < r:\n        mid = (l + r) // 2\n        c = 0\n        for i in blocks:\n            if i > mid:\n                c += i // (mid + -1)\n        if c > K:\n            l = mid + 1\n        else:\n            r = mid\n    return l"
    }
  ]
}