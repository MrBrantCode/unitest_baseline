{
  "task_id": "taco_16720",
  "entry_point": "maximize_gems",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 1\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = -1\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 1\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "reward = 0",
      "mutated_line": "reward = 1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 1\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "reward = 0",
      "mutated_line": "reward = -1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = -1\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "reward = 0",
      "mutated_line": "reward = 1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 1\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "reward += booty[i]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i -= 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):",
      "mutated_line": "def pick_k(keys_to_chest, booty, k, starting_at=1, opened=0):",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=1, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):",
      "mutated_line": "def pick_k(keys_to_chest, booty, k, starting_at=-1, opened=0):",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=-1, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):",
      "mutated_line": "def pick_k(keys_to_chest, booty, k, starting_at=1, opened=0):",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=1, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):",
      "mutated_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=1):",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=1):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):",
      "mutated_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=-1):",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=-1):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):",
      "mutated_line": "def pick_k(keys_to_chest, booty, k, starting_at=0, opened=1):",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=1):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k == 0: return score(keys_to_chest, booty, opened)",
      "mutated_line": "if k != 0:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k != 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "best_booty = 0",
      "mutated_line": "return score(keys_to_chest, booty, opened)",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 1\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "best_booty = 0",
      "mutated_line": "return score(keys_to_chest, booty, opened)",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = -1\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "best_booty = 0",
      "mutated_line": "return score(keys_to_chest, booty, opened)",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 1\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return gcd(b, a % b)",
      "mutated_line": "return a",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a * b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return gcd(b, a % b)",
      "mutated_line": "return a",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a + b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k not in mem: mem[k] = f(keys_to_chest, booty, opened)",
      "mutated_line": "if k in mem:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if opened & 1: reward += booty[i]",
      "mutated_line": "if opened | 1:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened | 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "if opened & 1: reward += booty[i]",
      "mutated_line": "if opened & 1:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward -= booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "reward += booty[i]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 2\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "reward += booty[i]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 0\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "reward += booty[i]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 0\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "reward += booty[i]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += -1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "opened //= 2",
      "mutated_line": "opened //= 3",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 3\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "opened //= 2",
      "mutated_line": "opened //= 1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 1\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "opened //= 2",
      "mutated_line": "opened //= 0",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 0\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "opened //= 2",
      "mutated_line": "opened //= 1",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 1\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "opened //= 2",
      "mutated_line": "opened //= -2",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= -2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k == 0: return score(keys_to_chest, booty, opened)",
      "mutated_line": "if k == 1:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 1:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k == 0: return score(keys_to_chest, booty, opened)",
      "mutated_line": "if k == -1:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == -1:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k == 0: return score(keys_to_chest, booty, opened)",
      "mutated_line": "if k == 1:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 1:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if val > best_booty: best_booty = val",
      "mutated_line": "if val >= best_booty:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val >= best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if val > best_booty: best_booty = val",
      "mutated_line": "if val <= best_booty:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val <= best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if val > best_booty: best_booty = val",
      "mutated_line": "if val != best_booty:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val != best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if opened & 1: reward += booty[i]",
      "mutated_line": "if opened & 2:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 2:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if opened & 1: reward += booty[i]",
      "mutated_line": "if opened & 0:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 0:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if opened & 1: reward += booty[i]",
      "mutated_line": "if opened & 0:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 0:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if opened & 1: reward += booty[i]",
      "mutated_line": "if opened & -1:",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & -1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k + 1, key + 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k + 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k * 1, key + 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k * 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key - 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key - 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key * 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key * 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened & keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened & keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened ^ keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened ^ keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 2, key + 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 2, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 0, key + 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 0, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 0, key + 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 0, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - -1, key + 1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - -1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 2, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 2, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 0, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 0, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 0, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 0, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))",
      "mutated_line": "val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + -1, opened | keys_to_chest[key]))",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + -1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((2 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((2 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((0 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((0 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((0 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((0 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((-1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((-1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) == 1)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) == 1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 2)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 2)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 0)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 0)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 0)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != 0)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "keys_to_chest = [sum(1 << i for i, c in enumerate(cs) if gcd(c, key) != 1) for key in ns]",
      "mutated_line": "keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != -1)) for key in ns]",
      "code": "def maximize_gems(T, test_cases):\n\n    def gcd(a, b):\n        if not b:\n            return a\n        return gcd(b, a % b)\n\n    def memo(f):\n        mem = {}\n\n        def ret(keys_to_chest, booty, opened):\n            k = (id(keys_to_chest), opened)\n            if k not in mem:\n                mem[k] = f(keys_to_chest, booty, opened)\n            return mem[k]\n        return ret\n\n    @memo\n    def score(keys_to_chest, booty, opened):\n        i = 0\n        reward = 0\n        while opened:\n            if opened & 1:\n                reward += booty[i]\n            i += 1\n            opened //= 2\n        return reward\n\n    def pick_k(keys_to_chest, booty, k, starting_at=0, opened=0):\n        if k == 0:\n            return score(keys_to_chest, booty, opened)\n        best_booty = 0\n        for key in range(starting_at, len(keys_to_chest)):\n            val = max(best_booty, pick_k(keys_to_chest, booty, k - 1, key + 1, opened | keys_to_chest[key]))\n            if val > best_booty:\n                best_booty = val\n        return best_booty\n\n    def solve(k, ns, cs, zs):\n        keys_to_chest = [sum((1 << i for (i, c) in enumerate(cs) if gcd(c, key) != -1)) for key in ns]\n        return pick_k(keys_to_chest, zs, k)\n    results = []\n    for case in test_cases:\n        (N, M, K, keys, chests, gems) = case\n        results.append(solve(K, keys, chests, gems))\n    return results"
    }
  ]
}