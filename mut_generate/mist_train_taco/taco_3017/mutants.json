{
  "task_id": "taco_3017",
  "entry_point": "min_operations_to_palindrome",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 1\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = -1\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 1\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 1\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = -1\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 1\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt -= 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "ans += n - cnt - (j - bit.sum(j))",
      "mutated_line": "ans -= n - cnt - (j - bit.sum(j))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans -= n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if odd is not None:",
      "mutated_line": "if odd is None:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans -= abs(n // 2 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans -= abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i += 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "a = ord('a')",
      "mutated_line": "a = ord('')",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 2 != 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 != 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 1) - bit.sum(i) != 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) != 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "code = ord(s[i]) - a",
      "mutated_line": "code = ord(s[i]) + a",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) + a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "code = ord(s[i]) - a",
      "mutated_line": "code = ord(s[i]) * a",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) * a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code == odd or index[code][-1] == i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd or index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 2\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 0\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 0\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += -1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += n - cnt - (j - bit.sum(j))",
      "mutated_line": "ans += n - cnt + (j - bit.sum(j))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt + (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += n - cnt - (j - bit.sum(j))",
      "mutated_line": "ans += (n - cnt) * (j - bit.sum(j))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += (n - cnt) * (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // 2 < cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 < cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // 2 > cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 > cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // 2 == cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 == cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * n",
      "mutated_line": "self.tree = [0] / n",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] / n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * n",
      "mutated_line": "self.tree = [0] + n",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] + n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * n",
      "mutated_line": "self.tree = [0] ** n",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] ** n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 1\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = -1\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 1\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 2\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 0\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 0\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= -1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i >= 0:",
      "mutated_line": "while i > 0:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i > 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i >= 0:",
      "mutated_line": "while i < 0:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i < 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i >= 0:",
      "mutated_line": "while i == 0:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i == 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "s += self.tree[i]",
      "mutated_line": "s -= self.tree[i]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s -= self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < self.size:",
      "mutated_line": "while i <= self.size:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < self.size:",
      "mutated_line": "while i >= self.size:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i >= self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < self.size:",
      "mutated_line": "while i != self.size:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i != self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "self.tree[i] += x",
      "mutated_line": "self.tree[i] -= x",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] -= x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) * 2 == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) * 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) + 2 == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) + 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 2 == 2:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 2:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 2 == 0:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 0:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 2 == 0:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 0:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 2 == -1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == -1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if odd is not None:",
      "mutated_line": "if odd is None:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 1) + bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) + bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 1) * bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) * bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 1) - bit.sum(i) == 2:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 2:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 1) - bit.sum(i) == 0:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 0:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 1) - bit.sum(i) == 0:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 0:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 1) - bit.sum(i) == -1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == -1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code != odd and index[code][-1] == i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code != odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code == odd and index[code][-1] != i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] != i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += n - cnt - (j - bit.sum(j))",
      "mutated_line": "ans += n + cnt - (j - bit.sum(j))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n + cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += n - cnt - (j - bit.sum(j))",
      "mutated_line": "ans += n * cnt - (j - bit.sum(j))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n * cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += n - cnt - (j - bit.sum(j))",
      "mutated_line": "ans += n - cnt - (j + bit.sum(j))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j + bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans += n - cnt - (j - bit.sum(j))",
      "mutated_line": "ans += n - cnt - j * bit.sum(j)",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - j * bit.sum(j)\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "bit.add(j, 1)",
      "mutated_line": "bit.add(j, 2)",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 2)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "bit.add(j, 1)",
      "mutated_line": "bit.add(j, 0)",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 0)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "bit.add(j, 1)",
      "mutated_line": "bit.add(j, 0)",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 0)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "bit.add(j, 1)",
      "mutated_line": "bit.add(j, -1)",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, -1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n / 2 <= cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n / 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n * 2 <= cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n * 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "j = index[odd][-1]",
      "mutated_line": "j = index[odd][+1]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][+1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 2 + (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 + (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 2 * (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 * (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 1:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= -1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= -1:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 1:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 1) + 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) + 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 1) * 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) * 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i - 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i * 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i * 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 3 == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 3 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 1 == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 1 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 0 == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 0 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % 1 == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 1 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(char_pos) % 2 == 1:",
      "mutated_line": "if len(char_pos) % -2 == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % -2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return +1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // 3 <= cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 3 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // 1 <= cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 1 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // 0 <= cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 0 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // 1 <= cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 1 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n // 2 <= cnt:",
      "mutated_line": "if n // -2 <= cnt:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // -2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "j = index[odd][-1]",
      "mutated_line": "j = index[odd][-2]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-2]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "j = index[odd][-1]",
      "mutated_line": "j = index[odd][-0]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-0]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "j = index[odd][-1]",
      "mutated_line": "j = index[odd][-0]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-0]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "j = index[odd][-1]",
      "mutated_line": "j = index[odd][--1]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][--1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n / 2 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n / 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n * 2 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n * 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 2 - (j + bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j + bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 2 - j * bit.sum(j))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - j * bit.sum(j))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * n",
      "mutated_line": "self.tree = [1] * n",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [1] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * n",
      "mutated_line": "self.tree = [-1] * n",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [-1] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * n",
      "mutated_line": "self.tree = [1] * n",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [1] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i | i + 1) - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i | i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 1) - 2",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 2\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 1) - 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 0\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 1) - 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 0\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 1) - -1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - -1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + 2",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 2\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 0\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + 0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 0\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + -1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + -1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "index = [[] for _ in range(26)]",
      "mutated_line": "index = [[] for _ in range(27)]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(27)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "index = [[] for _ in range(26)]",
      "mutated_line": "index = [[] for _ in range(25)]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(25)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "index = [[] for _ in range(26)]",
      "mutated_line": "index = [[] for _ in range(0)]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(0)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "index = [[] for _ in range(26)]",
      "mutated_line": "index = [[] for _ in range(1)]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(1)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "index = [[] for _ in range(26)]",
      "mutated_line": "index = [[] for _ in range(-26)]",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(-26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -2\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -0\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -0\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return --1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i - 1) - bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i - 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i * 1) - bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i * 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code == odd and index[code][+1] == i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][+1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 3 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 3 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 1 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 1 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 0 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 0 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // 1 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 1 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += abs(n // 2 - (j - bit.sum(j)))",
      "mutated_line": "ans += abs(n // -2 - (j - bit.sum(j)))",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // -2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i - 1) - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i - 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i * 1) - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i * 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "index[ord(ch) - a].append(i)",
      "mutated_line": "index[ord(ch) + a].append(i)",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) + a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "index[ord(ch) - a].append(i)",
      "mutated_line": "index[ord(ch) * a].append(i)",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) * a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 2) - bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 2) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 0) - bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 0) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + 0) - bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 0) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bit.sum(i + 1) - bit.sum(i) == 1:",
      "mutated_line": "if bit.sum(i + -1) - bit.sum(i) == 1:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + -1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code == odd and index[code][-2] == i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-2] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code == odd and index[code][-0] == i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-0] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code == odd and index[code][-0] == i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-0] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if code == odd and index[code][-1] == i:",
      "mutated_line": "if code == odd and index[code][--1] == i:",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][--1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 2) - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 2) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 0) - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 0) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + 0) - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + 0) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = (i & i + 1) - 1",
      "mutated_line": "i = (i & i + -1) - 1",
      "code": "def min_operations_to_palindrome(s: str) -> int:\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * n\n\n        def sum(self, i):\n            s = 0\n            i -= 1\n            while i >= 0:\n                s += self.tree[i]\n                i = (i & i + -1) - 1\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i |= i + 1\n    a = ord('a')\n\n    def make_index(s):\n        index = [[] for _ in range(26)]\n        for (i, ch) in enumerate(s):\n            index[ord(ch) - a].append(i)\n        return index\n    n = len(s)\n    index = make_index(s)\n    odd = None\n    for (code, char_pos) in enumerate(index):\n        if len(char_pos) % 2 == 1:\n            if odd is not None:\n                return -1\n            odd = code\n    bit = Bit(n)\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        if bit.sum(i + 1) - bit.sum(i) == 1:\n            continue\n        code = ord(s[i]) - a\n        if code == odd and index[code][-1] == i:\n            continue\n        cnt += 1\n        j = index[code].pop()\n        ans += n - cnt - (j - bit.sum(j))\n        bit.add(j, 1)\n        if n // 2 <= cnt:\n            break\n    if odd is not None:\n        j = index[odd][-1]\n        ans += abs(n // 2 - (j - bit.sum(j)))\n    return ans"
    }
  ]
}