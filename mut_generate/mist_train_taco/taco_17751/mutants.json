{
  "task_id": "taco_17751",
  "entry_point": "csb",
  "mutant_count": 249,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import math\n\ndef csb(n):\n    count = 1\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import math\n\ndef csb(n):\n    count = -1\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import math\n\ndef csb(n):\n    count = 1\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count -= 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 0 and cb < 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 and cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i == n:",
      "mutated_line": "if i != n:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i != n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' - str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' - str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = (str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ') * str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = (str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ') * str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp.get(st) != None:",
      "mutated_line": "if dp.get(st) == None:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) == None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 1\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = -1\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 1\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 1 << i >= 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i >= 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 1 << i <= 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i <= 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 1 << i != 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i != 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x == 1:",
      "mutated_line": "if x != 1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x != 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 2)) - 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) - 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 2)) * 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) * 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n &= n - 1",
      "mutated_line": "n &= n + 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n + 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "n &= n - 1",
      "mutated_line": "n &= n * 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n * 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 2\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 0\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 0\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += -1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca <= 0 or cb < 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca <= 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca >= 0 or cb < 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca >= 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca != 0 or cb < 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca != 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 0 or cb <= 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb <= 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 0 or cb >= 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb >= 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 0 or cb != 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb != 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 1\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return -1\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 1\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 or cb == 0 or cf == 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 or cb == 0 or cf == 0:\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 1\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return -1\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 1\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) - ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) - ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = (str(ca) + ' ' + str(cb) + ' ' + str(cf)) * ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = (str(ca) + ' ' + str(cb) + ' ' + str(cf)) * ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C | 1 << i > 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C | 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 1 << i > 1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 1:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 1 << i > -1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > -1:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 1 << i > 1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 1:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = 1",
      "mutated_line": "x = 2",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 2\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 0\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 0\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = 1",
      "mutated_line": "x = -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = -1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 2:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 2:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 0:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 0:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == 1:",
      "mutated_line": "if x == -1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == -1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if cf == 1:",
      "mutated_line": "if cf != 1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf != 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif cf == 1:",
      "mutated_line": "elif cf != 1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf != 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 2)) + 2",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 2\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 2)) + 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 0\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 2)) + 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 0\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 2)) + -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + -1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return f(csb(A), csb(B), 0, 0, C, n, dp)",
      "mutated_line": "return f(csb(A), csb(B), 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 1, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return f(csb(A), csb(B), 0, 0, C, n, dp)",
      "mutated_line": "return f(csb(A), csb(B), -1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), -1, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return f(csb(A), csb(B), 0, 0, C, n, dp)",
      "mutated_line": "return f(csb(A), csb(B), 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 1, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return f(csb(A), csb(B), 0, 0, C, n, dp)",
      "mutated_line": "return f(csb(A), csb(B), 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 1, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return f(csb(A), csb(B), 0, 0, C, n, dp)",
      "mutated_line": "return f(csb(A), csb(B), 0, -1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, -1, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return f(csb(A), csb(B), 0, 0, C, n, dp)",
      "mutated_line": "return f(csb(A), csb(B), 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 1, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n &= n - 1",
      "mutated_line": "n &= n - 2",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 2\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n &= n - 1",
      "mutated_line": "n &= n - 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 0\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n &= n - 1",
      "mutated_line": "n &= n - 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 0\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n &= n - 1",
      "mutated_line": "n &= n - -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - -1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 1 or cb < 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 1 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < -1 or cb < 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < -1 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 1 or cb < 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 1 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 0 or cb < 1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 1:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 0 or cb < -1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < -1:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if ca < 0 or cb < 0:",
      "mutated_line": "if ca < 0 or cb < 1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 1:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca != 0 and cb == 0 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca != 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb != 0 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb != 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb == 0 and (cf != 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf != 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 2\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 0\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 0\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return -1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + ' ' + str(cb) + ' ' - str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' - str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = (str(ca) + ' ' + str(cb) + ' ') * str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = (str(ca) + ' ' + str(cb) + ' ') * str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + '' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + '' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cf == 1:",
      "mutated_line": "if cf == 2:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 2:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cf == 1:",
      "mutated_line": "if cf == 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 0:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cf == 1:",
      "mutated_line": "if cf == 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 0:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cf == 1:",
      "mutated_line": "if cf == -1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == -1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) - f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) - f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) * f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) * f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) - f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) - f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) * f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) * f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif cf == 1:",
      "mutated_line": "elif cf == 2:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 2:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif cf == 1:",
      "mutated_line": "elif cf == 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 0:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif cf == 1:",
      "mutated_line": "elif cf == 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 0:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif cf == 1:",
      "mutated_line": "elif cf == -1:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == -1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) - f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) - f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) * f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) * f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) - f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) - f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) * f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) * f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 1 and cb == 0 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 1 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == -1 and cb == 0 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == -1 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 1 and cb == 0 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 1 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb == 1 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 1 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb == -1 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == -1 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb == 1 and (cf == 0):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 1 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb == 0 and (cf == 1):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 1):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb == 0 and (cf == -1):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == -1):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if ca == 0 and cb == 0 and (cf == 0):",
      "mutated_line": "if ca == 0 and cb == 0 and (cf == 1):",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 1):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + ' ' + str(cb) - ' ' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) - ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = (str(ca) + ' ' + str(cb)) * ' ' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = (str(ca) + ' ' + str(cb)) * ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 2 << i > 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 2 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 0 << i > 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 0 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & 0 << i > 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 0 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if C & 1 << i > 0:",
      "mutated_line": "if C & -1 << i > 0:",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & -1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 3)) + 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 3)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 1)) + 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 1)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 0)) + 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 0)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, 1)) + 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 1)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "n = int(math.log(C, 2)) + 1",
      "mutated_line": "n = int(math.log(C, -2)) + 1",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, -2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + ' ' - str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' - str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = (str(ca) + ' ') * str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = (str(ca) + ' ') * str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + ' ' + str(cb) + '' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + '' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i - 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i - 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i * 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i * 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, -1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, -1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca + 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca + 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca * 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca * 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb + 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb + 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb * 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb * 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i - 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i - 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i * 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i * 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 2, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 2, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, -1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, -1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca + 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca + 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca * 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca * 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i - 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i - 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i * 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i * 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, -1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, -1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb + 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb + 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb * 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb * 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i - 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i - 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i * 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i * 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, -1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, -1, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca + 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca + 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca * 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca * 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i - 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i - 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i * 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i * 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 2, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 2, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, -1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, -1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb + 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb + 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb * 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb * 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i - 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i - 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i * 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i * 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 2, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 2, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, -1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, -1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i - 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i - 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i * 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i * 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, -1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, -1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 1, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca + 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca + 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca * 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca * 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb + 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb + 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb * 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb * 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i - 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i - 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i * 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i * 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 2, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 2, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 0, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, -1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, -1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) - ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) - ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) * ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) * ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 2, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 2, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + -1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + -1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 2, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 2, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - -1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - -1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 2, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 2, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - -1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - -1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 2, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 2, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + -1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + -1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 2, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 2, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 0, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 0, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 0, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 0, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - -1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - -1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 2, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 2, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 0, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 0, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 0, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 0, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + -1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + -1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 2, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 2, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 0, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 0, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 0, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 0, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - -1, i + 1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - -1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 2, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 2, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 0, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 0, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 0, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 0, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + -1, 0, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + -1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 2, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 2, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 0, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 0, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 0, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 0, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - -1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - -1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 2, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 2, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 0, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 0, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 0, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 0, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + -1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + -1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 2, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 2, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 0, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 0, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 0, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 0, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - -1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - -1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 2, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 2, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 0, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 0, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + -1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + -1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 2, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 2, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 0, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + -1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + -1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 2, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 2, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 0, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - -1, cb - 1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - -1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 2, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 2, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 0, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - -1, i + 1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - -1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 2, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 2, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 0, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)",
      "mutated_line": "dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + -1, 1, C, n, dp)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + -1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "st = str(ca) + ' ' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "mutated_line": "st = str(ca) + '' + str(cb) + ' ' + str(cf) + ' ' + str(i)",
      "code": "import math\n\ndef csb(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef f(ca, cb, i, cf, C, n, dp):\n    if ca < 0 or cb < 0:\n        return 0\n    if i == n:\n        if ca == 0 and cb == 0 and (cf == 0):\n            return 1\n        return 0\n    st = str(ca) + '' + str(cb) + ' ' + str(cf) + ' ' + str(i)\n    if dp.get(st) != None:\n        return dp[st]\n    x = 0\n    if C & 1 << i > 0:\n        x = 1\n    if x == 1:\n        if cf == 1:\n            dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n        else:\n            dp[st] = f(ca - 1, cb, i + 1, 0, C, n, dp) + f(ca, cb - 1, i + 1, 0, C, n, dp)\n    elif cf == 1:\n        dp[st] = f(ca - 1, cb, i + 1, 1, C, n, dp) + f(ca, cb - 1, i + 1, 1, C, n, dp)\n    else:\n        dp[st] = f(ca, cb, i + 1, 0, C, n, dp) + f(ca - 1, cb - 1, i + 1, 1, C, n, dp)\n    return dp[st]\n\ndef count_bit_shuffle_ways(A, B, C):\n    n = int(math.log(C, 2)) + 1\n    dp = {}\n    return f(csb(A), csb(B), 0, 0, C, n, dp)"
    }
  ]
}