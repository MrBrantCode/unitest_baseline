{
  "task_id": "taco_16727",
  "entry_point": "sum_of_powers_modulo",
  "mutant_count": 142,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 2 - 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 - 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 2 * 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 * 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] / 10 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] / 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] + 10 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] + 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] ** 10 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] ** 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = [0] * r",
      "mutated_line": "s = [0] / r",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] / r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = [0] * r",
      "mutated_line": "s = [0] + r",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] + r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = [0] * r",
      "mutated_line": "s = [0] ** r",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] ** r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return s[k] % p",
      "mutated_line": "return s[k] * p",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] * p"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return s[k] % p",
      "mutated_line": "return s[k] + p",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] + p"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 * 2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 * 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 + 2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 + 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 2 + 6",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 6\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 2 + 4",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 4\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 2 + 0",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 0\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 2 + 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 1\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 2 + -5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + -5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * (10 * 5)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * (10 * 5)\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * (10 + 5)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * (10 + 5)\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k - 1):",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k - 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k * 1):",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k * 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 1) + 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) + 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 1) * 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) * 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans += d[(j + 1) * r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans += d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans / (j + 1)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans / (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans * (j + 1)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans * (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 11 ** 2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 11 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 9 ** 2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 9 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 0 ** 2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 0 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 1 ** 2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 1 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = -10 ** 2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = -10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 3 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 3 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 1 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 1 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 0 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 0 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** 1 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 1 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "r = 10 ** 2 + 5",
      "mutated_line": "r = 10 ** -2 + 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** -2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [1] * 10 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [1] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [-1] * 10 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [-1] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [1] * 10 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [1] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 11 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 11 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 9 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 9 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 0 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 0 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 1 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 1 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * -10 ** 5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * -10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 10 ** 6",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 6\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 10 ** 4",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 4\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 10 ** 0",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 0\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 10 ** 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 1\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [0] * (10 ** 5)",
      "mutated_line": "d = [0] * 10 ** -5",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** -5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = [0] * r",
      "mutated_line": "s = [1] * r",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [1] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = [0] * r",
      "mutated_line": "s = [-1] * r",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [-1] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = [0] * r",
      "mutated_line": "s = [1] * r",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [1] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if j == k_inner or k_inner == 0:",
      "mutated_line": "if j == k_inner and k_inner == 0:",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner and k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 2):",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 2):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 0):",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 0):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + 0):",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 0):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(k + 1):",
      "mutated_line": "for j in range(k + -1):",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + -1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 1) - 2",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 2\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 1) - 0",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 0\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 1) - 0",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 0\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 1) - -1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - -1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 1) * r + k_inner] / s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] / s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 1) * r + k_inner] + s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] + s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 1) * r + k_inner] ** s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] ** s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans // (j - 1)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j - 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans // (j * 1)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j * 1)\n    return s[k] % p"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if j == k_inner or k_inner == 0:",
      "mutated_line": "if j != k_inner or k_inner == 0:",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j != k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if j == k_inner or k_inner == 0:",
      "mutated_line": "if j == k_inner or k_inner != 0:",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner != 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j * r + k_inner] = 2",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 2\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j * r + k_inner] = 0",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 0\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j * r + k_inner] = 0",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 0\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j * r + k_inner] = -1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = -1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] - d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] - d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] * d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] * d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n - 1, j + 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n - 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n * 1, j + 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n * 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j - 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j - 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j * 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j * 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans // (j + 2)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 2)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans // (j + 0)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 0)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans // (j + 0)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 0)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "s[j] = ans // (j + 1)",
      "mutated_line": "s[j] = ans // (j + -1)",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + -1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if j == k_inner or k_inner == 0:",
      "mutated_line": "if j == k_inner or k_inner == 1:",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 1:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if j == k_inner or k_inner == 0:",
      "mutated_line": "if j == k_inner or k_inner == -1:",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == -1:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if j == k_inner or k_inner == 0:",
      "mutated_line": "if j == k_inner or k_inner == 1:",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 1:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j * r - k_inner] = 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r - k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j * r * k_inner] = 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r * k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r - k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r - k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r * k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r * k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 2, j + 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 2, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 0, j + 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 0, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 0, j + 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 0, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + -1, j + 1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + -1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 2) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 2) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 0) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 0) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + 0) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 0) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = pow(n + 1, j + 1) - 1",
      "mutated_line": "ans = pow(n + 1, j + -1) - 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + -1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 1) * r - k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r - k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 1) * r * k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r * k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j / r + k_inner] = 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j / r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j + r + k_inner] = 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j + r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "d[j * r + k_inner] = 1",
      "mutated_line": "d[j ** r + k_inner] = 1",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j ** r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j / r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j / r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j + r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j + r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j ** r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j ** r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner + 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner + 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[((j - 1) * r + k_inner) * 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[((j - 1) * r + k_inner) * 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r - k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r - k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r * k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r * k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 1) / r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) / r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[j + 1 + r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[j + 1 + r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 1) ** r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) ** r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r - k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r - k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r * k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r * k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 2] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 2] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 0] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 0] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 0] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 0] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - -1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - -1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) / r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) / r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[j - 1 + r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[j - 1 + r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) ** r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) ** r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j - 1) * r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j - 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[j * 1 * r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[j * 1 * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) / r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) / r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[j - 1 + r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[j - 1 + r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) ** r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) ** r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j + 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j + 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[j * 1 * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[j * 1 * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 2) * r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 2) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 0) * r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 0) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + 0) * r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 0) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans -= d[(j + 1) * r + k_inner] * s[k_inner]",
      "mutated_line": "ans -= d[(j + -1) * r + k_inner] * s[k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + -1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j + 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j + 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[j * 1 * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[j * 1 * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 2) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 2) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 0) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 0) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 0) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 0) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - -1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - -1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 2) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 2) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 0) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 0) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - 0) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - 0) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[j * r + k_inner] = d[(j - 1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "mutated_line": "d[j * r + k_inner] = d[(j - -1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]",
      "code": "def sum_of_powers_modulo(n: int, k: int, p: int) -> int:\n    r = 10 ** 2 + 5\n    d = [0] * 10 ** 5\n    s = [0] * r\n    for j in range(r):\n        for k_inner in range(r):\n            if j == k_inner or k_inner == 0:\n                d[j * r + k_inner] = 1\n            else:\n                d[j * r + k_inner] = d[(j - -1) * r + k_inner - 1] + d[(j - 1) * r + k_inner]\n    for j in range(k + 1):\n        ans = pow(n + 1, j + 1) - 1\n        for k_inner in range(j):\n            ans -= d[(j + 1) * r + k_inner] * s[k_inner]\n        s[j] = ans // (j + 1)\n    return s[k] % p"
    }
  ]
}