{
  "task_id": "taco_2509",
  "entry_point": "lexComp",
  "mutant_count": 325,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if a[0] != b[0]:",
      "mutated_line": "if a[0] == b[0]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] == b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[1] == b[1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] == b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 1\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return -1\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 1\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) + (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) + (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) * ((b[1] - a[1]) * (c[0] - b[0]))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) * ((b[1] - a[1]) * (c[0] - b[0]))\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 - (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 - (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 * (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 * (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 1\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "start = 0",
      "mutated_line": "start = -1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = -1\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 1\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) / (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) / (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return b[0] - a[0] + (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return b[0] - a[0] + (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) ** (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) ** (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) / (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) / (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1] + (c[0] - b[0]))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1] + (c[0] - b[0]))\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) ** (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) ** (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) * 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) * 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return a[0] - b[0] + 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return a[0] - b[0] + 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) * 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) * 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1] + 2)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1] + 2)\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, len(points)):",
      "mutated_line": "for i in range(2, len(points)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(2, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, len(points)):",
      "mutated_line": "for i in range(0, len(points)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(0, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, len(points)):",
      "mutated_line": "for i in range(0, len(points)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(0, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, len(points)):",
      "mutated_line": "for i in range(-1, len(points)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(-1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[0], points[i]) >= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) >= 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[0], points[i]) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) <= 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[0], points[i]) != 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) != 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 or turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 or turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(1, len(hull)):",
      "mutated_line": "for i in range(2, len(hull)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(2, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(1, len(hull)):",
      "mutated_line": "for i in range(0, len(hull)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(0, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(1, len(hull)):",
      "mutated_line": "for i in range(0, len(hull)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(0, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(1, len(hull)):",
      "mutated_line": "for i in range(-1, len(hull)):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(-1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if lexComp(hull[i], hull[start]) < 0:",
      "mutated_line": "if lexComp(hull[i], hull[start]) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) <= 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if lexComp(hull[i], hull[start]) < 0:",
      "mutated_line": "if lexComp(hull[i], hull[start]) >= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) >= 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if lexComp(hull[i], hull[start]) < 0:",
      "mutated_line": "if lexComp(hull[i], hull[start]) != 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) != 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a[0] != b[0]:",
      "mutated_line": "if a[1] != b[0]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[1] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a[0] != b[0]:",
      "mutated_line": "if a[-1] != b[0]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[-1] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a[0] != b[0]:",
      "mutated_line": "if a[1] != b[0]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[1] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a[0] != b[0]:",
      "mutated_line": "if a[0] != b[1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[1]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a[0] != b[0]:",
      "mutated_line": "if a[0] != b[-1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[-1]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a[0] != b[0]:",
      "mutated_line": "if a[0] != b[1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[1]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] <= b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] <= b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] >= b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] >= b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] != b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] != b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return +1 if a[0] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return +1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] < b[0] else 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 2\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] < b[0] else 0",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 0\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] < b[0] else 0",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 0\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] < b[0] else -1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else -1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[2] != b[1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[2] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[0] != b[1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[0] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[0] != b[1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[0] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[-1] != b[1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[-1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[1] != b[2]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[2]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[1] != b[0]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[0]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[1] != b[0]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[0]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if a[1] != b[1]:",
      "mutated_line": "if a[1] != b[-1]:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[-1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] <= b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] <= b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] >= b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] >= b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] != b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] != b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return +1 if a[1] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return +1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[1] else 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 2\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[1] else 0",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 0\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[1] else 0",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 0\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[1] else -1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else -1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] + a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] + a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return b[0] * a[0] * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return b[0] * a[0] * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] + b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] + b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] * b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] * b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] + a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] + a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - b[1] * a[1] * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - b[1] * a[1] * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] + b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] + b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] * b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] * b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] + b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] + b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] * b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] * b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 3 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 3 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 1 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 1 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 0 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 0 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 1 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 1 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** -2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** -2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] + b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] + b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] * b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] * b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 3",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 3\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 1\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 0",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 0\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 1\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** -2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** -2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if contamination_levels[i][j] == 1:",
      "mutated_line": "if contamination_levels[i][j] != 1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] != 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[0], points[i]) > 1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 1:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[0], points[i]) > -1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > -1:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[0], points[i]) > 1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 1:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[2:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[2:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[0:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[0:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[0:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[0:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[-1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[-1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) > 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) > 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) < 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) < 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) == 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) == 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) < 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) < 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) > 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) == 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) == 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[1], n + p[0]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n + p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[1], n * p[0]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n * p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "hull = hull[::-1]",
      "mutated_line": "hull = hull[::+1]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::+1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if lexComp(hull[i], hull[start]) < 0:",
      "mutated_line": "if lexComp(hull[i], hull[start]) < 1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 1:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if lexComp(hull[i], hull[start]) < 0:",
      "mutated_line": "if lexComp(hull[i], hull[start]) < -1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < -1:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if lexComp(hull[i], hull[start]) < 0:",
      "mutated_line": "if lexComp(hull[i], hull[start]) < 1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 1:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -2 if a[0] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -2 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -0 if a[0] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -0 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -0 if a[0] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -0 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return --1 if a[0] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return --1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -2 if a[1] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -2 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -0 if a[1] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -0 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -0 if a[1] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -0 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return --1 if a[1] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return --1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if contamination_levels[i][j] == 1:",
      "mutated_line": "if contamination_levels[i][j] == 2:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 2:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if contamination_levels[i][j] == 1:",
      "mutated_line": "if contamination_levels[i][j] == 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 0:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if contamination_levels[i][j] == 1:",
      "mutated_line": "if contamination_levels[i][j] == 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 0:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if contamination_levels[i][j] == 1:",
      "mutated_line": "if contamination_levels[i][j] == -1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == -1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[2:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[2:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[0:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[0:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[0:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[0:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[-1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[-1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 3 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 3 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 1 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 1 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 0 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 0 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 1 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 1 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= -2 and turn(hull[-2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= -2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 1:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= -1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= -1:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 1:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 1:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[2], n - p[0]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[2], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[0], n - p[0]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[0], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[0], n - p[0]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[0], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[-1], n - p[0]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[-1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "hull = hull[::-1]",
      "mutated_line": "hull = hull[::-2]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-2]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "hull = hull[::-1]",
      "mutated_line": "hull = hull[::-0]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-0]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "hull = hull[::-1]",
      "mutated_line": "hull = hull[::-0]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-0]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "hull = hull[::-1]",
      "mutated_line": "hull = hull[::--1]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::--1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[1] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[1] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[-1] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[-1] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[1] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[1] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[1] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] < b[-1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[-1] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1 if a[0] < b[0] else 1",
      "mutated_line": "return -1 if a[0] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[1] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[2] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[2] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[0] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[0] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[0] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[0] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[-1] < b[1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[-1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[2] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[2] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[0] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[0] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[0] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1 if a[1] < b[1] else 1",
      "mutated_line": "return -1 if a[1] < b[-1] else 1",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[-1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[1] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[1] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[-1] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[-1] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[1] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[1] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[1]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[1]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[-1]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[-1]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[1]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[1]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[2] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[2] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[0] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[0] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[0] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[0] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[-1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[-1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[2]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[2]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[0]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[0]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[0]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[0]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[-1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[-1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[2] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[2] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[0] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[0] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[0] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[0] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[-1] - a[1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[-1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[2]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[2]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[0]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[0]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[0]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[0]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[-1]) * (c[0] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[-1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[1] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[1] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[-1] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[-1] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[1] - b[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[1] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[1])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[-1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[-1])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])",
      "mutated_line": "return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[1])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[1] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[1] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[-1] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[-1] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[1] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[1] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[1]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[1]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[-1]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[-1]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[1]) ** 2 + (a[1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[1]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[2] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[2] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[0] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[0] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[0] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[0] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[-1] - b[1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[-1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[2]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[2]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[0]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[0]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[0]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[0]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2",
      "mutated_line": "return (a[0] - b[0]) ** 2 + (a[1] - b[-1]) ** 2",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[-1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(1, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(-1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(-1, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(1, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(0, 3):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 3):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 1):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(0, 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 0):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 1):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx in range(0, 2):",
      "mutated_line": "for dx in range(0, -2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, -2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[1], points[i]) > 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[1], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[-1], points[i]) > 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[-1], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if lexComp(points[0], points[i]) > 0:",
      "mutated_line": "if lexComp(points[1], points[i]) > 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[1], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(points[0], points[i]) = (points[i], points[0])",
      "mutated_line": "(points[1], points[i]) = (points[i], points[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[1], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(points[0], points[i]) = (points[i], points[0])",
      "mutated_line": "(points[-1], points[i]) = (points[i], points[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[-1], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(points[0], points[i]) = (points[i], points[0])",
      "mutated_line": "(points[1], points[i]) = (points[i], points[0])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[1], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(points[0], points[i]) = (points[i], points[0])",
      "mutated_line": "(points[0], points[i]) = (points[i], points[1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[1])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(points[0], points[i]) = (points[i], points[0])",
      "mutated_line": "(points[0], points[i]) = (points[i], points[-1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[-1])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(points[0], points[i]) = (points[i], points[0])",
      "mutated_line": "(points[0], points[i]) = (points[i], points[1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[1])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[1], n - p[1]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[1]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[1], n - p[-1]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[-1]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "hull = [(p[1], n - p[0]) for p in hull]",
      "mutated_line": "hull = [(p[1], n - p[1]) for p in hull]",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[1]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(1, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(-1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(-1, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(1, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(0, 3):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 3):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 1):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(0, 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 0):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 1):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dy in range(0, 2):",
      "mutated_line": "for dy in range(0, -2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, -2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ok = True",
      "mutated_line": "ok = False",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = False\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "points.append(curPoints[0])",
      "mutated_line": "points.append(curPoints[1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[1])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "points.append(curPoints[0])",
      "mutated_line": "points.append(curPoints[-1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[-1])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "points.append(curPoints[0])",
      "mutated_line": "points.append(curPoints[1])",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[1])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] + points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] + points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] * points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] * points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] + points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] + points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] * points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] * points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[+2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[+2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[+1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[+1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(1, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(-1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(-1, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(1, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(0, 3):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 3):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 1):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(0, 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 0):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 1):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for ddx in range(0, 2):",
      "mutated_line": "for ddx in range(0, -2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, -2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[1])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[1])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[-1])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[-1])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[1])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[1])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-3], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-3], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-1], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-1], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-0], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-0], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-1], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-1], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[--2], hull[-1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[--2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-2], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-2], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-0], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-0], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[-0], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-0], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:",
      "mutated_line": "while len(hull) >= 2 and turn(hull[-2], hull[--1], p) <= 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[--1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(1, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(-1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(-1, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(1, 2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(1, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(0, 3):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 3):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 1):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(0, 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 0):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(0, 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 1):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ddy in range(0, 2):",
      "mutated_line": "for ddy in range(0, -2):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, -2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n or 0 <= y < n or contamination_levels[x][y] == 0:",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n or 0 <= y < n or contamination_levels[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[2] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[2] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[0] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[0] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[0] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[0] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[-1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[-1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][2], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][2], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][0], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][0], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][0], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][0], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][-1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][-1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[1] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[1] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[-1] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[-1] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[1] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[1] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][1]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][1]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][-1]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][-1]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][1]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][1]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx - ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx - ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = ((i - 1 + dx) * ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = ((i - 1 + dx) * ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy - ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy - ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, (j - 1 + dy) * ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, (j - 1 + dy) * ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 < x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 < x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 > x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 > x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 == x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 == x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 0 < y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 < y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 0 > y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 > y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 0 == y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 == y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] != 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] != 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok = False",
      "mutated_line": "ok = True",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = True\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "curPoints.append((i + dx, j + dy))",
      "mutated_line": "curPoints.append((i - dx, j + dy))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i - dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "curPoints.append((i + dx, j + dy))",
      "mutated_line": "curPoints.append((i * dx, j + dy))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i * dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "curPoints.append((i + dx, j + dy))",
      "mutated_line": "curPoints.append((i + dx, j - dy))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j - dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "curPoints.append((i + dx, j + dy))",
      "mutated_line": "curPoints.append((i + dx, j * dy))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j * dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[1][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[1][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[-1][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[-1][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[1][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[1][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[1][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[1][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[-1][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[-1][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))",
      "mutated_line": "points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[1][0]), dist2(p, points[0])))",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[1][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 - dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 - dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = ((i - 1) * dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = ((i - 1) * dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j - 1 - dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 - dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, (j - 1) * dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, (j - 1) * dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 1 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 1 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if -1 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if -1 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 1 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 1 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 1 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 1 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and -1 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and -1 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 1 <= y < n and (contamination_levels[x][y] == 0):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 1 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 1):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == -1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == -1):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):",
      "mutated_line": "if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 1):",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 1):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i + 1 + dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i + 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i * 1 + dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i * 1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j + 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j + 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j * 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j * 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 2 + dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 2 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 0 + dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 0 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 0 + dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 0 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - -1 + dx + ddx, j - 1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - -1 + dx + ddx, j - 1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j - 2 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 2 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j - 0 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 0 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j - 0 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - 0 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(x, y) = (i - 1 + dx + ddx, j - 1 + dy + ddy)",
      "mutated_line": "(x, y) = (i - 1 + dx + ddx, j - -1 + dy + ddy)",
      "code": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n\ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef find_zombie_lair_vertices(n, contamination_levels):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if contamination_levels[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                (x, y) = (i - 1 + dx + ddx, j - -1 + dy + ddy)\n                                if 0 <= x < n and 0 <= y < n and (contamination_levels[x][y] == 0):\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            (points[0], points[i]) = (points[i], points[0])\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    V = len(hull)\n    vertices = hull\n    return (V, vertices)"
    }
  ]
}