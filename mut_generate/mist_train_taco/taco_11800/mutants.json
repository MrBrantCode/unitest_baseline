{
  "task_id": "taco_11800",
  "entry_point": "can_divide_dominoes",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return False\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = False\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if node in dic:",
      "mutated_line": "if node not in dic:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node not in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if x == y:",
      "mutated_line": "if x != y:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x != y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [0] / n",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] / n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [0] + n",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] + n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [0] ** n",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] ** n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = False\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited[node - 1] = color",
      "mutated_line": "visited[node + 1] = color",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node + 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "visited[node - 1] = color",
      "mutated_line": "visited[node * 1] = color",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node * 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = True\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x not in dic:",
      "mutated_line": "if x in dic:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if y not in dic:",
      "mutated_line": "if y in dic:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 and len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 and len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append('NO')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(2, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(0, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(0, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(-1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n - 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n * 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - 1] != 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] != 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited[node - 1] = color",
      "mutated_line": "visited[node - 2] = color",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 2] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited[node - 1] = color",
      "mutated_line": "visited[node - 0] = color",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 0] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited[node - 1] = color",
      "mutated_line": "visited[node - 0] = color",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 0] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited[node - 1] = color",
      "mutated_line": "visited[node - -1] = color",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - -1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - 1] != 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] != 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) >= 2 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) >= 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) <= 2 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) <= 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) != 2 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) != 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) >= 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) >= 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) <= 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) <= 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) != 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) != 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = True\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [1] * n",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [1] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [-1] * n",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [-1] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [1] * n",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [1] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 2):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 0):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 0):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + -1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - 1] == 1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 1:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - 1] == -1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == -1:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - 1] == 1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 1:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "results.append('YES')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "results.append('NO')",
      "mutated_line": "results.append('')",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - 1] == 1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 1:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - 1] == -1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == -1:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - 1] == 1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 1:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent or visited[nbr - 1] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent or visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 3 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 3 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 1 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 1 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 0 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 0 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 1 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 1 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > -2 or len(dic[y]) > 2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > -2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) > 3:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 3:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) > 1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 1:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) > 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 0:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) > 1:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 1:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(dic[x]) > 2 or len(dic[y]) > 2:",
      "mutated_line": "if len(dic[x]) > 2 or len(dic[y]) > -2:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > -2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i + 1] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i + 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i * 1] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i * 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = True\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr + 1] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr + 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr * 1] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr * 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr == parent and visited[nbr - 1] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr == parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent and visited[nbr - 1] != color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] != color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return True\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - 2] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 2] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - 0] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 0] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - 0] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 0] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if visited[i - 1] == 0:",
      "mutated_line": "if visited[i - -1] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - -1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, +1, 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, +1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, -1, 2):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 2):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, -1, 0):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 0):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, -1, 0):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 0):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, -1, -1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, -1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - 2] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 2] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - 0] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 0] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - 0] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 0] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if visited[nbr - 1] == 0:",
      "mutated_line": "if visited[nbr - -1] == 0:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - -1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "queue.append([nbr, node, 3 - color])",
      "mutated_line": "queue.append([nbr, node, 3 + color])",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 + color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "queue.append([nbr, node, 3 - color])",
      "mutated_line": "queue.append([nbr, node, 3 * color])",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 * color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, -2, 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -2, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, -0, 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -0, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, -0, 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -0, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if not bfs(i, -1, 1):",
      "mutated_line": "if not bfs(i, --1, 1):",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, --1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append([nbr, node, 3 - color])",
      "mutated_line": "queue.append([nbr, node, 4 - color])",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 4 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append([nbr, node, 3 - color])",
      "mutated_line": "queue.append([nbr, node, 2 - color])",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 2 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append([nbr, node, 3 - color])",
      "mutated_line": "queue.append([nbr, node, 0 - color])",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 0 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append([nbr, node, 3 - color])",
      "mutated_line": "queue.append([nbr, node, 1 - color])",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 1 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append([nbr, node, 3 - color])",
      "mutated_line": "queue.append([nbr, node, -3 - color])",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, -3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent and visited[nbr + 1] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr + 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent and visited[nbr * 1] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr * 1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent and visited[nbr - 2] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 2] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent and visited[nbr - 0] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 0] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent and visited[nbr - 0] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 0] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif nbr != parent and visited[nbr - 1] == color:",
      "mutated_line": "elif nbr != parent and visited[nbr - -1] == color:",
      "code": "from collections import deque\n\ndef can_divide_dominoes(test_cases):\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - -1] == color:\n                        return False\n        return True\n    results = []\n    for (n, dominoes) in test_cases:\n        dic = {}\n        flag = True\n        for (x, y) in dominoes:\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            results.append('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    }
  ]
}