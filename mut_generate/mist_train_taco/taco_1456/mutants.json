{
  "task_id": "taco_1456",
  "entry_point": "min_absolute_difference_modulo",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 - 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 * 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if p == 1:",
      "mutated_line": "if p != 1:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p != 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "mutated_line": "right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) * MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) * MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "mutated_line": "right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) + MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) + MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "mutated_line": "left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) * MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) * MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "mutated_line": "left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) + MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) + MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (left_sum - right_sum) % MOD",
      "mutated_line": "return (left_sum - right_sum) * MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (left_sum - right_sum) % MOD",
      "mutated_line": "return left_sum - right_sum + MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return left_sum - right_sum + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 * 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 + 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 8\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 6\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 0\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 1\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + -7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if p == 1:",
      "mutated_line": "if p == 2:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 2:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if p == 1:",
      "mutated_line": "if p == 0:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 0:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if p == 1:",
      "mutated_line": "if p == 0:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 0:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if p == 1:",
      "mutated_line": "if p == -1:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == -1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return len(k_list) % 2",
      "mutated_line": "return len(k_list) * 2",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) * 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return len(k_list) % 2",
      "mutated_line": "return len(k_list) + 2",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) + 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "left[k] += 1",
      "mutated_line": "left[k] -= 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] -= 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "right[k] += 1",
      "mutated_line": "right[k] -= 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] -= 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (left_sum - right_sum) % MOD",
      "mutated_line": "return (left_sum + right_sum) % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum + right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return (left_sum - right_sum) % MOD",
      "mutated_line": "return left_sum * right_sum % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return left_sum * right_sum % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 11 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 9 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 0 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 1 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = -10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 10 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 8 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 0 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 1 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** -9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return len(k_list) % 2",
      "mutated_line": "return len(k_list) % 3",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 3\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return len(k_list) % 2",
      "mutated_line": "return len(k_list) % 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 1\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return len(k_list) % 2",
      "mutated_line": "return len(k_list) % 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 0\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return len(k_list) % 2",
      "mutated_line": "return len(k_list) % 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 1\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return len(k_list) % 2",
      "mutated_line": "return len(k_list) % -2",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % -2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "k_list.sort(reverse=True)",
      "mutated_line": "k_list.sort(reverse=False)",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=False)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left[k] += 1",
      "mutated_line": "left[k] += 2",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 2\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left[k] += 1",
      "mutated_line": "left[k] += 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 0\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left[k] += 1",
      "mutated_line": "left[k] += 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 0\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left[k] += 1",
      "mutated_line": "left[k] += -1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += -1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k in left:",
      "mutated_line": "if k not in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k not in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[k] += 1",
      "mutated_line": "right[k] += 2",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 2\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[k] += 1",
      "mutated_line": "right[k] += 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 0\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[k] += 1",
      "mutated_line": "right[k] += 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 0\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right[k] += 1",
      "mutated_line": "right[k] += -1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += -1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while False:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "right[k + 1] += q",
      "mutated_line": "right[k + 1] -= q",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] -= q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k -= 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if q == 0:",
      "mutated_line": "if q != 0:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q != 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k + 1 in left:",
      "mutated_line": "if k + 1 not in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 not in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 2\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 0\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 0\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += -1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "mutated_line": "right_sum = sum((v / pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v / pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "mutated_line": "right_sum = sum((v + pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v + pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "mutated_line": "right_sum = sum((v ** pow(p, k, MOD) for (k, v) in right.items())) % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v ** pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "mutated_line": "left_sum = sum((v / pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v / pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "mutated_line": "left_sum = sum((v + pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v + pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "mutated_line": "left_sum = sum((v ** pow(p, k, MOD) for (k, v) in left.items())) % MOD",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v ** pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "right[k + 1] += q",
      "mutated_line": "right[k - 1] += q",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k - 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "right[k + 1] += q",
      "mutated_line": "right[k * 1] += q",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k * 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if q == 0:",
      "mutated_line": "if q == 1:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 1:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if q == 0:",
      "mutated_line": "if q == -1:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == -1:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if q == 0:",
      "mutated_line": "if q == 1:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 1:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k + 1 in left:",
      "mutated_line": "if k - 1 in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k - 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k + 1 in left:",
      "mutated_line": "if k * 1 in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k * 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 1] != 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] != 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right[k + 1] += q",
      "mutated_line": "right[k + 2] += q",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 2] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right[k + 1] += q",
      "mutated_line": "right[k + 0] += q",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 0] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right[k + 1] += q",
      "mutated_line": "right[k + 0] += q",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 0] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "right[k + 1] += q",
      "mutated_line": "right[k + -1] += q",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + -1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 in left:",
      "mutated_line": "if k + 2 in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 2 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 in left:",
      "mutated_line": "if k + 0 in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 0 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 in left:",
      "mutated_line": "if k + 0 in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 0 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k + 1 in left:",
      "mutated_line": "if k + -1 in left:",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + -1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 1] == 2",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 2\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 1] == 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 0\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 1] == 0",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 0\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 1] == -1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == -1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "del left[k + 1]",
      "mutated_line": "del left[k - 1]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k - 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "del left[k + 1]",
      "mutated_line": "del left[k * 1]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k * 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "del right[k + 1]",
      "mutated_line": "del right[k - 1]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k - 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "del right[k + 1]",
      "mutated_line": "del right[k * 1]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k * 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k - 1] == 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k - 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k * 1] == 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k * 1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "del left[k + 1]",
      "mutated_line": "del left[k + 2]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 2]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "del left[k + 1]",
      "mutated_line": "del left[k + 0]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 0]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "del left[k + 1]",
      "mutated_line": "del left[k + 0]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 0]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "del left[k + 1]",
      "mutated_line": "del left[k + -1]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + -1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "del right[k + 1]",
      "mutated_line": "del right[k + 2]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 2]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "del right[k + 1]",
      "mutated_line": "del right[k + 0]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 0]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "del right[k + 1]",
      "mutated_line": "del right[k + 0]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + 0]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "del right[k + 1]",
      "mutated_line": "del right[k + -1]",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 1] == 1\n                    del left[k + 1]\n                    del right[k + -1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 2] == 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 2] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 0] == 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 0] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + 0] == 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + 0] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "assert right[k + 1] == 1",
      "mutated_line": "assert right[k + -1] == 1",
      "code": "def min_absolute_difference_modulo(n, p, k_list):\n    MOD = 10 ** 9 + 7\n    if p == 1:\n        return len(k_list) % 2\n    k_list.sort(reverse=True)\n    left = Counter()\n    right = Counter()\n    for k in k_list:\n        if not left:\n            left[k] += 1\n        else:\n            if k in left:\n                del left[k]\n                continue\n            right[k] += 1\n            while True:\n                (q, r) = divmod(right[k], p)\n                right[k] = r\n                right[k + 1] += q\n                if q == 0:\n                    break\n                if k + 1 in left:\n                    assert right[k + -1] == 1\n                    del left[k + 1]\n                    del right[k + 1]\n                    break\n                k += 1\n    right_sum = sum((v * pow(p, k, MOD) for (k, v) in right.items())) % MOD\n    if not left:\n        return right_sum\n    left_sum = sum((v * pow(p, k, MOD) for (k, v) in left.items())) % MOD\n    return (left_sum - right_sum) % MOD"
    }
  ]
}