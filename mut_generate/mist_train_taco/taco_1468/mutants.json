{
  "task_id": "taco_1468",
  "entry_point": "max_points_in_circle",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 2\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 0\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 0\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = -1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 1",
      "mutated_line": "val = 2",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 2\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 1",
      "mutated_line": "val = 0",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 0\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 1",
      "mutated_line": "val = 0",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 0\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 1",
      "mutated_line": "val = -1",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = -1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 - (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 - (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 * (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 * (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) or (d := distance(x1, y1, x, y)) <= 2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) or (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) * 2 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) * 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt(x1 - x2 + 2 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt(x1 - x2 + 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) * 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) * 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2 + 2))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2 + 2))\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x and y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x and y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) < 2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) < 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) > 2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) > 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) == 2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) == 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 + x2) ** 2 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 + x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 * x2) ** 2 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 * x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 3 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 3 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 0 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 0 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** -2 + (y1 - y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** -2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 + y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 + y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 * y2) ** 2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 * y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 3)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 3)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 0)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 0)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** -2)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** -2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 == x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 == x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 == y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 == y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 / r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 / r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 + r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 + r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 ** r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 ** r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "angle = math.atan2(y1 - y, x1 - x)",
      "mutated_line": "angle = math.atan2(y1 + y, x1 - x)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 + y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "angle = math.atan2(y1 - y, x1 - x)",
      "mutated_line": "angle = math.atan2(y1 * y, x1 - x)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 * y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "angle = math.atan2(y1 - y, x1 - x)",
      "mutated_line": "angle = math.atan2(y1 - y, x1 + x)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 + x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "angle = math.atan2(y1 - y, x1 - x)",
      "mutated_line": "angle = math.atan2(y1 - y, x1 * x)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 * x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d * (2 * r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d * (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d // (2 * r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d // (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans = max(ans, (val := (val + entry)))",
      "mutated_line": "ans = max(ans, (val := (val - entry)))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val - entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans = max(ans, (val := (val + entry)))",
      "mutated_line": "ans = max(ans, (val := (val * entry)))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val * entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 3 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 3 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 1 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 1 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 0 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 0 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 1 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 1 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:",
      "mutated_line": "if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= -2 * r:",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= -2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / (2 / r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 / r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / (2 + r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 + r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / 2 ** r)",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / 2 ** r)\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "angles.append((angle - delta, +1))",
      "mutated_line": "angles.append((angle + delta, +1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle + delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "angles.append((angle - delta, +1))",
      "mutated_line": "angles.append((angle * delta, +1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle * delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "angles.append((angle - delta, +1))",
      "mutated_line": "angles.append((angle - delta, -1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, -1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "angles.append((angle + delta, -1))",
      "mutated_line": "angles.append((angle - delta, -1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle - delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "angles.append((angle + delta, -1))",
      "mutated_line": "angles.append((angle * delta, -1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle * delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "angles.append((angle + delta, -1))",
      "mutated_line": "angles.append((angle + delta, +1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, +1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[0], +x[1]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], +x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / (3 * r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (3 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / (1 * r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (1 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / (0 * r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (0 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / (1 * r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (1 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta = math.acos(d / (2 * r))",
      "mutated_line": "delta = math.acos(d / (-2 * r))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (-2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "angles.append((angle - delta, +1))",
      "mutated_line": "angles.append((angle - delta, +2))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +2))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "angles.append((angle - delta, +1))",
      "mutated_line": "angles.append((angle - delta, +0))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +0))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "angles.append((angle - delta, +1))",
      "mutated_line": "angles.append((angle - delta, +0))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +0))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "angles.append((angle - delta, +1))",
      "mutated_line": "angles.append((angle - delta, +-1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +-1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angles.append((angle + delta, -1))",
      "mutated_line": "angles.append((angle + delta, -2))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -2))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angles.append((angle + delta, -1))",
      "mutated_line": "angles.append((angle + delta, -0))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -0))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angles.append((angle + delta, -1))",
      "mutated_line": "angles.append((angle + delta, -0))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -0))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angles.append((angle + delta, -1))",
      "mutated_line": "angles.append((angle + delta, --1))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, --1))\n        angles.sort(key=lambda x: (x[0], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[1], -x[1]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[1], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[-1], -x[1]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[-1], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[1], -x[1]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[1], -x[1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[0], -x[2]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[2]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[0], -x[0]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[0]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[0], -x[0]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[0]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "angles.sort(key=lambda x: (x[0], -x[1]))",
      "mutated_line": "angles.sort(key=lambda x: (x[0], -x[-1]))",
      "code": "import math\nfrom typing import List\n\ndef max_points_in_circle(points: List[List[int]], r: int) -> int:\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    ans = 1\n    for (x, y) in points:\n        angles = []\n        for (x1, y1) in points:\n            if (x1 != x or y1 != y) and (d := distance(x1, y1, x, y)) <= 2 * r:\n                angle = math.atan2(y1 - y, x1 - x)\n                delta = math.acos(d / (2 * r))\n                angles.append((angle - delta, +1))\n                angles.append((angle + delta, -1))\n        angles.sort(key=lambda x: (x[0], -x[-1]))\n        val = 1\n        for (_, entry) in angles:\n            ans = max(ans, (val := (val + entry)))\n    return ans"
    }
  ]
}