{
  "task_id": "taco_17049",
  "entry_point": "min_operations_to_unify_tree_colors",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u += 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v += 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[0] / 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] / 2"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[0] * 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] * 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 2\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 0\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 0\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= -1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 2\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 0\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 0\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= -1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if colors[u] == colors[v]:",
      "mutated_line": "if colors[u] != colors[v]:",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] != colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "t += 1",
      "mutated_line": "t -= 1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t -= 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[0] // 3",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 3"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[0] // 1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[0] // 0",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[0] // 1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[0] // -2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // -2"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while a != dsu[a]:",
      "mutated_line": "while a == dsu[a]:",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a == dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while b != dsu[b]:",
      "mutated_line": "while b == dsu[b]:",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b == dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a < b:",
      "mutated_line": "if a <= b:",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a <= b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a < b:",
      "mutated_line": "if a >= b:",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a >= b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a < b:",
      "mutated_line": "if a != b:",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a != b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "d = {u: [] for u, v in enumerate(dsu) if u == v}",
      "mutated_line": "for (u, e) in enumerate(edges_list):",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u != v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "nxt, visited, t = [x], set(), 0",
      "mutated_line": "(nxt, visited, t) = ([x], set(), 1)",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 1)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "nxt, visited, t = [x], set(), 0",
      "mutated_line": "(nxt, visited, t) = ([x], set(), -1)",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), -1)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "nxt, visited, t = [x], set(), 0",
      "mutated_line": "(nxt, visited, t) = ([x], set(), 1)",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 1)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t += 1",
      "mutated_line": "t += 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 2\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 0\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 0\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t += 1",
      "mutated_line": "t += -1",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += -1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[1] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[-1] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[-1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[1])[1] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[1] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return t, cur[0]",
      "mutated_line": "return (t, cur[1])",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[1])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return t, cur[0]",
      "mutated_line": "return (t, cur[-1])",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[-1])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return t, cur[0]",
      "mutated_line": "return (t, cur[1])",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[1])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if y not in visited:",
      "mutated_line": "if y in visited:",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[2])[0] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[2])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[0])[0] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[0])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[0])[0] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[0])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(0)[-1])[0] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(0)[-1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(1)[1])[0] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(1)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(-1)[1])[0] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(-1)[1])[0] // 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return bfs(bfs(0)[1])[0] // 2",
      "mutated_line": "return bfs(bfs(1)[1])[0] // 2",
      "code": "def min_operations_to_unify_tree_colors(n, colors, edges):\n    dsu = list(range(n))\n    edges_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        if colors[u] == colors[v]:\n            (a, b) = (dsu[u], dsu[v])\n            while a != dsu[a]:\n                a = dsu[a]\n            while b != dsu[b]:\n                b = dsu[b]\n            if a < b:\n                dsu[b] = dsu[v] = a\n            else:\n                dsu[a] = dsu[u] = b\n        else:\n            edges_list[u].append(v)\n    for (u, v) in enumerate(dsu):\n        dsu[u] = dsu[v]\n    d = {u: [] for (u, v) in enumerate(dsu) if u == v}\n    for (u, e) in enumerate(edges_list):\n        for v in e:\n            d[dsu[u]].append(dsu[v])\n            d[dsu[v]].append(dsu[u])\n\n    def bfs(x):\n        (nxt, visited, t) = ([x], set(), 0)\n        while nxt:\n            t += 1\n            (cur, nxt) = (nxt, [])\n            for x in cur:\n                visited.add(x)\n                for y in d[x]:\n                    if y not in visited:\n                        nxt.append(y)\n        return (t, cur[0])\n    return bfs(bfs(1)[1])[0] // 2"
    }
  ]
}