{
  "task_id": "taco_4371",
  "entry_point": "count_valid_pairs",
  "mutant_count": 42,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] / (N + 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] / (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] + (N + 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] + (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] ** (N + 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] ** (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 1\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "k = 0",
      "mutated_line": "k = -1",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = -1\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 1\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "k += l[a]",
      "mutated_line": "k -= l[a]",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k -= l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] * (N - 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N - 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] * (N * 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N * 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(3, N + 1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(3, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(1, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(0, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(1, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(-2, N + 1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(-2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N - 1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N - 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N * 1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N * 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "a = M % i",
      "mutated_line": "a = M * i",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M * i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "a = M % i",
      "mutated_line": "a = M + i",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M + i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "l[j] += 1",
      "mutated_line": "l[j] -= 1",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] -= 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [2] * (N + 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [2] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [0] * (N + 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [0] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [0] * (N + 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [0] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [-1] * (N + 1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [-1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] * (N + 2)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 2)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] * (N + 0)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 0)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] * (N + 0)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 0)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [1] * (N + 1)",
      "mutated_line": "l = [1] * (N + -1)",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + -1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 2):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 2):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 0):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 0):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + -1):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + -1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(a, N + 1, i):",
      "mutated_line": "for j in range(a, N - 1, i):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N - 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(a, N + 1, i):",
      "mutated_line": "for j in range(a, N * 1, i):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N * 1, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l[j] += 1",
      "mutated_line": "l[j] += 2",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 2\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l[j] += 1",
      "mutated_line": "l[j] += 0",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 0\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l[j] += 1",
      "mutated_line": "l[j] += 0",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += 0\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l[j] += 1",
      "mutated_line": "l[j] += -1",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 1, i):\n            l[j] += -1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(a, N + 1, i):",
      "mutated_line": "for j in range(a, N + 2, i):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 2, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(a, N + 1, i):",
      "mutated_line": "for j in range(a, N + 0, i):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 0, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(a, N + 1, i):",
      "mutated_line": "for j in range(a, N + 0, i):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + 0, i):\n            l[j] += 1\n    return k"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(a, N + 1, i):",
      "mutated_line": "for j in range(a, N + -1, i):",
      "code": "def count_valid_pairs(N: int, M: int) -> int:\n    \"\"\"\n    Counts the number of ordered pairs (a, b) such that 1 ≤ a < b ≤ N and \n    ((M % a) % b) = ((M % b) % a).\n\n    Parameters:\n    N (int): The upper limit for the range of a and b.\n    M (int): The integer used in the modulo operations.\n\n    Returns:\n    int: The number of valid pairs (a, b).\n    \"\"\"\n    l = [1] * (N + 1)\n    k = 0\n    for i in range(2, N + 1):\n        a = M % i\n        k += l[a]\n        for j in range(a, N + -1, i):\n            l[j] += 1\n    return k"
    }
  ]
}