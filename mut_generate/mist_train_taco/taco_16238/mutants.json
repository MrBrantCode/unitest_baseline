{
  "task_id": "taco_16238",
  "entry_point": "find_closed_curve",
  "mutant_count": 217,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "path += P",
      "mutated_line": "path -= P",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path -= P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path -= [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path -= [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path -= P[::-1][1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path -= P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path -= [(n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path -= [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path -= make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path -= make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "is_min = A[n] == 0",
      "mutated_line": "is_min = A[n] != 0",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] != 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(nums) == 1:",
      "mutated_line": "if len(nums) != 1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) != 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path -= [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path -= [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "path += [(i, 0)]",
      "mutated_line": "path -= [(i, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path -= [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return \"Possible\", path",
      "mutated_line": "return ('', path)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('', path)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(1 << N):",
      "mutated_line": "for n in range(2 << N):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(2 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(1 << N):",
      "mutated_line": "for n in range(0 << N):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(0 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(1 << N):",
      "mutated_line": "for n in range(0 << N):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(0 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for n in range(1 << N):",
      "mutated_line": "for n in range(-1 << N):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(-1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_min = A[n] == 0",
      "mutated_line": "is_min = A[n] == 1",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 1\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_min = A[n] == 0",
      "mutated_line": "is_min = A[n] == -1",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == -1\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_min = A[n] == 0",
      "mutated_line": "is_min = A[n] == 1",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 1\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "s = s - 1 & n",
      "mutated_line": "s = s - 1 | n",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 | n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 1 or A[s] == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 or A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if A[s] == 0:",
      "mutated_line": "if A[s] != 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] != 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(nums) == 1:",
      "mutated_line": "if len(nums) == 2:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 2:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(nums) == 1:",
      "mutated_line": "if len(nums) == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 0:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(nums) == 1:",
      "mutated_line": "if len(nums) == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 0:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(nums) == 1:",
      "mutated_line": "if len(nums) == -1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == -1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "n = nums[0]",
      "mutated_line": "n = nums[1]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[1]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "n = nums[0]",
      "mutated_line": "n = nums[-1]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[-1]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "n = nums[0]",
      "mutated_line": "n = nums[1]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[1]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n - 1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n - 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n * 1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n * 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[1:], n - 1)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n - 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[1:], n * 1)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n * 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n + 1, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n + 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n * 1, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n * 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x + 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x + 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x * 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x * 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, +1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, +1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path = [(0, 0)]",
      "mutated_line": "path = [(1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(1, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path = [(0, 0)]",
      "mutated_line": "path = [(-1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(-1, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path = [(0, 0)]",
      "mutated_line": "path = [(1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(1, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path = [(0, 0)]",
      "mutated_line": "path = [(0, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 1)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path = [(0, 0)]",
      "mutated_line": "path = [(0, -1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, -1)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "path = [(0, 0)]",
      "mutated_line": "path = [(0, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 1)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "s = s - 1 & n",
      "mutated_line": "s = s + 1 & n",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s + 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "s = s - 1 & n",
      "mutated_line": "s = s * 1 & n",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s * 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] != 1 and A[s] == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] != 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 1 and A[s] != 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] != 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[s] == 0:",
      "mutated_line": "if A[s] == 1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 1:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[s] == 0:",
      "mutated_line": "if A[s] == -1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == -1:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[s] == 0:",
      "mutated_line": "if A[s] == 1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 1:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "is_min = False",
      "mutated_line": "is_min = True",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = True\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = nums[0]",
      "mutated_line": "n = nums[1]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[1]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = nums[0]",
      "mutated_line": "n = nums[-1]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[-1]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "n = nums[0]",
      "mutated_line": "n = nums[1]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[1]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n - 1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n - 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n * 1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n * 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n + 1, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n + 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n * 1, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n * 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x + 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x + 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x * 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x * 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, +1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, +1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + 2):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 2):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + 0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 0):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + 0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 0):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + -1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[1:], n + 2)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 2)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[1:], n + 0)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 0)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[1:], n + 0)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 0)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[1:], n + -1)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + -1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 1), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 1), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, -1), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, -1), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 1), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 1), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 2), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 2), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 0), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 0), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 0), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 0), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, -1), (n + 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, -1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n - 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n - 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n * 1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n * 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 2), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 2), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 0), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 0), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 0), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 0), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, -1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, -1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n - 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n - 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n * 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n * 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 1)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, -1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, -1)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 1)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::-1][2:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][2:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::-1][0:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][0:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::-1][0:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][0:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::-1][-1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][-1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n - 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n - 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n * 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n * 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 2), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 2), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 0), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 0), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, -1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, -1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n, 2), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 2), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n, 0), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 0), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n, 0), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 0), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n, -1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, -1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n, 1), (n, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 1)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n, 1), (n, -1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, -1)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n, 1), (n, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 1)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 2, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 2, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 0, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 0, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 0, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 0, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - -1, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - -1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 2, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 2, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 0, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 0, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 0, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 0, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - -1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - -1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, -2):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -2):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, -0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -0):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, -0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -0):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, --1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, --1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 1 << i], 1)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 1)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 1 << i], -1)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], -1)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 1 << i], 1)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 1)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 1 << i], 0)[2:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[2:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 1 << i], 0)[0:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[0:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 1 << i], 0)[0:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[0:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 1 << i], 0)[-1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[-1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s = s - 1 & n",
      "mutated_line": "s = s - 2 & n",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 2 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s = s - 1 & n",
      "mutated_line": "s = s - 0 & n",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 0 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s = s - 1 & n",
      "mutated_line": "s = s - 0 & n",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 0 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s = s - 1 & n",
      "mutated_line": "s = s - -1 & n",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - -1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 2 and A[s] == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 2 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 0 and A[s] == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 0 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 0 and A[s] == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 0 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == -1 and A[s] == 0:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == -1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 1 and A[s] == 1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 1:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 1 and A[s] == -1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == -1:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[n] == 1 and A[s] == 0:",
      "mutated_line": "if A[n] == 1 and A[s] == 1:",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 1:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return \"Impossible\", None",
      "mutated_line": "return ('', None)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [(x, 0)]",
      "mutated_line": "return [(x, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 1)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [(x, 0)]",
      "mutated_line": "return [(x, -1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, -1)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [(x, 0)]",
      "mutated_line": "return [(x, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 1)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + 2):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 2):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + 0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 0):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + 0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 0):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(x, n + 1):",
      "mutated_line": "for i in range(x, n + -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + -1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n - 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n - 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n * 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n * 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 1), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, -1), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, -1), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 1), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 1), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n - 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n - 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n * 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n * 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 2), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 2), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 0), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 0), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 0), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 0), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, -1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, -1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 1), (n, 2), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 2), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 1), (n, 0), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 0), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 1), (n, 0), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 0), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 1), (n, -1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, -1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 1)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, -1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, -1)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 1)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 2, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 2, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 0, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 0, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 0, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 0, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - -1, x - 1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - -1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 2, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 2, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 0, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 0, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 0, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 0, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - -1, -1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - -1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, -2):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -2):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, -0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -0):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, -0):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -0):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(n - 1, x - 1, -1):",
      "mutated_line": "for i in range(n - 1, x - 1, --1):",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, --1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, 1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 1))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, -1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, -1))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, 1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 1))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[2:], n + 1)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[2:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[0:], n + 1)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[0:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[0:], n + 1)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[0:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "P = make(nums[1:], n + 1)",
      "mutated_line": "P = make(nums[-1:], n + 1)",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[-1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 2, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 2, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 0, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 0, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 0, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 0, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + -1, 1), (n + 1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + -1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 2, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 2, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 0, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 0, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 0, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 0, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]",
      "mutated_line": "path += [(n, 0), (n, 1), (n + 1, 1), (n + -1, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + -1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::+1][1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::+1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 2, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 2, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 0, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 0, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 0, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 0, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "path += [(n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + -1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + -1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "path += [(i, 0)]",
      "mutated_line": "path += [(i, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 1)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "path += [(i, 0)]",
      "mutated_line": "path += [(i, -1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, -1)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "path += [(i, 0)]",
      "mutated_line": "path += [(i, 1)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 1)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, 1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 1))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, -1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, -1))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, 1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 1))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 2, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 2, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 0, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 0, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 0, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 0, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + -1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + -1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 2, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 2, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 0, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 0, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + 0, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 0, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]",
      "mutated_line": "path += [(n + 1, 0), (n + -1, 1), (n, 1), (n, 0)]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + -1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, 1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 1))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, -1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, -1))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "path.append((i, 0))",
      "mutated_line": "path.append((i, 1))",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 1))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::-2][1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-2][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::-0][1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-0][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::-0][1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-0][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "path += P[::-1][1:]",
      "mutated_line": "path += P[::--1][1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::--1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n | 1 << i], 0)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n | 1 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 2 << i], 0)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 2 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 0 << i], 0)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 0 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & 0 << i], 0)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & 0 << i], 0)[1:]\n    return ('Possible', path)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "path += make([i for i in range(N) if n & 1 << i], 0)[1:]",
      "mutated_line": "path += make([i for i in range(N) if n & -1 << i], 0)[1:]",
      "code": "def find_closed_curve(N, A):\n    minimal_sets = []\n    for n in range(1 << N):\n        s = n\n        is_min = A[n] == 0\n        while s:\n            s = s - 1 & n\n            if A[n] == 1 and A[s] == 0:\n                return ('Impossible', None)\n            if A[s] == 0:\n                is_min = False\n        if is_min:\n            minimal_sets.append(n)\n\n    def make(nums, x):\n        if not nums:\n            return [(x, 0)]\n        path = []\n        if len(nums) == 1:\n            n = nums[0]\n            for i in range(x, n + 1):\n                path.append((i, 0))\n            path += [(n + 1, 0), (n + 1, 1), (n, 1), (n, 0)]\n            for i in range(n - 1, x - 1, -1):\n                path.append((i, 0))\n            return path\n        n = nums[0]\n        for i in range(x, n + 1):\n            path.append((i, 0))\n        P = make(nums[1:], n + 1)\n        path += P\n        path += [(n, 0), (n, 1), (n + 1, 1), (n + 1, 0)]\n        path += P[::-1][1:]\n        path += [(n + 1, 1), (n, 1), (n, 0)]\n        for i in range(n - 1, x - 1, -1):\n            path += [(i, 0)]\n        return path\n    path = [(0, 0)]\n    for n in minimal_sets:\n        path += make([i for i in range(N) if n & -1 << i], 0)[1:]\n    return ('Possible', path)"
    }
  ]
}