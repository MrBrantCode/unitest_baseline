{
  "task_id": "taco_11960",
  "entry_point": "count_special_subsegments",
  "mutant_count": 181,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] / (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] / (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] + (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] + (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] ** (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] ** (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 1\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = -1\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 1\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n - 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n - 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n * 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n * 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "idx[p_val] = i + 1",
      "mutated_line": "idx[p_val] = i - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i - 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "idx[p_val] = i + 1",
      "mutated_line": "idx[p_val] = i * 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i * 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, 1, -1):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 1, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, -1, -1):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, -1, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, 1, -1):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 1, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, 0, +1):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, +1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = i - l + 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l + 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = (i - l) * 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = (i - l) * 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = r - i + 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i + 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = (r - i) * 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = (r - i) * 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if nl < nr:",
      "mutated_line": "if nl <= nr:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl <= nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if nl < nr:",
      "mutated_line": "if nl >= nr:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl >= nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if nl < nr:",
      "mutated_line": "if nl != nr:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl != nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] / (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] / (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] + (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] + (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] ** (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] ** (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 1\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = -1\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 1\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i >= 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i <= 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i != 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "s += self.tree[i]",
      "mutated_line": "s -= self.tree[i]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s -= self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i += i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i < self.size:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i > self.size:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i > self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i == self.size:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i == self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "self.tree[i] += x",
      "mutated_line": "self.tree[i] -= x",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] -= x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i -= i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if w <= 0:",
      "mutated_line": "if w < 0:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w < 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if w <= 0:",
      "mutated_line": "if w > 0:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w > 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if w <= 0:",
      "mutated_line": "if w == 0:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w == 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 1\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = -1\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 1\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return x + 1",
      "mutated_line": "return x - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x - 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return x + 1",
      "mutated_line": "return x * 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x * 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [1] * (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [1] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [-1] * (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [-1] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [1] * (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [1] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + 2)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 2)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 0)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 0)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + -1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + -1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "idx[p_val] = i + 1",
      "mutated_line": "idx[p_val] = i + 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 2\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "idx[p_val] = i + 1",
      "mutated_line": "idx[p_val] = i + 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 0\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "idx[p_val] = i + 1",
      "mutated_line": "idx[p_val] = i + 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 0\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "idx[p_val] = i + 1",
      "mutated_line": "idx[p_val] = i + -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + -1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, 0, -2):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -2):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, 0, -0):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -0):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, 0, -0):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -0):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for p_val in range(n, 0, -1):",
      "mutated_line": "for p_val in range(n, 0, --1):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, --1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "r = bit.lower_bound(k + 1)",
      "mutated_line": "r = bit.lower_bound(k - 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k - 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "r = bit.lower_bound(k + 1)",
      "mutated_line": "r = bit.lower_bound(k * 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k * 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = i + l - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i + l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = i * l - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i * l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = i - l - 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 2\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = i - l - 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 0\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = i - l - 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 0\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nl = i - l - 1",
      "mutated_line": "nl = i - l - -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - -1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = r + i - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r + i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = r * i - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r * i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = r - i - 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 2\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = r - i - 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 0\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = r - i - 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 0\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "nr = r - i - 1",
      "mutated_line": "nr = r - i - -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - -1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "bit.add(i, 1)",
      "mutated_line": "bit.add(i, 2)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "bit.add(i, 1)",
      "mutated_line": "bit.add(i, 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "bit.add(i, 1)",
      "mutated_line": "bit.add(i, 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "bit.add(i, 1)",
      "mutated_line": "bit.add(i, -1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n - 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n - 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n * 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n * 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 1:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > -1:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 1:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i | -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i | -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if w <= 0:",
      "mutated_line": "if w <= 1:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 1:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if w <= 0:",
      "mutated_line": "if w <= -1:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= -1:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if w <= 0:",
      "mutated_line": "if w <= 1:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 1:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 1\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return -1\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 1\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 2 << self.size.bit_length() - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 2 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 0 << self.size.bit_length() - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 0 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 0 << self.size.bit_length() - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 0 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = -1 << self.size.bit_length() - 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = -1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 1 << self.size.bit_length() + 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() + 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 1 << self.size.bit_length() * 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() * 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k <= self.size or self.tree[x + k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size or self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "w -= self.tree[x + k]",
      "mutated_line": "w += self.tree[x + k]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w += self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "x += k",
      "mutated_line": "x -= k",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x -= k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 2\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 0\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 0\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= -1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return x + 1",
      "mutated_line": "return x + 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 2\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return x + 1",
      "mutated_line": "return x + 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 0\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return x + 1",
      "mutated_line": "return x + 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 0\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return x + 1",
      "mutated_line": "return x + -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + -1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "r = bit.lower_bound(k + 1)",
      "mutated_line": "r = bit.lower_bound(k + 2)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 2)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "r = bit.lower_bound(k + 1)",
      "mutated_line": "r = bit.lower_bound(k + 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 0)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "r = bit.lower_bound(k + 1)",
      "mutated_line": "r = bit.lower_bound(k + 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 0)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "r = bit.lower_bound(k + 1)",
      "mutated_line": "r = bit.lower_bound(k + -1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + -1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for j in range(l + 1, i):",
      "mutated_line": "for j in range(l - 1, i):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l - 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for j in range(l + 1, i):",
      "mutated_line": "for j in range(l * 1, i):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l * 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if i < idx[p_val - q] < r:",
      "mutated_line": "if i <= idx[p_val - q] < r:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i <= idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if i < idx[p_val - q] < r:",
      "mutated_line": "if i >= idx[p_val - q] < r:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i >= idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if i < idx[p_val - q] < r:",
      "mutated_line": "if i != idx[p_val - q] < r:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i != idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans -= 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for j in range(i + 1, r):",
      "mutated_line": "for j in range(i - 1, r):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i - 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for j in range(i + 1, r):",
      "mutated_line": "for j in range(i * 1, r):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i * 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if l < idx[p_val - q] < i:",
      "mutated_line": "if l <= idx[p_val - q] < i:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l <= idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if l < idx[p_val - q] < i:",
      "mutated_line": "if l >= idx[p_val - q] < i:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l >= idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if l < idx[p_val - q] < i:",
      "mutated_line": "if l != idx[p_val - q] < i:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l != idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans -= 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [1] * (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [1] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [-1] * (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [-1] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [1] * (n + 1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [1] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 2)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 2)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 0)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 0)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 0)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + -1)",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + -1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & +i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & +i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 1 << self.size.bit_length() - 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 2\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 1 << self.size.bit_length() - 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 0\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 1 << self.size.bit_length() - 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 0\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "k = 1 << (self.size.bit_length() - 1)",
      "mutated_line": "k = 1 << self.size.bit_length() - -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - -1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k < self.size and self.tree[x + k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k < self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k > self.size and self.tree[x + k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k > self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k == self.size and self.tree[x + k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k == self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k <= self.size and self.tree[x + k] <= w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] <= w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k <= self.size and self.tree[x + k] >= w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] >= w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k <= self.size and self.tree[x + k] != w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] != w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for j in range(l + 1, i):",
      "mutated_line": "for j in range(l + 2, i):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 2, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for j in range(l + 1, i):",
      "mutated_line": "for j in range(l + 0, i):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 0, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for j in range(l + 1, i):",
      "mutated_line": "for j in range(l + 0, i):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 0, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for j in range(l + 1, i):",
      "mutated_line": "for j in range(l + -1, i):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + -1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j + 1]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j + 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j * 1]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j * 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 2\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 0\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 0\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += -1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for j in range(i + 1, r):",
      "mutated_line": "for j in range(i + 2, r):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 2, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for j in range(i + 1, r):",
      "mutated_line": "for j in range(i + 0, r):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 0, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for j in range(i + 1, r):",
      "mutated_line": "for j in range(i + 0, r):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 0, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for j in range(i + 1, r):",
      "mutated_line": "for j in range(i + -1, r):",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + -1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j + 1]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j + 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j * 1]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j * 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 2\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 0\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 0\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += -1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x - k <= self.size and self.tree[x + k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x - k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x * k <= self.size and self.tree[x + k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x * k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "w -= self.tree[x + k]",
      "mutated_line": "w -= self.tree[x - k]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x - k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "w -= self.tree[x + k]",
      "mutated_line": "w -= self.tree[x * k]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x * k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - 2]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 2]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - 0]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 0]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - 0]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 0]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - -1]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - -1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if i < idx[p_val - q] < r:",
      "mutated_line": "if i < idx[p_val + q] < r:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val + q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if i < idx[p_val - q] < r:",
      "mutated_line": "if i < idx[p_val * q] < r:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val * q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - 2]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 2]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - 0]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 0]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - 0]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 0]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "q = p[j - 1]",
      "mutated_line": "q = p[j - -1]",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - -1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "if l < idx[p_val - q] < i:",
      "mutated_line": "if l < idx[p_val + q] < i:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val + q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "if l < idx[p_val - q] < i:",
      "mutated_line": "if l < idx[p_val * q] < i:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x + k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val * q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k <= self.size and self.tree[x - k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x - k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if x + k <= self.size and self.tree[x + k] < w:",
      "mutated_line": "if x + k <= self.size and self.tree[x * k] < w:",
      "code": "def count_special_subsegments(n, p):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n        def lower_bound(self, w):\n            if w <= 0:\n                return 0\n            x = 0\n            k = 1 << self.size.bit_length() - 1\n            while k:\n                if x + k <= self.size and self.tree[x * k] < w:\n                    w -= self.tree[x + k]\n                    x += k\n                k >>= 1\n            return x + 1\n    idx = [0] * (n + 1)\n    for (i, p_val) in enumerate(p):\n        idx[p_val] = i + 1\n    bit = Bit(n)\n    ans = 0\n    for p_val in range(n, 0, -1):\n        i = idx[p_val]\n        k = bit.sum(i)\n        r = bit.lower_bound(k + 1)\n        l = bit.lower_bound(k)\n        nl = i - l - 1\n        nr = r - i - 1\n        if nl < nr:\n            for j in range(l + 1, i):\n                q = p[j - 1]\n                if i < idx[p_val - q] < r:\n                    ans += 1\n        else:\n            for j in range(i + 1, r):\n                q = p[j - 1]\n                if l < idx[p_val - q] < i:\n                    ans += 1\n        bit.add(i, 1)\n    return ans"
    }
  ]
}