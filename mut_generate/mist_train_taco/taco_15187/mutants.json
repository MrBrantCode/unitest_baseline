{
  "task_id": "taco_15187",
  "entry_point": "calculate_minimum_distance",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n != 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 2:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 0:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 0:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == -1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 1\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return -1\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 1\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a > checkpoints[n - 1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a > checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a < checkpoints[n - 1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a < checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a == checkpoints[n - 1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a == checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return a - checkpoints[1]",
      "mutated_line": "return a + checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a + checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return a - checkpoints[1]",
      "mutated_line": "return a * checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a * checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "elif a <= checkpoints[0]:",
      "mutated_line": "elif a < checkpoints[0]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a < checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "elif a <= checkpoints[0]:",
      "mutated_line": "elif a > checkpoints[0]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a > checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "elif a <= checkpoints[0]:",
      "mutated_line": "elif a == checkpoints[0]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a == checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a >= checkpoints[n + 1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n + 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a >= checkpoints[n * 1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n * 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n - 2] + a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] + a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n - 2] * a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] * a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] + checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] + checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = (min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2]) * checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = (min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2]) * checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] + checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] + checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = (min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1]) * checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = (min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1]) * checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a >= checkpoints[n - 2]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 2]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a >= checkpoints[n - 0]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 0]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a >= checkpoints[n - 0]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 0]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif a >= checkpoints[n - 1]:",
      "mutated_line": "elif a >= checkpoints[n - -1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - -1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return a - checkpoints[1]",
      "mutated_line": "return a - checkpoints[2]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[2]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return a - checkpoints[1]",
      "mutated_line": "return a - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[0]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return a - checkpoints[1]",
      "mutated_line": "return a - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[0]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return a - checkpoints[1]",
      "mutated_line": "return a - checkpoints[-1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[-1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif a <= checkpoints[0]:",
      "mutated_line": "elif a <= checkpoints[1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[1]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif a <= checkpoints[0]:",
      "mutated_line": "elif a <= checkpoints[-1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[-1]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif a <= checkpoints[0]:",
      "mutated_line": "elif a <= checkpoints[1]:",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[1]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) - checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) - checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) * checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) * checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) - checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) - checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) * checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) * checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n + 2] - a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n + 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n * 2] - a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n * 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[1]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[-1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[-1]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[1]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[2]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[2]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[0]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[0]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[-1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[-1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n - 3] - a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 3] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n - 1] - a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 1] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n - 0] - a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 0] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n - 1] - a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 1] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return checkpoints[n - 2] - a",
      "mutated_line": "return checkpoints[n - -2] - a",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - -2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n + 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n + 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n * 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n * 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n + 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n + 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n * 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n * 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a + checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a + checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a * checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a * checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] + a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] + a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] * a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] * a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 3] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 3] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 1] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 1] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 0] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 0] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 1] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 1] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - -2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - -2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a + checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a + checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a * checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a * checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] + a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] + a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] * a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] * a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 2] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 2] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 0] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 0] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 0] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 0] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - -1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - -1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[-1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[-1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n + 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n + 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n * 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n * 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[2]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[2]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[-1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[-1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n + 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n + 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n * 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n * 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 3] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 3] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 0] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 0] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "mutated_line": "gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - -2] - a)) + checkpoints[n - 2] - checkpoints[0]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - -2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 0] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 0] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 0] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 0] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - 1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "mutated_line": "droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - -1] - a)) + checkpoints[n - 1] - checkpoints[1]",
      "code": "def calculate_minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    elif a >= checkpoints[n - 1]:\n        return a - checkpoints[1]\n    elif a <= checkpoints[0]:\n        return checkpoints[n - 2] - a\n    else:\n        gauche = min(abs(a - checkpoints[0]), abs(checkpoints[n - 2] - a)) + checkpoints[n - 2] - checkpoints[0]\n        droite = min(abs(a - checkpoints[1]), abs(checkpoints[n - -1] - a)) + checkpoints[n - 1] - checkpoints[1]\n        return min(gauche, droite)"
    }
  ]
}