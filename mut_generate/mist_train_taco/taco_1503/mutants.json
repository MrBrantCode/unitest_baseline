{
  "task_id": "taco_1503",
  "entry_point": "power",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "MOD = 998244354\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "MOD = 998244352\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "MOD = -998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 2\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 0\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 0\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = -1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while b > 0:",
      "mutated_line": "while b >= 0:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b >= 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while b > 0:",
      "mutated_line": "while b <= 0:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b <= 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while b > 0:",
      "mutated_line": "while b != 0:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b != 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 1\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = -1\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 1\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "while b > 0:",
      "mutated_line": "while b > 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 1:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "while b > 0:",
      "mutated_line": "while b > -1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > -1:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "while b > 0:",
      "mutated_line": "while b > 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 1:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 != 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 != 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "a = a * a % MOD",
      "mutated_line": "a = a * a * MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a * MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "a = a * a % MOD",
      "mutated_line": "a = a * a + MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a + MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b //= 2",
      "mutated_line": "b //= 3",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 3\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b //= 2",
      "mutated_line": "b //= 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 1\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b //= 2",
      "mutated_line": "b //= 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 0\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b //= 2",
      "mutated_line": "b //= 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 1\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b //= 2",
      "mutated_line": "b //= -2",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= -2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return power(n, MOD - 2)",
      "mutated_line": "return power(n, MOD + 2)",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD + 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return power(n, MOD - 2)",
      "mutated_line": "return power(n, MOD * 2)",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD * 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prob = [0, 0]",
      "mutated_line": "prob = [1, 0]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [1, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prob = [0, 0]",
      "mutated_line": "prob = [-1, 0]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [-1, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prob = [0, 0]",
      "mutated_line": "prob = [1, 0]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [1, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prob = [0, 0]",
      "mutated_line": "prob = [0, 1]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 1]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prob = [0, 0]",
      "mutated_line": "prob = [0, -1]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, -1]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prob = [0, 0]",
      "mutated_line": "prob = [0, 1]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 1]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(3, max(n, m) + 1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(3, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(1, max(n, m) + 1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(1, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(0, max(n, m) + 1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(0, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(1, max(n, m) + 1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(1, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(-2, max(n, m) + 1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(-2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(2, max(n, m) - 1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) - 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(2, max(n, m) * 1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) * 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 1\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = -1\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 1\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "res += prob[cnt]",
      "mutated_line": "res -= prob[cnt]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res -= prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 1\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = -1\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 1\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "res += prob[cnt]",
      "mutated_line": "res -= prob[cnt]",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res -= prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b * 2 == 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b * 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b + 2 == 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b + 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 2:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 2:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 0:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 0:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 0:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 0:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == -1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == -1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res * a % MOD",
      "mutated_line": "res = res * a * MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a * MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res * a % MOD",
      "mutated_line": "res = res * a + MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a + MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "a = a * a % MOD",
      "mutated_line": "a = a / a % MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a / a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "a = a * a % MOD",
      "mutated_line": "a = (a + a) % MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = (a + a) % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "a = a * a % MOD",
      "mutated_line": "a = a ** a % MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a ** a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return power(n, MOD - 2)",
      "mutated_line": "return power(n, MOD - 3)",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 3)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return power(n, MOD - 2)",
      "mutated_line": "return power(n, MOD - 1)",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 1)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return power(n, MOD - 2)",
      "mutated_line": "return power(n, MOD - 0)",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 0)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return power(n, MOD - 2)",
      "mutated_line": "return power(n, MOD - 1)",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 1)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return power(n, MOD - 2)",
      "mutated_line": "return power(n, MOD - -2)",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - -2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(2, max(n, m) + 2):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 2):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(2, max(n, m) + 0):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 0):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(2, max(n, m) + 0):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 0):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for c in range(2, max(n, m) + 1):",
      "mutated_line": "for c in range(2, max(n, m) + -1):",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + -1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] - (-1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] - (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] * ((-1) ** c * inverse(power(2, c))))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] * ((-1) ** c * inverse(power(2, c))))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "prob[-1] %= MOD",
      "mutated_line": "prob[+1] %= MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[+1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if grid[r][c] == 'o':",
      "mutated_line": "if grid[r][c] != 'o':",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] != 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt -= 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if grid[r][c] == 'o':",
      "mutated_line": "if grid[r][c] != 'o':",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] != 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt -= 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if grid[r][c] == 'o':",
      "mutated_line": "if grid[r][c] != 'o':",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] != 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "res *= 2",
      "mutated_line": "res /= 2",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res /= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 3 == 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 3 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 1 == 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 1 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 0 == 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 0 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 1 == 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 1 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % -2 == 1:",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % -2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res * a % MOD",
      "mutated_line": "res = res / a % MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res / a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res * a % MOD",
      "mutated_line": "res = (res + a) % MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = (res + a) % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res = res * a % MOD",
      "mutated_line": "res = res ** a % MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res ** a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-1) ** c / inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c / inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + ((-1) ** c + inverse(power(2, c))))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + ((-1) ** c + inverse(power(2, c))))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + ((-1) ** c) ** inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + ((-1) ** c) ** inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prob[-1] %= MOD",
      "mutated_line": "prob[-2] %= MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-2] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prob[-1] %= MOD",
      "mutated_line": "prob[-0] %= MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-0] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prob[-1] %= MOD",
      "mutated_line": "prob[-0] %= MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-0] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prob[-1] %= MOD",
      "mutated_line": "prob[--1] %= MOD",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[--1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if grid[r][c] == 'o':",
      "mutated_line": "if grid[r][c] == '':",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == '':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 2\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 0\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 0\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += -1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 1\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = -1\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 1\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if grid[r][c] == 'o':",
      "mutated_line": "if grid[r][c] == '':",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == '':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 2\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 0\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 0\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += -1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 1\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = -1\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 1\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if grid[r][c] == 'o':",
      "mutated_line": "if grid[r][c] == '':",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == '':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "res *= 2",
      "mutated_line": "res *= 3",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 3\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "res *= 2",
      "mutated_line": "res *= 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 1\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "res *= 2",
      "mutated_line": "res *= 0",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 0\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "res *= 2",
      "mutated_line": "res *= 1",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 1\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "res *= 2",
      "mutated_line": "res *= -2",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= -2\n                res %= MOD\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[+1] + (-1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[+1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + -1 * c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + -1 * c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-1 + c) * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1 + c) * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-2] + (-1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-2] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-0] + (-1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-0] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-0] + (-1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-0] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[--1] + (-1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[--1] + (-1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (+1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (+1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-2) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-2) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-0) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-0) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-0) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-0) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (--1) ** c * inverse(power(2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (--1) ** c * inverse(power(2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(3, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(3, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(1, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(1, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(0, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(0, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(1, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(1, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(2, c)))",
      "mutated_line": "prob.append(prob[-1] + (-1) ** c * inverse(power(-2, c)))",
      "code": "MOD = 998244353\n\ndef power(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b //= 2\n    return res\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef calculate_board_value(n, m, grid):\n    prob = [0, 0]\n    for c in range(2, max(n, m) + 1):\n        prob.append(prob[-1] + (-1) ** c * inverse(power(-2, c)))\n        prob[-1] %= MOD\n    res = 0\n    for r in range(n):\n        cnt = 0\n        for c in range(m):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for c in range(m):\n        cnt = 0\n        for r in range(n):\n            if grid[r][c] == 'o':\n                cnt += 1\n            else:\n                cnt = 0\n            res += prob[cnt]\n            res %= MOD\n    for r in range(n):\n        for c in range(m):\n            if grid[r][c] == 'o':\n                res *= 2\n                res %= MOD\n    return res"
    }
  ]
}