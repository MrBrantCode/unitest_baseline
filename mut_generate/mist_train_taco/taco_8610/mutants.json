{
  "task_id": "taco_8610",
  "entry_point": "find_lexicographically_smallest_counterexample",
  "mutant_count": 177,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "arr[diff_ind:] += 1",
      "mutated_line": "arr[diff_ind:] -= 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] -= 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid_ind = N // 2",
      "mutated_line": "mid_ind = N / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N / 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid_ind = N // 2",
      "mutated_line": "mid_ind = N * 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N * 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if len(seqs) == 0:",
      "mutated_line": "if len(seqs) != 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) != 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "arr[diff_ind:] += 1",
      "mutated_line": "arr[diff_ind:] += 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 2\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "arr[diff_ind:] += 1",
      "mutated_line": "arr[diff_ind:] += 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 0\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "arr[diff_ind:] += 1",
      "mutated_line": "arr[diff_ind:] += 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 0\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "arr[diff_ind:] += 1",
      "mutated_line": "arr[diff_ind:] += -1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += -1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "s = s - np.sum(arr)",
      "mutated_line": "s = s + np.sum(arr)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s + np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "s = s - np.sum(arr)",
      "mutated_line": "s = s * np.sum(arr)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s * np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if s < 0:",
      "mutated_line": "if s <= 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s <= 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if s < 0:",
      "mutated_line": "if s >= 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s >= 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if s < 0:",
      "mutated_line": "if s != 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s != 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = M - m + 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m + 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = (M - m) * 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = (M - m) * 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ind = n - 1",
      "mutated_line": "ind = n + 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n + 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ind = n - 1",
      "mutated_line": "ind = n * 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n * 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while ind >= 0:",
      "mutated_line": "while ind > 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind > 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while ind >= 0:",
      "mutated_line": "while ind < 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind < 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while ind >= 0:",
      "mutated_line": "while ind == 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind == 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "arr[ind] += z",
      "mutated_line": "arr[ind] -= z",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] -= z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "s -= z",
      "mutated_line": "s += z",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s += z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "ind -= 1",
      "mutated_line": "ind += 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind += 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if s != 0:",
      "mutated_line": "if s == 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s == 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 != 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median == seq[(n - 2) // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median == seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid_ind = N // 2",
      "mutated_line": "mid_ind = N // 3",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 3\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid_ind = N // 2",
      "mutated_line": "mid_ind = N // 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 1\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid_ind = N // 2",
      "mutated_line": "mid_ind = N // 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 0\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid_ind = N // 2",
      "mutated_line": "mid_ind = N // 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 1\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid_ind = N // 2",
      "mutated_line": "mid_ind = N // -2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // -2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind - 2, mid_ind - 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind - 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind * 2, mid_ind - 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind * 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind + 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind + 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind * 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind * 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 3, +1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, +1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind >= N and ind < 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N and ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if seq is not -1 and test_seq(K, seq):",
      "mutated_line": "if seq is not -1 or test_seq(K, seq):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 or test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if len(seqs) == 0:",
      "mutated_line": "if len(seqs) == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 1:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if len(seqs) == 0:",
      "mutated_line": "if len(seqs) == -1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == -1:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if len(seqs) == 0:",
      "mutated_line": "if len(seqs) == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 1:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return +1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 1:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if s < 0:",
      "mutated_line": "if s < -1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < -1:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 1:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return +1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = M + m - 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M + m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = M * m - 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M * m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = M - m - 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 2\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = M - m - 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 0\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = M - m - 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 0\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inc = M - m - 1",
      "mutated_line": "inc = M - m - -1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - -1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ind = n - 1",
      "mutated_line": "ind = n - 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 2\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ind = n - 1",
      "mutated_line": "ind = n - 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 0\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ind = n - 1",
      "mutated_line": "ind = n - 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 0\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ind = n - 1",
      "mutated_line": "ind = n - -1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - -1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while ind >= 0:",
      "mutated_line": "while ind >= 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 1:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while ind >= 0:",
      "mutated_line": "while ind >= -1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= -1:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while ind >= 0:",
      "mutated_line": "while ind >= 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 1:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 2\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 0\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 0\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= -1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= -1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s != 0:",
      "mutated_line": "if s != 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 1:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s != 0:",
      "mutated_line": "if s != -1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != -1:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s != 0:",
      "mutated_line": "if s != 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 1:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return +1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n * 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n + 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 2:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 0:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 0:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == -1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 2]) * 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) * 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 2]) // 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) // 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "seq.pop(n % k)",
      "mutated_line": "seq.pop(n * k)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n * k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "seq.pop(n % k)",
      "mutated_line": "seq.pop(n + k)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n + k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "seq.pop(k - 1)",
      "mutated_line": "seq.pop(k + 1)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k + 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "seq.pop(k - 1)",
      "mutated_line": "seq.pop(k * 1)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k * 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 3, mid_ind - 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 3, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 1, mid_ind - 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 1, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 0, mid_ind - 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 0, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 1, mid_ind - 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 1, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + -2, mid_ind - 3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + -2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 4, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 4, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 2, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 2, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 0, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 0, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 1, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 1, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - -3, -1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - -3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 3, -2):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -2):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 3, -0):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -0):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 3, -0):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -0):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for ind in range(mid_ind + 2, mid_ind - 3, -1):",
      "mutated_line": "for ind in range(mid_ind + 2, mid_ind - 3, --1):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, --1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind > N or ind < 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind > N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind < N or ind < 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind < N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind == N or ind < 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind == N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind >= N or ind <= 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind <= 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind >= N or ind >= 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind >= 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind >= N or ind != 0:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind != 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if seq is not -1 and test_seq(K, seq):",
      "mutated_line": "if seq is -1 and test_seq(K, seq):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -2\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -0\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -0\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return --1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -2\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -0\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -0\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return --1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -2\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -0\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -0\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return --1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 3 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 1 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 0 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 1 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % -2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "median = seq[n // 2]",
      "mutated_line": "median = seq[n / 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n / 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "median = seq[n // 2]",
      "mutated_line": "median = seq[n * 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n * 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] - seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] - seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = seq[n // 2 - 1] * seq[n // 2] / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = seq[n // 2 - 1] * seq[n // 2] / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 3",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 3\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 1\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 0",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 0\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 1",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 1\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / -2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / -2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "seq.pop(k - 1)",
      "mutated_line": "seq.pop(k - 2)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 2)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "seq.pop(k - 1)",
      "mutated_line": "seq.pop(k - 0)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 0)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "seq.pop(k - 1)",
      "mutated_line": "seq.pop(k - 0)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 0)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "seq.pop(k - 1)",
      "mutated_line": "seq.pop(k - -1)",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - -1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 2) / 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) / 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 2) * 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) * 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind >= N or ind < 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 1:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind >= N or ind < -1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < -1:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if ind >= N or ind < 0:",
      "mutated_line": "if ind >= N or ind < 1:",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 1:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "if seq is not -1 and test_seq(K, seq):",
      "mutated_line": "if seq is not +1 and test_seq(K, seq):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not +1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "median = seq[n // 2]",
      "mutated_line": "median = seq[n // 3]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 3]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "median = seq[n // 2]",
      "mutated_line": "median = seq[n // 1]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 1]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "median = seq[n // 2]",
      "mutated_line": "median = seq[n // 0]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 0]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "median = seq[n // 2]",
      "mutated_line": "median = seq[n // 1]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 1]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "median = seq[n // 2]",
      "mutated_line": "median = seq[n // -2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // -2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n + 2) // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n + 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[n * 2 // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[n * 2 // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 2) // 3]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 3]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 2) // 1]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 1]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 2) // 0]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 0]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 2) // 1]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 1]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 2) // -2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // -2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if seq is not -1 and test_seq(K, seq):",
      "mutated_line": "if seq is not -2 and test_seq(K, seq):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -2 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if seq is not -1 and test_seq(K, seq):",
      "mutated_line": "if seq is not -0 and test_seq(K, seq):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -0 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if seq is not -1 and test_seq(K, seq):",
      "mutated_line": "if seq is not -0 and test_seq(K, seq):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -0 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if seq is not -1 and test_seq(K, seq):",
      "mutated_line": "if seq is not --1 and test_seq(K, seq):",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not --1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 + 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 + 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 * 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 * 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n / 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n / 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n * 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n * 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 3) // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 3) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 1) // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 1) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 0) // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 0) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - 1) // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 1) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return median != seq[(n - 2) // 2]",
      "mutated_line": "return median != seq[(n - -2) // 2]",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - -2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n / 2 - 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n / 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n * 2 - 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n * 2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 2] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 2] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 0] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 0] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 0] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 0] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - -1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - -1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 3]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 3]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 1]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 1]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 0]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 0]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // 1]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // 1]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 2 - 1] + seq[n // -2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 2 - 1] + seq[n // -2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 3 - 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 3 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 1 - 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 1 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 0 - 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 0 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // 1 - 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // 1 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "median = (seq[n // 2 - 1] + seq[n // 2]) / 2",
      "mutated_line": "median = (seq[n // -2 - 1] + seq[n // 2]) / 2",
      "code": "def find_lexicographically_smallest_counterexample(N, S, K, m, M):\n\n    def gen_best_seq(n, diff_ind, m, M, s):\n        arr = np.full((n,), m)\n        arr[diff_ind:] += 1\n        s = s - np.sum(arr)\n        if s < 0:\n            return -1\n        inc = M - m - 1\n        ind = n - 1\n        while ind >= 0:\n            z = min(inc, s)\n            arr[ind] += z\n            s -= z\n            ind -= 1\n        if s != 0:\n            return -1\n        return arr\n\n    def test_seq(k, seq):\n        seq = sorted(seq)\n        n = len(seq)\n        if n % 2 == 1:\n            median = seq[n // 2]\n        else:\n            median = (seq[n // -2 - 1] + seq[n // 2]) / 2\n        seq.pop(n % k)\n        seq.pop(k - 1)\n        return median != seq[(n - 2) // 2]\n    mid_ind = N // 2\n    seqs = []\n    for ind in range(mid_ind + 2, mid_ind - 3, -1):\n        if ind >= N or ind < 0:\n            continue\n        seq = gen_best_seq(N, ind, m, M, S)\n        if seq is not -1 and test_seq(K, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)"
    }
  ]
}