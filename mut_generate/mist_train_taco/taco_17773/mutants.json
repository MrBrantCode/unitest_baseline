{
  "task_id": "taco_17773",
  "entry_point": "maximize_joi_cake_pieces",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 1\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = -1\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 1\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[-1] / N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] / N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[-1] + N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] + N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[-1] ** N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] ** N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if memo[p][q] != -1:",
      "mutated_line": "if memo[p][q] == -1:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] == -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 2 == 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 == 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 2 != 0 else 1",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 1\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 2 != 0 else -1",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else -1\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 2 != 0 else 1",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 1\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "if memo[p][q] != -1:",
      "mutated_line": "if memo[p][q] != +1:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != +1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif A[p] < A[q]:",
      "mutated_line": "elif A[p] <= A[q]:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] <= A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif A[p] < A[q]:",
      "mutated_line": "elif A[p] >= A[q]:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] >= A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif A[p] < A[q]:",
      "mutated_line": "elif A[p] != A[q]:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] != A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] - dfs((i + 1) % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] - dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] * dfs((i + 1) % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] * dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[+1] * N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[+1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N * 2 != 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N * 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N + 2 != 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N + 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 2 != 1 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 1 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 2 != -1 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != -1 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 2 != 1 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 1 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if memo[p][q] != -1:",
      "mutated_line": "if memo[p][q] != -2:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -2:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if memo[p][q] != -1:",
      "mutated_line": "if memo[p][q] != -0:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -0:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if memo[p][q] != -1:",
      "mutated_line": "if memo[p][q] != -0:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -0:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if memo[p][q] != -1:",
      "mutated_line": "if memo[p][q] != --1:",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != --1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] - dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] - dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] * dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] * dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] - dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] - dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] * dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] * dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[-2] * N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-2] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[-0] * N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-0] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[-0] * N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-0] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "memo = [[-1] * N for _ in range(N)]",
      "mutated_line": "memo = [[--1] * N for _ in range(N)]",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[--1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 3 != 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 3 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 1 != 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 1 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 0 != 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 0 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % 1 != 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 1 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "memo[i][i] = A[i] if N % 2 != 0 else 0",
      "mutated_line": "memo[i][i] = A[i] if N % -2 != 0 else 0",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % -2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 1) * N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) * N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, q - 1 + N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, q - 1 + N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 1) % N, 2)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 2)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 1) % N, 0)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 0)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 1) % N, 0)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 0)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 1) % N, -1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, -1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 1) * N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) * N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs(p + 1 + N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs(p + 1 + N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 1) % N, q, 2)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 2)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 1) % N, q, 0)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 0)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 1) % N, q, 0)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 0)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 1) % N, q, -1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, -1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) * N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) * N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs(i + 1 + N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs(i + 1 + N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) * N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) * N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, i - 1 + N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, i - 1 + N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 1))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 1))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, -1))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, -1))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 1))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 1))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) * N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) * N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs(p + 1 + N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs(p + 1 + N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 1), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 1), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, -1), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, -1), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 1), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 1), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) * N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) * N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, q - 1 + N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, q - 1 + N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 1))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 1))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, -1))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, -1))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 1))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 1))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q + 1) % N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q + 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, q * 1 % N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, q * 1 % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p - 1) % N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p - 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs(p * 1 % N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs(p * 1 % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i - 1) % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i - 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs(i * 1 % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs(i * 1 % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i + 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i + 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, i * 1 % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, i * 1 % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p - 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p - 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs(p * 1 % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs(p * 1 % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q + 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q + 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, q * 1 % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, q * 1 % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 2) % N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 2) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 0) % N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 0) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - 0) % N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 0) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "memo[p][q] = dfs(p, (q - 1) % N, 1)",
      "mutated_line": "memo[p][q] = dfs(p, (q - -1) % N, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - -1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 2) % N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 2) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 0) % N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 0) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + 0) % N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 0) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[p][q] = dfs((p + 1) % N, q, 1)",
      "mutated_line": "memo[p][q] = dfs((p + -1) % N, q, 1)",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + -1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 2) % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 2) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 0) % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 0) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 0) % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 0) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + -1) % N, (i - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + -1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 2) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 2) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 0) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 0) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 0) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 0) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))",
      "mutated_line": "ans = max(ans, A[i] + dfs((i + 1) % N, (i - -1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - -1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 2) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 2) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 0) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 0) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 0) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 0) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + -1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + -1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 2) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 2) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 0) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 0) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 0) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 0) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - 1) % N, 0))",
      "mutated_line": "memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - -1) % N, 0))",
      "code": "def maximize_joi_cake_pieces(N, A):\n    memo = [[-1] * N for _ in range(N)]\n    for i in range(N):\n        memo[i][i] = A[i] if N % 2 != 0 else 0\n\n    def dfs(p, q, t):\n        if memo[p][q] != -1:\n            return memo[p][q]\n        if t:\n            memo[p][q] = max(A[p] + dfs((p + 1) % N, q, 0), A[q] + dfs(p, (q - -1) % N, 0))\n        elif A[p] < A[q]:\n            memo[p][q] = dfs(p, (q - 1) % N, 1)\n        else:\n            memo[p][q] = dfs((p + 1) % N, q, 1)\n        return memo[p][q]\n    ans = 0\n    for i in range(N):\n        ans = max(ans, A[i] + dfs((i + 1) % N, (i - 1) % N, 0))\n    return ans"
    }
  ]
}