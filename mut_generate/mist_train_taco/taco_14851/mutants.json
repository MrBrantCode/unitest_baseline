{
  "task_id": "taco_14851",
  "entry_point": "find_bridges",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] / N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] / N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] + N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] + N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] ** N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] ** N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prenum = [0] * N",
      "mutated_line": "prenum = [0] / N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] / N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prenum = [0] * N",
      "mutated_line": "prenum = [0] + N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] + N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prenum = [0] * N",
      "mutated_line": "prenum = [0] ** N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] ** N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "parent = [0] * N",
      "mutated_line": "parent = [0] / N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] / N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "parent = [0] * N",
      "mutated_line": "parent = [0] + N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] + N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "parent = [0] * N",
      "mutated_line": "parent = [0] ** N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] ** N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lowest = [0] * N",
      "mutated_line": "lowest = [0] / N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] / N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lowest = [0] * N",
      "mutated_line": "lowest = [0] + N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] + N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "lowest = [0] * N",
      "mutated_line": "lowest = [0] ** N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] ** N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "timer = 1",
      "mutated_line": "timer = 2",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 2\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "timer = 1",
      "mutated_line": "timer = 0",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 0\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "timer = 1",
      "mutated_line": "timer = 0",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 0\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "timer = 1",
      "mutated_line": "timer = -1",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = -1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "timer += 1",
      "mutated_line": "timer -= 1",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer -= 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "timer += 1",
      "mutated_line": "timer += 2",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 2\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "timer += 1",
      "mutated_line": "timer += 0",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 0\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "timer += 1",
      "mutated_line": "timer += 0",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 0\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "timer += 1",
      "mutated_line": "timer += -1",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += -1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[cur] = True",
      "mutated_line": "visited[cur] = False",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = False\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [True] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [True] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prenum = [0] * N",
      "mutated_line": "prenum = [1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [1] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prenum = [0] * N",
      "mutated_line": "prenum = [-1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [-1] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prenum = [0] * N",
      "mutated_line": "prenum = [1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [1] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "parent = [0] * N",
      "mutated_line": "parent = [1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [1] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "parent = [0] * N",
      "mutated_line": "parent = [-1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [-1] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "parent = [0] * N",
      "mutated_line": "parent = [1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [1] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lowest = [0] * N",
      "mutated_line": "lowest = [1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [1] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lowest = [0] * N",
      "mutated_line": "lowest = [-1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [-1] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "lowest = [0] * N",
      "mutated_line": "lowest = [1] * N",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [1] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if lowest[nxt] == prenum[nxt]:",
      "mutated_line": "if lowest[nxt] != prenum[nxt]:",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] != prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif nxt != prev:",
      "mutated_line": "elif nxt == prev:",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt == prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "timer = rec(i, -1, timer)",
      "mutated_line": "timer = rec(i, +1, timer)",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, +1, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "timer = rec(i, -1, timer)",
      "mutated_line": "timer = rec(i, -2, timer)",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -2, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "timer = rec(i, -1, timer)",
      "mutated_line": "timer = rec(i, -0, timer)",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -0, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "timer = rec(i, -1, timer)",
      "mutated_line": "timer = rec(i, -0, timer)",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -0, timer)\n    return sorted(bridges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "timer = rec(i, -1, timer)",
      "mutated_line": "timer = rec(i, --1, timer)",
      "code": "def find_bridges(nodes, N, M):\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                if lowest[nxt] == prenum[nxt]:\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, --1, timer)\n    return sorted(bridges)"
    }
  ]
}