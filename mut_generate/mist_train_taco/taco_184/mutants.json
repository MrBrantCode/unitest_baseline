{
  "task_id": "taco_184",
  "entry_point": "calculate_book_read_count",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c = t = 0",
      "mutated_line": "c = t = 1",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 1\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c = t = 0",
      "mutated_line": "c = t = -1",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = -1\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c = t = 0",
      "mutated_line": "c = t = 1",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 1\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "t += 1",
      "mutated_line": "t -= 1",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t -= 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k_i == 0:",
      "mutated_line": "if k_i != 0:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i != 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t += 1",
      "mutated_line": "t += 2",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 2\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 0\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 0\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t += 1",
      "mutated_line": "t += -1",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += -1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "c = i // n",
      "mutated_line": "c = i / n",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i / n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "c = i // n",
      "mutated_line": "c = i * n",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i * n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "i = i % n",
      "mutated_line": "i = i * n",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i * n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "i = i % n",
      "mutated_line": "i = i + n",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i + n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "l[j] -= 1",
      "mutated_line": "l[j] += 1",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] += 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k_i == 0:",
      "mutated_line": "if k_i == 1:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 1:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k_i == 0:",
      "mutated_line": "if k_i == -1:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == -1:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k_i == 0:",
      "mutated_line": "if k_i == 1:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 1:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[j] -= 1",
      "mutated_line": "l[j] -= 2",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 2\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[j] -= 1",
      "mutated_line": "l[j] -= 0",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 0\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[j] -= 1",
      "mutated_line": "l[j] -= 0",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 0\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[j] -= 1",
      "mutated_line": "l[j] -= -1",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= -1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if l[j] == 0:",
      "mutated_line": "if l[j] != 0:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] != 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 1 if t != n else -1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t != n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c - 1 if t == n else -1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c - 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c * 1 if t == n else -1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c * 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 1 if t == n else +1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else +1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if l[j] == 0:",
      "mutated_line": "if l[j] == 1:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 1:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if l[j] == 0:",
      "mutated_line": "if l[j] == -1:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == -1:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if l[j] == 0:",
      "mutated_line": "if l[j] == 1:",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 1:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 2 if t == n else -1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 2 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 0 if t == n else -1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 0 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 0 if t == n else -1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 0 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + -1 if t == n else -1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + -1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 1 if t == n else -2)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 1 if t == n else -0)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 1 if t == n else -0)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(c + 1 if t == n else -1)",
      "mutated_line": "results.append(c + 1 if t == n else --1)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else --1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d[j - 1].append(i)",
      "mutated_line": "d[j + 1].append(i)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j + 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d[j - 1].append(i)",
      "mutated_line": "d[j * 1].append(i)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j * 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j >= i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j >= i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j <= i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j <= i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j != i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j != i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j - c * n if j > i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j - c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j * (c * n) if j > i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j * (c * n) if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j > i else j + n - c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n - c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j > i else (j + n) * (c * n))",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else (j + n) * (c * n))\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[j - 1].append(i)",
      "mutated_line": "d[j - 2].append(i)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 2].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[j - 1].append(i)",
      "mutated_line": "d[j - 0].append(i)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 0].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[j - 1].append(i)",
      "mutated_line": "d[j - 0].append(i)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 0].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[j - 1].append(i)",
      "mutated_line": "d[j - -1].append(i)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - -1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c / n if j > i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c / n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + (c + n) if j > i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + (c + n) if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c ** n if j > i else j + n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c ** n if j > i else j + n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j > i else j - n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j - n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j > i else j * n + c * n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j * n + c * n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j > i else j + n + c / n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c / n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j > i else j + n + (c + n))",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + (c + n))\n        results.append(c + 1 if t == n else -1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(h, j + c * n if j > i else j + n + c * n)",
      "mutated_line": "heapq.heappush(h, j + c * n if j > i else j + n + c ** n)",
      "code": "import heapq\n\ndef calculate_book_read_count(test_cases):\n    results = []\n    for case in test_cases:\n        (n, dependencies) = case\n        d = [[] for _ in range(n)]\n        h = []\n        l = []\n        for i in range(n):\n            (k_i, *required_chapters) = dependencies[i]\n            l.append(k_i)\n            if k_i == 0:\n                heapq.heappush(h, i)\n            for j in required_chapters:\n                d[j - 1].append(i)\n        c = t = 0\n        while h:\n            i = heapq.heappop(h)\n            t += 1\n            c = i // n\n            i = i % n\n            for j in d[i]:\n                l[j] -= 1\n                if l[j] == 0:\n                    heapq.heappush(h, j + c * n if j > i else j + n + c ** n)\n        results.append(c + 1 if t == n else -1)\n    return results"
    }
  ]
}