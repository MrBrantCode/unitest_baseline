{
  "task_id": "taco_2115",
  "entry_point": "count_interesting_subsets",
  "mutant_count": 238,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "c = 200000",
      "mutated_line": "c = 200001",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200001\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "c = 200000",
      "mutated_line": "c = 199999",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 199999\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "c = 200000",
      "mutated_line": "c = 0",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 0\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "c = 200000",
      "mutated_line": "c = 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 1\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "c = 200000",
      "mutated_line": "c = -200000",
      "code": "def count_interesting_subsets(N, slippers):\n    c = -200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244354\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244352\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 0\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 1\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = -998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] / (4 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] / (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] + 4 * c",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] + 4 * c\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] ** (4 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] ** (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[0] + 1) * mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) * mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return st[0] + 1 + mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return st[0] + 1 + mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * (4 / c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 / c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * (4 + c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 + c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * 4 ** c",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * 4 ** c\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if ss == se and ss == num:",
      "mutated_line": "if ss == se or ss == num:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se or ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) / 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) / 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) * 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) * 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if mid >= num:",
      "mutated_line": "if mid > num:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid > num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if mid >= num:",
      "mutated_line": "if mid < num:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid < num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if mid >= num:",
      "mutated_line": "if mid == num:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid == num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) * mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) * mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = st[idx * 2 + 1] + st[idx * 2 + 2] + mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = st[idx * 2 + 1] + st[idx * 2 + 2] + mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if rs <= ss and se <= re:",
      "mutated_line": "if rs <= ss or se <= re:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss or se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 2\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 0\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 0\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count = 1",
      "mutated_line": "count = -1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = -1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if slippers[i] != 1:",
      "mutated_line": "if slippers[i] == 1:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] == 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[0] - 1) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return st[0] * 1 % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return st[0] * 1 % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [1] * (4 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [1] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [-1] * (4 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [-1] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [1] * (4 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [1] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * (5 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (5 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * (3 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (3 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * (0 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (0 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * (1 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (1 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0] * (4 * c)",
      "mutated_line": "st = [0] * (-4 * c)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (-4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if ss == se and ss == num:",
      "mutated_line": "if ss != se and ss == num:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss != se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if ss == se and ss == num:",
      "mutated_line": "if ss == se and ss != num:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss != num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "st[idx] = (st[idx] + summ) % mod",
      "mutated_line": "st[idx] = (st[idx] + summ) * mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) * mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "st[idx] = (st[idx] + summ) % mod",
      "mutated_line": "st[idx] = st[idx] + summ + mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = st[idx] + summ + mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss - se) // 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss - se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = ss * se // 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = ss * se // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 3",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 3\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 1\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 0",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 0\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 1\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // -2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // -2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] - st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] - st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = st[idx * 2 + 1] * st[idx * 2 + 2] % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = st[idx * 2 + 1] * st[idx * 2 + 2] % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if rs <= ss and se <= re:",
      "mutated_line": "if rs < ss and se <= re:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs < ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if rs <= ss and se <= re:",
      "mutated_line": "if rs > ss and se <= re:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs > ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if rs <= ss and se <= re:",
      "mutated_line": "if rs == ss and se <= re:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs == ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if rs <= ss and se <= re:",
      "mutated_line": "if rs <= ss and se < re:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se < re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if rs <= ss and se <= re:",
      "mutated_line": "if rs <= ss and se > re:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se > re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if rs <= ss and se <= re:",
      "mutated_line": "if rs <= ss and se == re:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se == re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "elif re < ss or se < rs:",
      "mutated_line": "elif re < ss and se < rs:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss and se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if slippers[i] != 1:",
      "mutated_line": "if slippers[i] != 2:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 2:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if slippers[i] != 1:",
      "mutated_line": "if slippers[i] != 0:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 0:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if slippers[i] != 1:",
      "mutated_line": "if slippers[i] != 0:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 0:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if slippers[i] != 1:",
      "mutated_line": "if slippers[i] != -1:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != -1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) * mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) * mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = 1 + rangesum(0, 1, 200000, 1, slippers[i] - 1) + mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = 1 + rangesum(0, 1, 200000, 1, slippers[i] - 1) + mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(1, 1, 200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(1, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(-1, 1, 200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(-1, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(1, 1, 200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(1, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 2, 200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 2, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 0, 200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 0, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 0, 200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 0, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, -1, 200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, -1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 1, 200001, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200001, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 1, 199999, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 199999, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 1, 0, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 0, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 1, 1, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 1, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "update(0, 1, 200000, count, slippers[i])",
      "mutated_line": "update(0, 1, -200000, count, slippers[i])",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, -200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[0] + 2) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 2) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[0] + 0) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 0) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[0] + 0) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 0) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[0] + -1) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + -1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "st[idx] = (st[idx] + summ) % mod",
      "mutated_line": "st[idx] = (st[idx] - summ) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] - summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "st[idx] = (st[idx] + summ) % mod",
      "mutated_line": "st[idx] = st[idx] * summ % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = st[idx] * summ % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 * idx - 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx - 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 * idx * 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx * 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx - 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx - 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx * 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx * 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 2, mid - 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid - 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 2, mid * 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid * 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif re < ss or se < rs:",
      "mutated_line": "elif re <= ss or se < rs:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re <= ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif re < ss or se < rs:",
      "mutated_line": "elif re >= ss or se < rs:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re >= ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif re < ss or se < rs:",
      "mutated_line": "elif re != ss or se < rs:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re != ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif re < ss or se < rs:",
      "mutated_line": "elif re < ss or se <= rs:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se <= rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif re < ss or se < rs:",
      "mutated_line": "elif re < ss or se >= rs:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se >= rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif re < ss or se < rs:",
      "mutated_line": "elif re < ss or se != rs:",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se != rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 1\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return -1\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 1\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) / 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) / 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) * 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) * 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) * mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) * mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re) + mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re) + mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 - rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 - rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = 1 * rangesum(0, 1, 200000, 1, slippers[i] - 1) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = 1 * rangesum(0, 1, 200000, 1, slippers[i] - 1) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[1] + 1) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[1] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[-1] + 1) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[-1] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (st[0] + 1) % mod",
      "mutated_line": "return (st[1] + 1) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[1] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 / idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 / idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 + idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 + idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 ** idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 ** idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 * idx + 2, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 2, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 * idx + 0, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 0, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 * idx + 0, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 0, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(2 * idx + -1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + -1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 / idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 / idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 + idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 + idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 ** idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 ** idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 3, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 3, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 1, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 1, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 0, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 0, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 1, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 1, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + -2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + -2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 2, mid + 2, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 2, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 2, mid + 0, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 0, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 2, mid + 0, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 0, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(2 * idx + 2, mid + -1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + -1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 - 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 - 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 * 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 * 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 - 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 - 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 * 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 * 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss - se) // 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss - se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = ss * se // 2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = ss * se // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 3",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 3\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 1\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 0",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 0\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // 1",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 1\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (ss + se) // 2",
      "mutated_line": "mid = (ss + se) // -2",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // -2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) - rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) - rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return rangesum(2 * idx + 1, ss, mid, rs, re) * rangesum(2 * idx + 2, mid + 1, se, rs, re) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return rangesum(2 * idx + 1, ss, mid, rs, re) * rangesum(2 * idx + 2, mid + 1, se, rs, re) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (2 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (2 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (0 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (0 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (0 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (0 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (-1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (-1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(3 * idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(3 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(1 * idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(1 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(0 * idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(0 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(1 * idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(1 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "update(2 * idx + 1, ss, mid, summ, num)",
      "mutated_line": "update(-2 * idx + 1, ss, mid, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(-2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(3 * idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(3 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(1 * idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(1 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(0 * idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(0 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(1 * idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(1 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "update(2 * idx + 2, mid + 1, se, summ, num)",
      "mutated_line": "update(-2 * idx + 2, mid + 1, se, summ, num)",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(-2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx / 2 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx / 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx + 2 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx + 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx ** 2 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx ** 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 2] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 2] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 0] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 0] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 0] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 0] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + -1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + -1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx / 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx / 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx + 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx + 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx ** 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx ** 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 3]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 3]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 1]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 1]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 0]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 0]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 1]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 1]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + -2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + -2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(1, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(1, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(-1, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(-1, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(1, 1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(1, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 2, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 2, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 0, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 0, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 0, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 0, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, -1, 200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, -1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200001, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200001, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 199999, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 199999, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 0, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 0, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 1, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 1, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, -200000, 1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, -200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 2, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 2, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 0, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 0, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 0, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 0, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, -1, slippers[i] - 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, -1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] + 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] + 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] * 1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] * 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 3 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 3 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 1 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 1 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 0 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 0 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 1 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 1 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * -2 + 1] + st[idx * 2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * -2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 3 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 3 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 1 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 1 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 0 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 0 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 1 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 1 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod",
      "mutated_line": "st[idx] = (st[idx * 2 + 1] + st[idx * -2 + 2]) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * -2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx - 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx - 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx * 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx * 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx - 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx - 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx * 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx * 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid - 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid - 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid * 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid * 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 2)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 2)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 0)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 0)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 0)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 0)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod",
      "mutated_line": "count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - -1)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - -1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 / idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 / idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 + idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 + idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 ** idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 ** idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 2, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 2, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 0, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 0, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 0, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 0, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + -1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + -1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 / idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 / idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 + idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 + idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 ** idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 ** idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 3, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 3, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 1, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 1, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 0, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 0, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 1, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 1, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + -2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + -2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 2, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 2, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 0, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 0, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 0, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 0, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + -1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + -1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(3 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(3 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(1 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(1 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(0 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(0 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(1 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(1 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(-2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(-2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(3 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(3 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(1 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(1 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(0 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(0 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(1 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(1 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "mutated_line": "return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(-2 * idx + 2, mid + 1, se, rs, re)) % mod",
      "code": "def count_interesting_subsets(N, slippers):\n    c = 200000\n    mod = 998244353\n    st = [0] * (4 * c)\n\n    def update(idx, ss, se, summ, num):\n        if ss == se and ss == num:\n            st[idx] = (st[idx] + summ) % mod\n            return\n        mid = (ss + se) // 2\n        if mid >= num:\n            update(2 * idx + 1, ss, mid, summ, num)\n        else:\n            update(2 * idx + 2, mid + 1, se, summ, num)\n        st[idx] = (st[idx * 2 + 1] + st[idx * 2 + 2]) % mod\n\n    def rangesum(idx, ss, se, rs, re):\n        if rs <= ss and se <= re:\n            return st[idx]\n        elif re < ss or se < rs:\n            return 0\n        else:\n            mid = (ss + se) // 2\n            return (rangesum(2 * idx + 1, ss, mid, rs, re) + rangesum(-2 * idx + 2, mid + 1, se, rs, re)) % mod\n    for i in range(N):\n        count = 1\n        if slippers[i] != 1:\n            count = (1 + rangesum(0, 1, 200000, 1, slippers[i] - 1)) % mod\n        update(0, 1, 200000, count, slippers[i])\n    return (st[0] + 1) % mod"
    }
  ]
}