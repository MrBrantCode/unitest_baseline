{
  "task_id": "taco_15174",
  "entry_point": "min_exchanges_to_curry",
  "mutant_count": 164,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-2] / (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] / (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-2] + (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] + (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-2] ** (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] ** (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i == S - 1:",
      "mutated_line": "if i != S - 1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i != S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if j == T - 1:",
      "mutated_line": "if j != T - 1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j != T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-2] * (X + Y - Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y - Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-2] * ((X + Y) * Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * ((X + Y) * Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(d[p], d[q]) = (0, 0)",
      "mutated_line": "(d[p], d[q]) = (1, 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (1, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(d[p], d[q]) = (0, 0)",
      "mutated_line": "(d[p], d[q]) = (-1, 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (-1, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(d[p], d[q]) = (0, 0)",
      "mutated_line": "(d[p], d[q]) = (1, 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (1, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(d[p], d[q]) = (0, 0)",
      "mutated_line": "(d[p], d[q]) = (0, 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 1)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(d[p], d[q]) = (0, 0)",
      "mutated_line": "(d[p], d[q]) = (0, -1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, -1)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "(d[p], d[q]) = (0, 0)",
      "mutated_line": "(d[p], d[q]) = (0, 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 1)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) == -2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) == -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) - 1 if min(d[u], d[v]) != -2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) - 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) * 1 if min(d[u], d[v]) != -2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) * 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else +1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else +1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append(b + X + 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X + 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append((b + X) * 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append((b + X) * 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 1].append(a + 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a + 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 1].append(a * 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a * 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i == S - 1:",
      "mutated_line": "if i == S + 1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S + 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i == S - 1:",
      "mutated_line": "if i == S * 1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S * 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b + X + Y + 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y + 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append((b + X + Y) * 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append((b + X + Y) * 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append(a + X + 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X + 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append((a + X) * 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append((a + X) * 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if j == T - 1:",
      "mutated_line": "if j == T + 1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T + 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if j == T - 1:",
      "mutated_line": "if j == T * 1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T * 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [+2] * (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [+2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-2] * (X - Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X - Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-2] * (X * Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X * Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d[node] == -2:",
      "mutated_line": "if d[node] != -2:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] != -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != +2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != +2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 2 if min(d[u], d[v]) != -2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 2 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 0 if min(d[u], d[v]) != -2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 0 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 0 if min(d[u], d[v]) != -2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 0 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + -1 if min(d[u], d[v]) != -2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + -1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -2",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -0",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -0",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else --1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else --1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "g = [[] for _ in range(X + Y + Z)]",
      "mutated_line": "g = [[] for _ in range(X + Y - Z)]",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y - Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "g = [[] for _ in range(X + Y + Z)]",
      "mutated_line": "g = [[] for _ in range((X + Y) * Z)]",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range((X + Y) * Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append(b - X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b - X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append(b * X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b * X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append(b + X - 2)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 2)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append(b + X - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 0)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append(b + X - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 0)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 1].append(b + X - -1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - -1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 1].append(a - 2)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 2)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 1].append(a - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 0)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 1].append(a - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 0)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 1].append(a - -1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - -1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i == S - 1:",
      "mutated_line": "if i == S - 2:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 2:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i == S - 1:",
      "mutated_line": "if i == S - 0:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 0:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i == S - 1:",
      "mutated_line": "if i == S - 0:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 0:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i == S - 1:",
      "mutated_line": "if i == S - -1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - -1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a + 1, b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a + 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a * 1, b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a * 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, b + X + 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X + 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, (b + X) * 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, (b + X) * 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b + X - Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X - Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append((b + X) * Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append((b + X) * Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b + X + Y - 2)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 2)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b + X + Y - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 0)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b + X + Y - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 0)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b + X + Y - -1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - -1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append(a - X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a - X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append(a * X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a * X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append(a + X - 2)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 2)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append(a + X - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 0)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append(a + X - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 0)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 1].append(a + X - -1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - -1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == T - 1:",
      "mutated_line": "if j == T - 2:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 2:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == T - 1:",
      "mutated_line": "if j == T - 0:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 0:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == T - 1:",
      "mutated_line": "if j == T - 0:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 0:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == T - 1:",
      "mutated_line": "if j == T - -1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - -1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X + 1, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X + 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = ((a + X) * 1, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = ((a + X) * 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b + X + Y + 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y + 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, (b + X + Y) * 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, (b + X + Y) * 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-3] * (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-3] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-1] * (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-1] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-0] * (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-0] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [-1] * (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-1] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d = [-2] * (X + Y + Z)",
      "mutated_line": "d = [--2] * (X + Y + Z)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [--2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if d[node] == -2:",
      "mutated_line": "if d[node] == +2:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == +2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[node] = d[p] + 1",
      "mutated_line": "d[node] = d[p] - 1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] - 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[node] = d[p] + 1",
      "mutated_line": "d[node] = d[p] * 1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] * 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -3 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -3 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -1 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -0 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -1 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1",
      "mutated_line": "return min(d[u], d[v]) + 1 if min(d[u], d[v]) != --2 else -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != --2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "g = [[] for _ in range(X + Y + Z)]",
      "mutated_line": "g = [[] for _ in range(X - Y + Z)]",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X - Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "g = [[] for _ in range(X + Y + Z)]",
      "mutated_line": "g = [[] for _ in range(X * Y + Z)]",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X * Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a + 1].append(b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a + 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a * 1].append(b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a * 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X + 1].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X + 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[(b + X) * 1].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[(b + X) * 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 2, b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 2, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 0, b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 0, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 0, b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 0, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - -1, b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - -1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, b - X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b - X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, b * X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b * X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, b + X - 2)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 2)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, b + X - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 0)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, b + X - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 0)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(p, q) = (a - 1, b + X - 1)",
      "mutated_line": "(p, q) = (a - 1, b + X - -1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - -1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X + 1].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X + 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[(a + X) * 1].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[(a + X) * 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b - X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b - X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 1].append(b * X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b * X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y + 1].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y + 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[(b + X + Y) * 1].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[(b + X + Y) * 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a - X - 1, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a - X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a * X - 1, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a * X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 2, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 2, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 0, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 0, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 0, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 0, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - -1, b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - -1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b + X - Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X - Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, (b + X) * Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, (b + X) * Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b + X + Y - 2)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 2)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b + X + Y - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 0)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b + X + Y - 0)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 0)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b + X + Y - -1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - -1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if d[node] == -2:",
      "mutated_line": "if d[node] == -3:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -3:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if d[node] == -2:",
      "mutated_line": "if d[node] == -1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -1:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if d[node] == -2:",
      "mutated_line": "if d[node] == -0:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -0:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if d[node] == -2:",
      "mutated_line": "if d[node] == -1:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -1:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if d[node] == -2:",
      "mutated_line": "if d[node] == --2:",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == --2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[node] = d[p] + 1",
      "mutated_line": "d[node] = d[p] + 2",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 2\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[node] = d[p] + 1",
      "mutated_line": "d[node] = d[p] + 0",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 0\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[node] = d[p] + 1",
      "mutated_line": "d[node] = d[p] + 0",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 0\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[node] = d[p] + 1",
      "mutated_line": "d[node] = d[p] + -1",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + -1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 2].append(b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 2].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 0].append(b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 0].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - 0].append(b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 0].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[a - 1].append(b + X - 1)",
      "mutated_line": "g[a - -1].append(b + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - -1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b - X - 1].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b - X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b * X - 1].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b * X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 2].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 2].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 0].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 0].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - 0].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 0].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[b + X - 1].append(a - 1)",
      "mutated_line": "g[b + X - -1].append(a - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - -1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a - X - 1].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a - X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a * X - 1].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a * X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 2].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 2].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 0].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 0].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - 0].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 0].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[a + X - 1].append(b + X + Y - 1)",
      "mutated_line": "g[a + X - -1].append(b + X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - -1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X - Y - 1].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X - Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[(b + X) * Y - 1].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[(b + X) * Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 2].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 2].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 0].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 0].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - 0].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 0].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b + X + Y - -1].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - -1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b - X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b - X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(u, v) = (a + X - 1, b + X + Y - 1)",
      "mutated_line": "(u, v) = (a + X - 1, b * X + Y - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b + X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b * X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b - X + Y - 1].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b - X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "g[b + X + Y - 1].append(a + X - 1)",
      "mutated_line": "g[b * X + Y - 1].append(a + X - 1)",
      "code": "from collections import deque\n\ndef min_exchanges_to_curry(X, Y, Z, N, M, S, T, cutlet_sandwiches, cutlet_curries):\n    g = [[] for _ in range(X + Y + Z)]\n    for i in range(N):\n        (a, b) = cutlet_sandwiches[i]\n        g[a - 1].append(b + X - 1)\n        g[b + X - 1].append(a - 1)\n        if i == S - 1:\n            (p, q) = (a - 1, b + X - 1)\n    for j in range(M):\n        (a, b) = cutlet_curries[j]\n        g[a + X - 1].append(b + X + Y - 1)\n        g[b * X + Y - 1].append(a + X - 1)\n        if j == T - 1:\n            (u, v) = (a + X - 1, b + X + Y - 1)\n    d = [-2] * (X + Y + Z)\n    (d[p], d[q]) = (0, 0)\n    q = deque([p, q])\n    while q:\n        p = q.popleft()\n        for node in g[p]:\n            if d[node] == -2:\n                q.append(node)\n                d[node] = d[p] + 1\n    return min(d[u], d[v]) + 1 if min(d[u], d[v]) != -2 else -1"
    }
  ]
}