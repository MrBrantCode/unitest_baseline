{
  "task_id": "taco_2313",
  "entry_point": "fixed_xor",
  "mutant_count": 14,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return 'MUTATED'.join((f'{int(x, 16) ^ int(y, 16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return 'MUTATED'.join((f'{int(x, 16) ^ int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 16) | int(y, 16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) | int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) ^ int(y, 16):}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 17) ^ int(y, 16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 17) ^ int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 15) ^ int(y, 16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 15) ^ int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 0) ^ int(y, 16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 0) ^ int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 1) ^ int(y, 16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 1) ^ int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, -16) ^ int(y, 16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, -16) ^ int(y, 16):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 16) ^ int(y, 17):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) ^ int(y, 17):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 16) ^ int(y, 15):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) ^ int(y, 15):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 16) ^ int(y, 0):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) ^ int(y, 0):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 16) ^ int(y, 1):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) ^ int(y, 1):x}' for (x, y) in zip(a, b)))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return ''.join((f'{int(x, 16) ^ int(y, 16):x}' for x, y in zip(a, b)))",
      "mutated_line": "return ''.join((f'{int(x, 16) ^ int(y, -16):x}' for (x, y) in zip(a, b)))",
      "code": "def fixed_xor(a: str, b: str) -> str:\n    \"\"\"\n    Takes two hex strings as input and XORs them against each other.\n    If the strings are different lengths, the output will be the length of the shortest string.\n\n    Parameters:\n    a (str): The first hex string.\n    b (str): The second hex string.\n\n    Returns:\n    str: The XOR result as a hex string, truncated to the length of the shorter input.\n    \"\"\"\n    min_length = min(len(a), len(b))\n    (a, b) = (a[:min_length], b[:min_length])\n    return ''.join((f'{int(x, 16) ^ int(y, -16):x}' for (x, y) in zip(a, b)))"
    }
  ]
}