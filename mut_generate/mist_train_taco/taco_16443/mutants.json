{
  "task_id": "taco_16443",
  "entry_point": "minimum_assignment_cost",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] / n, [0] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] / n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] + n, [0] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] + n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] ** n, [0] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] ** n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] / n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] / n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] + n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] + n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] ** n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] ** n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] / n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] / n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] + n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] + n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] ** n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] ** n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while marki != -1:",
      "mutated_line": "while marki == -1:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki == -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "u[i] += delta",
      "mutated_line": "u[i] -= delta",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] -= delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while links[j] != -1:",
      "mutated_line": "while links[j] == -1:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] == -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] / n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] / n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] + n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] + n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] ** n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] ** n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1000] / n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] / n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1000] + n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] + n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1000] ** n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] ** n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] / n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] / n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] + n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] + n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] ** n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] ** n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "(marki, markj) = (i, -1)",
      "mutated_line": "(marki, markj) = (i, +1)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, +1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "while marki != -1:",
      "mutated_line": "while marki != +1:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != +1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "j = -1",
      "mutated_line": "j = +1",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = +1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visited[j] = True",
      "mutated_line": "visited[j] = False",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = False\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "while links[j] != -1:",
      "mutated_line": "while links[j] != +1:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != +1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i / n:(i + 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i / n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i + n:(i + 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i + n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i ** n:(i + 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i ** n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:(i + 1) / n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) / n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:i + 1 + n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:i + 1 + n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:(i + 1) ** n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) ** n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i / n:(i + 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i / n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i + n:(i + 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i + n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i ** n:(i + 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i ** n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:(i + 1) / n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) / n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:i + 1 + n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:i + 1 + n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:(i + 1) ** n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) ** n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([1] * n, [0] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([1] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([-1] * n, [0] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([-1] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([1] * n, [0] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([1] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [1] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [1] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [-1] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [-1] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [1] * n, [-1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [1] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [+1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [+1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(marki, markj) = (i, -1)",
      "mutated_line": "(marki, markj) = (i, -2)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -2)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(marki, markj) = (i, -1)",
      "mutated_line": "(marki, markj) = (i, -0)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -0)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(marki, markj) = (i, -1)",
      "mutated_line": "(marki, markj) = (i, -0)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -0)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(marki, markj) = (i, -1)",
      "mutated_line": "(marki, markj) = (i, --1)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, --1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while marki != -1:",
      "mutated_line": "while marki != -2:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -2:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while marki != -1:",
      "mutated_line": "while marki != -0:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -0:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while marki != -1:",
      "mutated_line": "while marki != -0:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -0:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while marki != -1:",
      "mutated_line": "while marki != --1:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != --1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = -1",
      "mutated_line": "j = -2",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -2\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = -1",
      "mutated_line": "j = -0",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -0\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = -1",
      "mutated_line": "j = -0",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -0\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = -1",
      "mutated_line": "j = --1",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = --1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "u[ind[j1]] += delta",
      "mutated_line": "u[ind[j1]] -= delta",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] -= delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "v[j1] -= delta",
      "mutated_line": "v[j1] += delta",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] += delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "mins[j1] -= delta",
      "mutated_line": "mins[j1] += delta",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] += delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while links[j] != -1:",
      "mutated_line": "while links[j] != -2:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -2:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while links[j] != -1:",
      "mutated_line": "while links[j] != -0:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -0:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while links[j] != -1:",
      "mutated_line": "while links[j] != -0:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -0:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while links[j] != -1:",
      "mutated_line": "while links[j] != --1:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != --1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:(i - 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i - 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:i * 1 * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:i * 1 * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:(i - 1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i - 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:i * 1 * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:i * 1 * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [-2] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-2] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [-0] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-0] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [-0] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-0] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(u, v, ind) = ([0] * n, [0] * n, [-1] * n)",
      "mutated_line": "(u, v, ind) = ([0] * n, [0] * n, [--1] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [--1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([+1] * n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([+1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1001] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1001] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [999] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [999] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [0] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [0] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [-1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [-1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [True] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [True] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "current = m[marki][j1] - u[marki] - v[j1]",
      "mutated_line": "current = m[marki][j1] - u[marki] + v[j1]",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] + v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "current = m[marki][j1] - u[marki] - v[j1]",
      "mutated_line": "current = (m[marki][j1] - u[marki]) * v[j1]",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = (m[marki][j1] - u[marki]) * v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current < mins[j1]:",
      "mutated_line": "if current <= mins[j1]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current <= mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current < mins[j1]:",
      "mutated_line": "if current >= mins[j1]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current >= mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current < mins[j1]:",
      "mutated_line": "if current != mins[j1]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current != mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == -1 and mins[j1] < mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 and mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:(i + 2) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 2) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:(i + 0) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 0) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:(i + 0) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 0) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m.append(l[i * n:(i + 1) * n])",
      "mutated_line": "m.append(l[i * n:(i + -1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + -1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:(i + 2) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 2) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:(i + 0) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 0) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:(i + 0) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 0) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mybeg.append(l[i * n:(i + 1) * n])",
      "mutated_line": "mybeg.append(l[i * n:(i + -1) * n])",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + -1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-2] * n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-2] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-0] * n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-0] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([-0] * n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-0] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)",
      "mutated_line": "(links, mins, visited) = ([--1] * n, [1000] * n, [False] * n)",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([--1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "current = m[marki][j1] - u[marki] - v[j1]",
      "mutated_line": "current = m[marki][j1] + u[marki] - v[j1]",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] + u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "current = m[marki][j1] - u[marki] - v[j1]",
      "mutated_line": "current = m[marki][j1] * u[marki] - v[j1]",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] * u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j != -1 or mins[j1] < mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j != -1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == -1 or mins[j1] <= mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] <= mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == -1 or mins[j1] >= mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] >= mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == -1 or mins[j1] != mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -1 or mins[j1] != mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == +1 or mins[j1] < mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == +1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == -2 or mins[j1] < mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -2 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == -0 or mins[j1] < mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -0 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == -0 or mins[j1] < mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == -0 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if j == -1 or mins[j1] < mins[j]:",
      "mutated_line": "if j == --1 or mins[j1] < mins[j]:",
      "code": "def minimum_assignment_cost(N, Arr):\n    n = N\n    l = Arr\n    m = []\n    mybeg = []\n    for i in range(n):\n        m.append(l[i * n:(i + 1) * n])\n        mybeg.append(l[i * n:(i + 1) * n])\n\n    def util():\n        (u, v, ind) = ([0] * n, [0] * n, [-1] * n)\n        for i in range(n):\n            (links, mins, visited) = ([-1] * n, [1000] * n, [False] * n)\n            (marki, markj) = (i, -1)\n            while marki != -1:\n                j = -1\n                for j1 in range(n):\n                    if not visited[j1]:\n                        current = m[marki][j1] - u[marki] - v[j1]\n                        if current < mins[j1]:\n                            mins[j1] = current\n                            links[j1] = markj\n                        if j == --1 or mins[j1] < mins[j]:\n                            j = j1\n                delta = mins[j]\n                for j1 in range(n):\n                    if visited[j1]:\n                        u[ind[j1]] += delta\n                        v[j1] -= delta\n                    else:\n                        mins[j1] -= delta\n                u[i] += delta\n                visited[j] = True\n                (markj, marki) = (j, ind[j])\n            while links[j] != -1:\n                ind[j] = ind[links[j]]\n                j = links[j]\n            ind[j] = i\n        return [(ind[j], j) for j in range(n)]\n    return sum((mybeg[x][y] for (x, y) in util()))"
    }
  ]
}